Index: backfire/feeds/packages/utils/autofs/Makefile
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/Makefile
@@ -0,0 +1,84 @@
+#
+# Copyright (C) 2006-2010 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=autofs
+PKG_VERSION:=5.0.5
+PKG_RELEASE:=1
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
+PKG_SOURCE_URL:=http://www.kernel.org/pub/linux/daemons/autofs/v5
+PKG_MD5SUM:=a1d262cb6ebef0c2dd0fe22232fb3d5a
+PKG_INSTALL:=1
+PKG_FIXUP:=autoreconf
+PKG_REMOVE_FILES:=
+
+AUTOFS_MODS := parse_sun.so \
+	mount_nfs4.so mount_nfs.so mount_generic.so mount_changer.so mount_bind.so mount_autofs.so mount_afs.so \
+	lookup_userhome.so lookup_program.so lookup_multi.so lookup_hosts.so lookup_files.so lookup_file.so lookup_dir.so
+
+AUTOFS_EXT2_MODS := mount_ext2.so mount_ext3.so mount_ext4.so
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/autofs5/common
+  SECTION:=utils
+  CATEGORY:=Utilities
+  SUBMENU:=Filesystem
+  TITLE:=Autofs Userspace Daemon
+  MAINTAINER:=Zhifeng Gu <guzhifeng1979@hotmail.com>
+  URL:=http://www.kernel.org/pub/linux/daemons/autofs/
+  DEPENDS+= +kmod-fs-autofs4 +libpthread
+endef
+
+define Package/autofs5
+  $(call Package/autofs5/common)
+  DEPENDS+= +kmod-fs-autofs4 +libpthread
+endef
+
+define Package/autofs5-mount-ext2
+  $(call Package/autofs5/common)
+  DEPENDS+= +autofs5 +e2fsprogs
+endef
+
+define Package/autofs5/conffiles
+/etc/config/autofs
+endef
+
+CONFIGURE_ARGS += --with-E2FSCK=/usr/sbin/e2fsck \
+				--with-E3FSCK=/usr/sbin/e2fsck \
+				--with-E4FSCK=/usr/sbin/e2fsck
+
+define Package/autofs5/install
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/sbin/automount $(1)/usr/sbin/
+	$(INSTALL_DIR) $(1)/usr/lib/autofs
+	for MOD in $(AUTOFS_MODS); do \
+		$(CP) $(PKG_INSTALL_DIR)/usr/lib/autofs/$$$$MOD $(1)/usr/lib/autofs/; \
+	done
+	$(INSTALL_DIR) $(1)/etc/config
+	$(INSTALL_DATA) ./files/autofs.conf $(1)/etc/config/autofs
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_BIN) ./files/autofs.init $(1)/etc/init.d/autofs
+	$(INSTALL_DIR) $(1)/etc/hotplug.d/block
+	$(INSTALL_DATA) ./files/50-autofs $(1)/etc/hotplug.d/block
+	$(INSTALL_DIR) $(1)/lib/functions/autofs
+	$(INSTALL_DATA) ./files/autofs.sh $(1)/lib/functions
+	$(INSTALL_BIN) ./files/direct.fstab $(1)/lib/functions/autofs
+	ln -sf /tmp/auto.master $(1)/etc/
+endef
+
+define Package/autofs5-mount-ext2/install
+	$(INSTALL_DIR) $(1)/usr/lib/autofs
+	for MOD in $(AUTOFS_EXT2_MODS); do \
+		$(CP) $(PKG_INSTALL_DIR)/usr/lib/autofs/$$$$MOD $(1)/usr/lib/autofs/; \
+	done
+endef
+
+$(eval $(call BuildPackage,autofs5))
+$(eval $(call BuildPackage,autofs5-mount-ext2))
Index: backfire/feeds/packages/utils/autofs/patches/200-fix-configure-not-run-when-cross-compiling
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/200-fix-configure-not-run-when-cross-compiling
@@ -0,0 +1,13 @@
+Index: autofs-5.0.5/configure.in
+===================================================================
+--- autofs-5.0.5.orig/configure.in
++++ autofs-5.0.5/configure.in
+@@ -292,7 +292,7 @@
+ DAEMON_CFLAGS=
+ DAEMON_LDFLAGS=
+ AC_MSG_CHECKING([whether gcc -fPIE works])
+-AC_RUN_IFELSE([AC_LANG_PROGRAM([[]], [[int main(void) {return 0;}]])],
++AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[int main(void) {return 0;}]])],
+ 	      [gcc_supports_pie=yes], [gcc_supports_pie=no])
+ AC_MSG_RESULT([$gcc_supports_pie])
+ if test $gcc_supports_pie = yes ; then
Index: backfire/feeds/packages/utils/autofs/patches/202-disable-yp-lookup
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/202-disable-yp-lookup
@@ -0,0 +1,40 @@
+Index: autofs-5.0.5/lib/Makefile
+===================================================================
+--- autofs-5.0.5.orig/lib/Makefile
++++ autofs-5.0.5/lib/Makefile
+@@ -10,7 +10,7 @@
+ 	args.c alarm.c macros.c master.c defaults.c parse_subs.c \
+ 	dev-ioctl-lib.c
+ RPCS = mount.h mount_clnt.c mount_xdr.c
+-OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o rpc_subs.o \
++OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o \
+ 	mounts.o log.o nsswitch.o master_tok.o master_parse.tab.o \
+ 	nss_tok.o nss_parse.tab.o args.o alarm.o macros.o master.o \
+ 	defaults.o parse_subs.o dev-ioctl-lib.o
+Index: autofs-5.0.5/modules/Makefile
+===================================================================
+--- autofs-5.0.5.orig/modules/Makefile
++++ autofs-5.0.5/modules/Makefile
+@@ -11,7 +11,7 @@
+ 	mount_generic.c  mount_nfs.c  mount_afs.c  mount_autofs.c \
+ 	mount_changer.c  mount_bind.c
+ 
+-MODS :=	lookup_yp.so lookup_file.so lookup_program.so lookup_userhome.so \
++MODS :=	lookup_file.so lookup_program.so lookup_userhome.so \
+ 	lookup_multi.so lookup_hosts.so \
+ 	parse_sun.so \
+ 	mount_generic.so mount_nfs.so mount_afs.so mount_autofs.so \
+Index: autofs-5.0.5/daemon/lookup.c
+===================================================================
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -169,9 +169,6 @@
+ 
+ 			memset(source, 0, 10);
+ 			if (!strncmp(name, "file:", 5) ||
+-			    !strncmp(name, "yp:", 3) ||
+-			    !strncmp(name, "nis:", 4) ||
+-			    !strncmp(name, "nisplus:", 8) ||
+ 			    !strncmp(name, "ldap:", 5) ||
+ 			    !strncmp(name, "ldaps:", 6)) {
+ 				strncpy(source, name, tmp - name);
Index: backfire/feeds/packages/utils/autofs/patches/203-disable-ldap-code-in-defaults
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/203-disable-ldap-code-in-defaults
@@ -0,0 +1,46 @@
+--- a/lib/defaults.c	2011-06-28 15:34:35.000000000 +0800
++++ b/lib/defaults.c	2012-02-28 16:46:53.000000000 +0800
+@@ -19,7 +19,9 @@
+ 
+ #include "list.h"
+ #include "defaults.h"
++#ifdef WITH_LDAP
+ #include "lookup_ldap.h"
++#endif
+ #include "log.h"
+ #include "automount.h"
+ 
+@@ -197,6 +199,8 @@
+ 	return 1;
+ }
+ 
++#ifdef WITH_LDAP
++
+ void defaults_free_uris(struct list_head *list)
+ {
+ 	struct list_head *next;
+@@ -290,6 +294,8 @@
+ 	return list;
+ }
+ 
++#endif
++
+ /*
+  * Read config env variables and check they have been set.
+  *
+@@ -428,6 +434,7 @@
+ 	return logging;
+ }
+ 
++#ifdef WITH_LDAP
+ unsigned int defaults_get_ldap_timeout(void)
+ {
+ 	int res;
+@@ -645,6 +652,7 @@
+ 
+ 	return schema;
+ }
++#endif
+ 
+ unsigned int defaults_get_mount_nfs_default_proto(void)
+ {
Index: backfire/feeds/packages/utils/autofs/patches/205-fix-install-symlinks
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/205-fix-install-symlinks
@@ -0,0 +1,15 @@
+Index: autofs-5.0.5/modules/Makefile
+===================================================================
+--- autofs-5.0.5.orig/modules/Makefile
++++ autofs-5.0.5/modules/Makefile
+@@ -62,8 +62,9 @@
+ 	install -c $(MODS) -m 755 $(INSTALLROOT)$(autofslibdir)
+ 	-rm -f $(INSTALLROOT)$(autofslibdir)/mount_smbfs.so
+ 	ln -fs lookup_file.so $(INSTALLROOT)$(autofslibdir)/lookup_files.so
+-	ln -fs lookup_yp.so $(INSTALLROOT)$(autofslibdir)/lookup_nis.so
++ifeq ($(LDAP), 1)
+ 	ln -fs lookup_ldap.so $(INSTALLROOT)$(autofslibdir)/lookup_ldaps.so
++endif
+ 	ln -fs mount_nfs.so $(INSTALLROOT)$(autofslibdir)/mount_nfs4.so
+ ifeq ($(EXT2FS), 1)
+  ifeq ($(EXT3FS), 1)
Index: backfire/feeds/packages/utils/autofs/patches/201-uclibc-compat
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/201-uclibc-compat
@@ -0,0 +1,11 @@
+--- a/include/rpc_subs.h	2011-06-28 15:34:35.000000000 +0800
++++ b/include/rpc_subs.h	2012-02-28 15:42:51.000000000 +0800
+@@ -18,7 +18,7 @@
+ 
+ #include <rpc/rpc.h>
+ #include <rpc/pmap_prot.h>
+-#include <nfs/nfs.h>
++#include <linux/nfs.h>
+ #include <linux/nfs2.h>
+ #include <linux/nfs3.h>
+ 
Index: backfire/feeds/packages/utils/autofs/files/autofs.init
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.init
@@ -0,0 +1,88 @@
+#!/bin/sh /etc/rc.common
+#
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+START=21
+STOP=98
+
+MASTER_FILE=/tmp/auto.master
+AUTOMOUNT_OPTS=
+
+. /lib/functions/autofs.sh
+
+create_map_entry() {
+    local cfg="$1"
+    local entry type maptype mountpoint map timeout
+
+    config_get type "$cfg" type
+    case "$type" in
+        direct)
+            mountpoint=/-
+            ;;
+        indirect)
+            config_get mountpoint "$cfg" mountpoint
+            ;;
+        *)
+            logger -t "autofs" "unknown map type: $type"
+            return
+    esac
+
+    config_get maptype "$cfg" maptype
+    config_get map "$cfg" map
+
+    entry="$mountpoint\t\t$maptype:$map"
+
+    config_get timeout "$cfg" timeout
+    if [ -n "$timeout" ]; then
+        entry="$entry\t\t-DTIMEOUT=$timeout"
+    fi
+
+    echo -e $entry >> $MASTER_FILE
+}
+
+automount_options() {
+    local cfg="$1"
+    local timeout
+
+    config_get timeout "$cfg" timeout
+    if [ -n "$timeout" ]; then
+        AUTOMOUNT_OPTS="$AUTOMOUNT_OPTS -t $timeout"
+    fi
+}
+
+start_daemon() {
+    . /etc/functions.sh
+
+    config_load autofs
+    echo "# Auto generated map entries, please modify /etc/config/autofs." > $MASTER_FILE
+    config_foreach create_map_entry mapentry
+    config_foreach automount_options automount
+    automount -p $AUTOMOUNT_PIDFILE $AUTOMOUNT_OPTS
+}
+
+start() {
+    if is_running; then
+        logger -t "autofs" "automount is already running"
+        return
+    fi
+    start_daemon
+}
+
+stop() {
+    if ! is_running; then
+        return
+    fi
+    kill -TERM `cat $AUTOMOUNT_PIDFILE`
+    rm -f $AUTOMOUNT_PIDFILE
+    echo "# Autofs is stopped" > $MASTER_FILE
+}
+
+restart() {
+    if is_running; then
+        reload_config
+    else
+        start_daemon
+    fi
+}
Index: backfire/feeds/packages/utils/autofs/files/50-autofs
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/50-autofs
@@ -0,0 +1,13 @@
+#!/bin/sh
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+blkdev=`dirname $DEVPATH`
+
+if [ `basename $blkdev` != "block" ]; then
+    . /lib/functions/autofs.sh
+    if is_running; then
+        reload_config
+    fi
+fi
Index: backfire/feeds/packages/utils/autofs/files/autofs.conf
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.conf
@@ -0,0 +1,13 @@
+config automount
+       option timeout   300
+
+config mapentry
+       option type      direct
+       option maptype   file
+       option map       /lib/functions/autofs/direct.fstab
+
+#config mapentry
+#       option type         indirect
+#       option mountpoint   /home
+#       option maptype      file
+#       option map          /etc/auto.home
Index: backfire/feeds/packages/utils/autofs/files/direct.fstab
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/direct.fstab
@@ -0,0 +1,49 @@
+#!/bin/sh
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+. /etc/functions.sh
+
+direct_mount() {
+    local cfg="$1"
+    local is_rootfs target uuid device label fstype options enabled
+
+    # ignore rootfs targets
+    config_get_bool is_rootfs "$cfg" is_rootfs 0
+    if [ "is_rootfs" = 1 ]; then
+        return
+    fi
+    config_get target "$cfg" target
+    if [ -z "$target" ] || [ "$target" = / ] || [ "$target" = /overlay ]; then
+        return
+    fi
+    # ignore enabled mount entries
+    config_get_bool enabled "$cfg" enabled 1
+    if [ "$enabled" = 1 ]; then
+        return
+    fi
+
+    config_get device "$cfg" device
+    config_get label "$cfg" label
+    config_get uuid "$cfg" uuid
+    if [ -n "$uuid" ] && blkid | grep -q UUID=\"$uuid\"; then
+        device="UUID=$uuid"
+    elif [ -n "$label" ] && blkid | grep -q LABEL=\"$label\"; then
+        device="LABEL=$label"
+    elif [ -z "$device" ] || ! blkid | grep -q ^$device; then
+        return
+    fi
+
+    config_get fstype "$cfg" fstype "auto"
+    config_get options "$cfg" options
+    if [ -z "$options" ]; then
+        options="-fstype=$fstype"
+    else
+        options="-fstype=$fstype,$options"
+    fi
+    echo -e "$target\t\t$options\t\t:$device"
+}
+
+config_load fstab
+config_foreach direct_mount mount
Index: backfire/feeds/packages/utils/autofs/patches/206-disable-parsing-nsswitch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/206-disable-parsing-nsswitch
@@ -0,0 +1,33 @@
+--- a/lib/nsswitch.c	2011-06-28 15:34:35.000000000 +0800
++++ b/lib/nsswitch.c	2012-03-04 00:03:06.000000000 +0800
+@@ -105,6 +105,12 @@
+ 	return 1;
+ }
+ 
++int nsswitch_parse(struct list_head *list)
++{
++    return add_source(list, "files") ? 0 : 1;
++}
++
++
+ /*
+ int main(void)
+ {
+--- a/lib/Makefile	2012-03-02 23:47:09.000000000 +0800
++++ b/lib/Makefile	2012-03-04 00:02:11.000000000 +0800
+@@ -6,13 +6,13 @@
+ include ../Makefile.rules
+ 
+ SRCS = cache.c cat_path.c rpc_subs.c mounts.c log.c nsswitch.c \
+-	master_tok.l master_parse.y nss_tok.c nss_parse.tab.c \
++	master_tok.l master_parse.y \
+ 	args.c alarm.c macros.c master.c defaults.c parse_subs.c \
+ 	dev-ioctl-lib.c
+ RPCS = mount.h mount_clnt.c mount_xdr.c
+ OBJS = cache.o mount_clnt.o mount_xdr.o cat_path.o \
+ 	mounts.o log.o nsswitch.o master_tok.o master_parse.tab.o \
+-	nss_tok.o nss_parse.tab.o args.o alarm.o macros.o master.o \
++	args.o alarm.o macros.o master.o \
+ 	defaults.o parse_subs.o dev-ioctl-lib.o
+ 
+ YACCSRC = nss_tok.c nss_parse.tab.c nss_parse.tab.h \
Index: backfire/feeds/packages/utils/autofs/patches/207-make-runtime-dep-commands-configurable
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/207-make-runtime-dep-commands-configurable
@@ -0,0 +1,59 @@
+Index: autofs-5.0.5/aclocal.m4
+===================================================================
+--- autofs-5.0.5.orig/aclocal.m4
++++ autofs-5.0.5/aclocal.m4
+@@ -5,15 +5,22 @@
+ dnl Like AC_PATH_PROGS, but add to the .h file as well
+ dnl --------------------------------------------------------------------------
+ AC_DEFUN(AF_PATH_INCLUDE,
+-[AC_PATH_PROGS($1,$2,$3,$4)
+-if test -n "$$1"; then
+-  AC_DEFINE(HAVE_$1,1,[define if you have $1])
+-  AC_DEFINE_UNQUOTED(PATH_$1, "$$1", [define if you have $1])
++[ 
++  $1="$2"
++  AC_ARG_WITH($1,
++  [  --with-$1=PATH	  override the default value with PATH ],
++	 if test -n "$withval"
++     then
++       $1="${withval}"
++     fi
++  )
++  AC_MSG_CHECKING([for $1 executable])
++  AC_MSG_RESULT([$$1])
++
++  AC_DEFINE(HAVE_$1,1,[define $1])
++  AC_DEFINE_UNQUOTED(PATH_$1, "$$1", [define $1])
+   HAVE_$1=1
+-else
+-  HAVE_$1=0
+-fi
+-AC_SUBST(HAVE_$1)])
++  AC_SUBST(HAVE_$1)])
+ 
+ dnl --------------------------------------------------------------------------
+ dnl AF_CHECK_PROG:
+Index: autofs-5.0.5/configure.in
+===================================================================
+--- autofs-5.0.5.orig/configure.in
++++ autofs-5.0.5/configure.in
+@@ -127,12 +127,13 @@
+ #
+ # Programs needed for various system functions or modules
+ #
+-AF_PATH_INCLUDE(MOUNT, mount, /bin/mount, $searchpath)
+-AF_PATH_INCLUDE(UMOUNT, umount, /bin/umount, $searchpath)
+-AF_PATH_INCLUDE(E2FSCK, fsck.ext2 e2fsck, , $searchpath)
+-AF_PATH_INCLUDE(E3FSCK, fsck.ext3 e3fsck, , $searchpath)
+-AF_PATH_INCLUDE(E4FSCK, fsck.ext4 e4fsck, , $searchpath)
+-AF_PATH_INCLUDE(MODPROBE, modprobe, , $searchpath)
++AF_PATH_INCLUDE(MOUNT, /bin/mount)
++AF_PATH_INCLUDE(MOUNT_NFS, /sbin/mount.nfs)
++AF_PATH_INCLUDE(UMOUNT, /bin/umount)
++AF_PATH_INCLUDE(E2FSCK, /sbin/fsck.ext2)
++AF_PATH_INCLUDE(E3FSCK, /sbin/fsck.ext3)
++AF_PATH_INCLUDE(E4FSCK, /sbin/fsck.ext4)
++AF_PATH_INCLUDE(MODPROBE, /sbin/modprobe)
+ 
+ AF_CHECK_PROG(LEX, flex lex, , $searchpath)
+ AF_CHECK_PROG(YACC, bison, , $searchpath)
Index: backfire/feeds/packages/utils/autofs/patches/208-dynamic-lookup-file
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/208-dynamic-lookup-file
@@ -0,0 +1,95 @@
+Index: autofs-5.0.5/modules/lookup_file.c
+===================================================================
+--- autofs-5.0.5.orig/modules/lookup_file.c
++++ autofs-5.0.5/modules/lookup_file.c
+@@ -49,6 +49,54 @@
+ 
+ int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
+ 
++static FILE *open_fopen_r_dyn(const char *path)
++{
++    FILE  *f;
++    pid_t pid;
++    int   pipefd[2];
++    
++    if (!access(path, X_OK)) {
++        debug(LOGOPT_NONE, "%s is executable, load it as dynamic file", path);
++
++        // execute the file and pipe the stdout
++        if (pipe(pipefd)) {
++            logerr(MODPREFIX "fail to create pipe");
++            return NULL;
++        }
++
++        pid = fork();
++        if (pid < 0) {
++            logerr(MODPREFIX "fork error");
++            return NULL;
++        }
++
++        if (pid == 0) { // execute the file
++            close(pipefd[0]);
++            dup2(pipefd[1], STDOUT_FILENO);
++            close(pipefd[1]);
++            execl(path, path, NULL);
++            logerr(MODPREFIX "fail to execute %s", path);
++            exit(255);	/* execl() failed */
++        }
++
++        // wrap the pipe read endpoint, and return
++        close(pipefd[1]);
++        f = fdopen(pipefd[0], "r");
++    }
++    else
++        f = fopen(path, "r");
++
++    if (f == NULL) {
++        logerr(MODPREFIX "open file error: %s", strerror(errno));
++        return NULL;
++    }
++#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
++    check_cloexec(fileno(f));
++#endif
++    return f;
++}
++
++
+ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context)
+ {
+ 	struct lookup_context *ctxt;
+@@ -393,7 +441,7 @@
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(logopt,
+ 		      MODPREFIX "could not open master map file %s",
+@@ -609,7 +657,7 @@
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
+@@ -704,7 +752,7 @@
+ 
+ 	mc = source->mc;
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
+@@ -809,7 +857,7 @@
+ 
+ 	mc = source->mc;
+ 
+-	f = open_fopen_r(ctxt->mapname);
++	f = open_fopen_r_dyn(ctxt->mapname);
+ 	if (!f) {
+ 		error(ap->logopt,
+ 		      MODPREFIX "could not open map file %s", ctxt->mapname);
Index: backfire/feeds/packages/utils/autofs/files/autofs.sh
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/files/autofs.sh
@@ -0,0 +1,19 @@
+#!/bin/sh
+#
+# Author: Zhifeng Gu <guzhifeng1979@hotmail.com>
+# Date: 2012/03
+# License: GPL
+
+AUTOMOUNT_PIDFILE=/var/run/automount.pid
+
+is_running() {
+    if [ ! -e $AUTOMOUNT_PIDFILE ]; then
+        return 1
+    fi
+    ps -p `cat $AUTOMOUNT_PIDFILE` &> /dev/null
+    return $?
+}
+
+reload_config() {
+    kill -HUP `cat $AUTOMOUNT_PIDFILE`
+}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.4-add-mount-wait-parameter.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.4-add-mount-wait-parameter.patch
@@ -0,0 +1,172 @@
+autofs-5.0.4 - add mount wait parameter
+
+From: Ian Kent <raven@themaw.net>
+
+Often delays when trying to mount from a server that is not reponding
+for some reason are undesirable. To try and prevent these delays we
+provide a configuration setting to limit the time that we wait for
+our spawned mount(8) process to complete before sending it a SIGTERM
+signal. This patch adds a configuration parameter to allow us to
+request we limit the time we wait for mount(8) to complete before
+send it a TERM signal.
+---
+
+ CHANGELOG                      |    1 +
+ daemon/spawn.c                 |    3 ++-
+ include/defaults.h             |    2 ++
+ lib/defaults.c                 |   13 +++++++++++++
+ man/auto.master.5.in           |    7 +++++++
+ redhat/autofs.sysconfig.in     |    9 +++++++++
+ samples/autofs.conf.default.in |    9 +++++++++
+ 7 files changed, 43 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 5adcca5..fadb229 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -2,6 +2,7 @@
+ -----------------------
+ - fix included map read fail handling.
+ - refactor ldap sasl bind handling.
++- add mount wait timeout parameter.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/spawn.c b/daemon/spawn.c
+index e02d926..db356d4 100644
+--- a/daemon/spawn.c
++++ b/daemon/spawn.c
+@@ -305,6 +305,7 @@ int spawn_mount(unsigned logopt, ...)
+ 	unsigned int options;
+ 	unsigned int retries = MTAB_LOCK_RETRIES;
+ 	int update_mtab = 1, ret, printed = 0;
++	unsigned int wait = defaults_get_mount_wait();
+ 	char buf[PATH_MAX];
+ 
+ 	/* If we use mount locking we can't validate the location */
+@@ -355,7 +356,7 @@ int spawn_mount(unsigned logopt, ...)
+ 	va_end(arg);
+ 
+ 	while (retries--) {
+-		ret = do_spawn(logopt, -1, options, prog, (const char **) argv);
++		ret = do_spawn(logopt, wait, options, prog, (const char **) argv);
+ 		if (ret & MTAB_NOTUPDATED) {
+ 			struct timespec tm = {3, 0};
+ 
+diff --git a/include/defaults.h b/include/defaults.h
+index 9bf16e5..cda2174 100644
+--- a/include/defaults.h
++++ b/include/defaults.h
+@@ -24,6 +24,7 @@
+ 
+ #define DEFAULT_TIMEOUT			600
+ #define DEFAULT_NEGATIVE_TIMEOUT	60
++#define DEFAULT_MOUNT_WAIT		-1
+ #define DEFAULT_UMOUNT_WAIT		12
+ #define DEFAULT_BROWSE_MODE		1
+ #define DEFAULT_LOGGING			0
+@@ -64,6 +65,7 @@ struct ldap_searchdn *defaults_get_searchdns(void);
+ void defaults_free_searchdns(struct ldap_searchdn *);
+ unsigned int defaults_get_mount_nfs_default_proto(void);
+ unsigned int defaults_get_append_options(void);
++unsigned int defaults_get_mount_wait(void);
+ unsigned int defaults_get_umount_wait(void);
+ const char *defaults_get_auth_conf_file(void);
+ unsigned int defaults_get_map_hash_table_size(void);
+diff --git a/lib/defaults.c b/lib/defaults.c
+index 17164bd..2204b18 100644
+--- a/lib/defaults.c
++++ b/lib/defaults.c
+@@ -47,6 +47,7 @@
+ 
+ #define ENV_MOUNT_NFS_DEFAULT_PROTOCOL	"MOUNT_NFS_DEFAULT_PROTOCOL"
+ #define ENV_APPEND_OPTIONS		"APPEND_OPTIONS"
++#define ENV_MOUNT_WAIT			"MOUNT_WAIT"
+ #define ENV_UMOUNT_WAIT			"UMOUNT_WAIT"
+ #define ENV_AUTH_CONF_FILE		"AUTH_CONF_FILE"
+ 
+@@ -325,6 +326,7 @@ unsigned int defaults_read_config(unsigned int to_syslog)
+ 		    check_set_config_value(key, ENV_NAME_ENTRY_ATTR, value, to_syslog) ||
+ 		    check_set_config_value(key, ENV_NAME_VALUE_ATTR, value, to_syslog) ||
+ 		    check_set_config_value(key, ENV_APPEND_OPTIONS, value, to_syslog) ||
++		    check_set_config_value(key, ENV_MOUNT_WAIT, value, to_syslog) ||
+ 		    check_set_config_value(key, ENV_UMOUNT_WAIT, value, to_syslog) ||
+ 		    check_set_config_value(key, ENV_AUTH_CONF_FILE, value, to_syslog) ||
+ 		    check_set_config_value(key, ENV_MAP_HASH_TABLE_SIZE, value, to_syslog) ||
+@@ -667,6 +669,17 @@ unsigned int defaults_get_append_options(void)
+ 	return res;
+ }
+ 
++unsigned int defaults_get_mount_wait(void)
++{
++	long wait;
++
++	wait = get_env_number(ENV_MOUNT_WAIT);
++	if (wait < 0)
++		wait = DEFAULT_MOUNT_WAIT;
++
++	return (unsigned int) wait;
++}
++
+ unsigned int defaults_get_umount_wait(void)
+ {
+ 	long wait;
+diff --git a/man/auto.master.5.in b/man/auto.master.5.in
+index 71c4402..792035f 100644
+--- a/man/auto.master.5.in
++++ b/man/auto.master.5.in
+@@ -174,6 +174,13 @@ Set the default timeout for caching failed key lookups (program default
+ 60). If the equivalent command line option is given it will override this
+ setting.
+ .TP
++.B MOUNT_WAIT
++Set the default time to wait for a response from a spawned mount(8)
++before sending it a SIGTERM. Note that we still need to wait for the
++RPC layer to timeout before the sub-process exits so this isn't ideal
++but it is the best we can do. The default is to wait until mount(8)
++returns without intervention.
++.TP
+ .B UMOUNT_WAIT
+ Set the default time to wait for a response from a spawned umount(8)
+ before sending it a SIGTERM. Note that we still need to wait for the
+diff --git a/redhat/autofs.sysconfig.in b/redhat/autofs.sysconfig.in
+index 37448ea..c72cd2b 100644
+--- a/redhat/autofs.sysconfig.in
++++ b/redhat/autofs.sysconfig.in
+@@ -14,6 +14,15 @@ TIMEOUT=300
+ #
+ #NEGATIVE_TIMEOUT=60
+ #
++# MOUNT_WAIT - time to wait for a response from umount(8).
++# 	       Setting this timeout can cause problems when
++# 	       mount would otherwise wait for a server that
++# 	       is temporarily unavailable, such as when it's
++# 	       restarting. The defailt of waiting for mount(8)
++# 	       usually results in a wait of around 3 minutes.
++#
++#MOUNT_WAIT=-1
++#
+ # UMOUNT_WAIT - time to wait for a response from umount(8).
+ #
+ #UMOUNT_WAIT=12
+diff --git a/samples/autofs.conf.default.in b/samples/autofs.conf.default.in
+index 7dee5fd..b87c4d0 100644
+--- a/samples/autofs.conf.default.in
++++ b/samples/autofs.conf.default.in
+@@ -14,6 +14,15 @@ TIMEOUT=300
+ #
+ #NEGATIVE_TIMEOUT=60
+ #
++# MOUNT_WAIT - time to wait for a response from umount(8).
++# 	       Setting this timeout can cause problems when
++# 	       mount would otherwise wait for a server that
++# 	       is temporarily unavailable, such as when it's
++# 	       restarting. The defailt of waiting for mount(8)
++# 	       usually results in a wait of around 3 minutes.
++#
++#MOUNT_WAIT=-1
++#
+ # UMOUNT_WAIT - time to wait for a response from umount(8).
+ #
+ #UMOUNT_WAIT=12
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-autofs_ldap_auth_conf-man-page.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-autofs_ldap_auth_conf-man-page.patch
@@ -0,0 +1,242 @@
+autofs-5.0.5 - add autofs_ldap_auth.conf man page
+
+From: Ian Kent <raven@themaw.net>
+
+
+---
+
+ CHANGELOG                      |    1 
+ man/auto.master.5.in           |    3 +
+ man/autofs.5                   |    1 
+ man/autofs.8.in                |    1 
+ man/autofs_ldap_auth.conf.5.in |   92 +++++++++++++++++++++++++++++++++++++++++
+ man/automount.8                |    1 
+ samples/autofs_ldap_auth.conf  |   61 ---------------------------
+ 7 files changed, 100 insertions(+), 60 deletions(-)
+ create mode 100644 man/autofs_ldap_auth.conf.5.in
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -24,6 +24,7 @@
+ - fix strdup() return value check (Leonardo Chiquitto).
+ - fix get query dn failure.
+ - fix ampersand escape in auto.smb.
++- add autofs_ldap_auth.conf man page.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/man/auto.master.5.in
++++ autofs-5.0.5/man/auto.master.5.in
+@@ -365,6 +365,8 @@ and set the location of the client certi
+ in the per-user configuration. The location of these files and the configuration
+ entry requirements is system dependent so the documentation for your
+ installation will need to be consulted to get further information.
++.P
++See \fBautofs_ldap_auth.conf\fP(5) for more information.
+ .SH EXAMPLE
+ .sp
+ .RS +.2i
+@@ -399,6 +401,7 @@ configuration will be used to locate the
+ .BR automount (8),
+ .BR autofs (5),
+ .BR autofs (8).
++.BR autofs_ldap_auth.conf (5)
+ .SH AUTHOR
+ This manual page was written by Christoph Lameter <chris@waterf.org>,
+ for the Dean GNU/Linux system.  Edited by <hpa@transmeta.com> and
+--- autofs-5.0.5.orig/man/autofs.5
++++ autofs-5.0.5/man/autofs.5
+@@ -229,6 +229,7 @@ and LDAP only.
+ .BR auto.master (5),
+ .BR autofs (8),
+ .BR mount (8).
++.BR autofs_ldap_auth.conf (5)
+ .SH AUTHOR
+ This manual page was written by Christoph Lameter <chris@waterf.org>,
+ for the Debian GNU/Linux system.  Edited by H. Peter Avian
+--- autofs-5.0.5.orig/man/autofs.8.in
++++ autofs-5.0.5/man/autofs.8.in
+@@ -50,6 +50,7 @@ will display the status of,
+ .BR automount (8),
+ .BR autofs (5),
+ .BR auto.master (5).
++.BR autofs_ldap_auth.conf (5)
+ .SH AUTHOR
+ This manual page was written by Christoph Lameter <chris@waterf.org>,
+ for the Debi GNU/Linux system.  Edited by H. Peter Anvin
+--- /dev/null
++++ autofs-5.0.5/man/autofs_ldap_auth.conf.5.in
+@@ -0,0 +1,92 @@
++.\" t
++.TH AUTOFS_LDAP_AUTH.CONF 5 "19 Feb 2010"
++.SH NAME
++autofs_ldap_auth.conf \- autofs LDAP authentication configuration
++.SH "DESCRIPTION"
++LDAP authenticated binds, TLS encrypted connections and certification
++may be used by setting appropriate values in the autofs authentication
++configuration file and configuring the LDAP client with appropriate
++settings.  The default location of this file is
++.nh
++.BR @@autofsmapdir@@/autofs_ldap_auth.conf .
++.hy
++If this file exists it will be used to establish whether TLS or authentication
++should be used.
++.P
++An example of this file is:
++.sp
++.RS +.2i
++.ta 1.0i
++.nf
++<?xml version="1.0" ?>
++<autofs_ldap_sasl_conf
++        usetls="yes"
++        tlsrequired="no"
++        authrequired="no"
++        authtype="DIGEST-MD5"
++        user="xyz"
++        secret="abc"
++/>
++.fi
++.RE
++.sp
++If TLS encryption is to be used the location of the Certificate Authority
++certificate must be set within the LDAP client configuration in 
++order to validate the server certificate. If, in addition, a certified
++connection is to be used then the client certificate and private key file
++locations must also be configured within the LDAP client.
++.SH "OPTIONS"
++This files contains a single XML element, as shown in the example above, with
++several attributes.
++.TP
++The possible attributes are:
++.TP
++\fBusetls="yes"|"no"\fP
++Determines whether an encrypted connection to the ldap server
++should be attempted.
++.TP
++\fBtlsrequired="yes"|"no"\fP
++This flag tells whether the ldap connection must be encrypted. If set to "yes",
++the automounter will fail to start if an encrypted connection cannot be
++established.
++.TP
++\fBauthrequired="yes"|"no"|"autodetect"\fP
++This option tells whether an authenticated connection to the ldap server is
++required in order to perform ldap queries. If this flag is set to yes, then
++only authenticated connections will be allowed. If it is set to no then
++authentication is not needed for ldap server connections. Finally, if it is
++set to autodetect then the ldap server will be queried to establish a
++suitable authentication mechanism. If no suitable mechanism can be found,
++connections to the ldap server are made without authentication.
++.TP
++\fBauthtype="GSSAPI"|"LOGIN"|"PLAIN"|"ANONYMOUS"|"DIGEST-MD5"\fP
++This attribute can be used to specify a preferred authentication mechanism.
++ In normal operations, the automounter will attempt to authenticate to the
++ldap server using the list of supportedSASLmechanisms obtained from the
++directory server.  Explicitly setting the authtype will bypass this selection
++and only try the mechanism specified.
++.TP
++\fBuser="<username>"\fP
++This attribute holds the authentication identity used by authentication
++mechanisms that require it.  Legal values for this attribute include any
++printable characters that can be used by the selected authentication
++mechanism.
++.TP
++\fBsecret="<password>"\fP
++This attribute holds the secret used by authentication mechanisms that
++require it. Legal values for this attribute include any printable
++characters that can be used by the selected authentication mechanism.
++.TP
++\fBclientprinc="<GSSAPI client principal>"\fP
++When using GSSAPI authentication, this attribute is consulted to determine
++the principal name to use when authenticating to the directory server. By
++default, this will be set to "autofsclient/<fqdn>@<REALM>.
++.TP
++\fBcredentialcache="<external credential cache path>"\fP
++When using GSSAPI authentication, this attribute can be used to specify an
++externally configured credential cache that is used during authentication.
++By default, autofs will setup a memory based credential cache.
++.SH "SEE ALSO"
++.BR auto.master (5),
++.SH AUTHOR
++This manual page was written by Ian Kent <raven@themaw.net>.
+--- autofs-5.0.5.orig/man/automount.8
++++ autofs-5.0.5/man/automount.8
+@@ -152,6 +152,7 @@ constructed has been detached from the m
+ .BR autofs (8),
+ .BR auto.master (5),
+ .BR mount (8).
++.BR autofs_ldap_auth.conf (5)
+ .SH BUGS
+ Don't know, I've fixed everything I know about.
+ 
+--- autofs-5.0.5.orig/samples/autofs_ldap_auth.conf
++++ autofs-5.0.5/samples/autofs_ldap_auth.conf
+@@ -1,66 +1,7 @@
+ <?xml version="1.0" ?>
+ <!--
+ This files contains a single entry with multiple attributes tied to it.
+-The attributes are:
+-
+-usetls  -  Determines whether an encrypted connection to the ldap server
+-	   should be attempted.  Legal values for the entry are:
+-	   "yes"
+-	   "no"
+-
+-tlsrequired  -  This flag tells whether the ldap connection must be
+-	   encrypted.  If set to "yes", the automounter will fail to start
+-	   if an encrypted connection cannot be established.  Legal values
+-	   for this option include:
+-	   "yes"
+-	   "no"
+-
+-authrequired  -  This option tells whether an authenticated connection to
+-	    the ldap server is required in order to perform ldap queries.
+-	    If this flag is set to yes, then only authenticated connections
+-	    will be allowed. If it is set to no then authentication is not
+-	    needed for ldap server connections. Finally, if it is set to
+-	    autodetect then the ldap server will be queried to establish
+-	    a suitable authentication mechanism. If no suitable mechanism
+-	    can be found, connections to the ldap server are made without
+-	    authentication.
+-	    Legal values for this option include:
+-	    "yes"
+-	    "no"
+-	    "autodetect"
+-
+-authtype  -  This attribute can be used to specify a preferred
+-	    authentication mechanism.  In normal operations, the
+-	    automounter will attempt to authenticate to the ldap server
+-	    using the list of supportedSASLmechanisms obtained from the
+-	    directory server.  Explicitly setting the authtype will bypass
+-	    this selection and only try the mechanism specified.  Legal
+-	    values for this attribute include:
+-	    "GSSAPI"
+-	    "LOGIN"
+-	    "PLAIN"
+-	    "ANONYMOUS"
+-	    "DIGEST-MD5"
+-
+-user  -  This attribute holds the authentication identity used by
+-	    authentication mechanisms that require it.  Legal values for
+-	    this attribute include any printable characters that can be
+-	    used by the selected authentication mechanism.
+-
+-secret  -  This attribute holds the secret used by authentication
+-	    mechanisms that require it.  Legal values for this attribute
+-	    include any printable characters that can be used by the
+-	    selected authentication mechanism.
+-
+-clientprinc  -  When using GSSAPI authentication, this attribute is
+-	    consulted to determine the principal name to use when
+-	    authenticating to the directory server.  By default, this will
+-	    be set to "autofsclient/<fqdn>@<REALM>.
+-
+-credentialcache - When using GSSAPI authentication, this attribute
+-	    can be used to specify an externally configured credential
+-	    cache that is used during authentication. By default, autofs
+-	    will setup a memory based credential cache.
++See autofs_ldap_auth.conf(5) for more information.
+ -->
+ 
+ <autofs_ldap_sasl_conf
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-base64-password-encode.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-base64-password-encode.patch
@@ -0,0 +1,368 @@
+autofs-5.0.5 - add base64 password encode
+
+From: Ian Kent <raven@themaw.net>
+
+Add a trivial base64 password endoder to obscure password entries
+in autofs_ldap_auth.conf. Note that there is no way to encrypt the
+passwords without storing a password somewhere because there is no
+interactive input to allow a pass phrase or password to be input.
+
+The base64 encoded string can be generated using the coreutils
+base64 utility with:
+
+echo -n "<your text string>" | base64
+
+autofs will use the encoded string if it finds a valid entry
+"encoded_secret=<encoded string>" in autofs_ldap_auth.conf. If
+this value is present it will override a "secret=<string>" entry.
+---
+
+ CHANGELOG                      |    1 
+ include/base64.h               |   11 ++
+ man/autofs_ldap_auth.conf.5.in |    6 +
+ modules/Makefile               |    4 
+ modules/base64.c               |  225 +++++++++++++++++++++++++++++++++++++++++
+ modules/lookup_ldap.c          |   29 ++++-
+ 6 files changed, 270 insertions(+), 6 deletions(-)
+ create mode 100644 include/base64.h
+ create mode 100644 modules/base64.c
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -54,6 +54,7 @@
+ - fix map source check in file lookup.
+ - auto adjust ldap page size.
+ - fix paged ldap map read.
++- add base64 password encode.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- /dev/null
++++ autofs-5.0.5/include/base64.h
+@@ -0,0 +1,11 @@
++
++#ifndef BASE64_H
++#define BASE64_H
++
++#include <stdlib.h>
++#include <string.h>
++
++int base64_encode(char *, size_t, char *, size_t);
++size_t base64_decode(char *, char *, size_t);
++
++#endif
+--- autofs-5.0.5.orig/man/autofs_ldap_auth.conf.5.in
++++ autofs-5.0.5/man/autofs_ldap_auth.conf.5.in
+@@ -96,6 +96,12 @@ This attribute holds the secret used by 
+ require it. Legal values for this attribute include any printable
+ characters that can be used by the selected authentication mechanism.
+ .TP
++\fBencoded_secret="<base64 encoded password>"\fP
++This attribute holds the base64 encoded secret used by authentication
++mechanisms that require it. If this entry is present as well as the
++secret entry this value will take precedence.
++.TP
++.TP
+ \fBclientprinc="<GSSAPI client principal>"\fP
+ When using GSSAPI authentication, this attribute is consulted to determine
+ the principal name to use when authenticating to the directory server. By
+--- autofs-5.0.5.orig/modules/Makefile
++++ autofs-5.0.5/modules/Makefile
+@@ -95,9 +95,9 @@ cyrus-sasl.o: cyrus-sasl.c
+ cyrus-sasl-extern.o: cyrus-sasl-extern.c
+ 	$(CC) $(CFLAGS) $(LDAP_FLAGS) -c $<
+ 
+-lookup_ldap.so: lookup_ldap.c dclist.o $(SASL_OBJ)
++lookup_ldap.so: lookup_ldap.c dclist.o base64.o $(SASL_OBJ)
+ 	$(CC) $(SOLDFLAGS) $(CFLAGS) $(LDAP_FLAGS) -o lookup_ldap.so \
+-		lookup_ldap.c dclist.o $(SASL_OBJ) \
++		lookup_ldap.c dclist.o base64.o $(SASL_OBJ) \
+ 		$(AUTOFS_LIB) $(LIBLDAP) $(LIBRESOLV)
+ 	$(STRIP) lookup_ldap.so
+ 
+--- /dev/null
++++ autofs-5.0.5/modules/base64.c
+@@ -0,0 +1,225 @@
++#include <base64.h>
++
++/*
++ * characters used for Base64 encoding
++ */
++static const char *BASE64_CHARS =
++	 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
++
++/*
++ * encode three bytes using base64 (RFC 3548)
++ *
++ * @param triple three bytes that should be encoded
++ * @param result buffer of four characters where the result is stored
++ */
++static void _base64_encode_triple(char triple[3], char result[4])
++{
++	int tripleValue, i;
++
++	tripleValue = triple[0];
++	tripleValue *= 256;
++	tripleValue += triple[1];
++	tripleValue *= 256;
++	tripleValue += triple[2];
++
++	for (i=0; i<4; i++) {
++		result[3 - i] = BASE64_CHARS[tripleValue % 64];
++		tripleValue /= 64;
++	}
++}
++
++/*
++ * encode an array of bytes using Base64 (RFC 3548)
++ *
++ * @param source the source buffer
++ * @param sourcelen the length of the source buffer
++ * @param target the target buffer
++ * @param targetlen the length of the target buffer
++ * @return 1 on success, 0 otherwise
++ */
++int base64_encode(char *source, size_t sourcelen, char *target, size_t targetlen)
++{
++	/* check if the result will fit in the target buffer */
++	if ((sourcelen + 2)/ 3*4 > targetlen - 1)
++		return 0;
++
++	/* encode all full triples */
++	while (sourcelen >= 3) {
++		_base64_encode_triple(source, target);
++		sourcelen -= 3;
++		source += 3;
++		target += 4;
++	}
++
++	/* encode the last one or two characters */
++	if (sourcelen > 0) {
++		unsigned char temp[3];
++		memset(temp, 0, sizeof(temp));
++		memcpy(temp, source, sourcelen);
++		_base64_encode_triple(temp, target);
++		target[3] = '=';
++		if (sourcelen == 1)
++			target[2] = '=';
++		target += 4;
++	}
++
++	/* terminate the string */
++	target[0] = 0;
++
++	return 1;
++}
++
++/*
++ * determine the value of a base64 encoding character
++ *
++ * @param base64char the character of which the value is searched
++ * @return the value in case of success (0-63), -1 on failure
++ */
++static int _base64_char_value(char base64char)
++{
++	if (base64char >= 'A' && base64char <= 'Z')
++		return base64char-'A';
++	if (base64char >= 'a' && base64char <= 'z')
++		return base64char-'a'+26;
++	if (base64char >= '0' && base64char <= '9')
++		return base64char-'0'+2*26;
++	if (base64char == '+')
++		return 2*26+10;
++	if (base64char == '/')
++		return 2*26+11;
++	return -1;
++}
++
++/*
++ * decode a 4 char base64 encoded byte triple
++ *
++ * @param quadruple the 4 characters that should be decoded
++ * @param result the decoded data
++ * @return lenth of the result (1, 2 or 3), 0 on failure
++ */
++static int _base64_decode_triple(char quadruple[4], char *result)
++{
++	int i, triple_value, bytes_to_decode = 3, only_equals_yet = 1;
++	int char_value[4];
++
++	for (i=0; i<4; i++)
++		char_value[i] = _base64_char_value(quadruple[i]);
++
++	/* check if the characters are valid */
++	for (i=3; i>=0; i--) {
++		if (char_value[i]<0) {
++			if (only_equals_yet && quadruple[i]=='=') {
++				/* we will ignore this character anyway, make it
++				 * something that does not break our calculations */
++				char_value[i]=0;
++				bytes_to_decode--;
++				continue;
++			}
++			return 0;
++		}
++		/* after we got a real character, no other '=' are allowed anymore */
++		only_equals_yet = 0;
++	}
++
++	/* if we got "====" as input, bytes_to_decode is -1 */
++	if (bytes_to_decode < 0)
++		bytes_to_decode = 0;
++
++	/* make one big value out of the partial values */
++	triple_value = char_value[0];
++	triple_value *= 64;
++	triple_value += char_value[1];
++	triple_value *= 64;
++	triple_value += char_value[2];
++	triple_value *= 64;
++	triple_value += char_value[3];
++
++	/* break the big value into bytes */
++	for (i=bytes_to_decode; i<3; i++)
++		triple_value /= 256;
++	for (i=bytes_to_decode-1; i>=0; i--) {
++		result[i] = triple_value%256;
++		triple_value /= 256;
++	}
++
++	return bytes_to_decode;
++}
++
++/*
++ * decode base64 encoded data
++ *
++ * @param source the encoded data (zero terminated)
++ * @param target pointer to the target buffer
++ * @param targetlen length of the target buffer
++ * @return length of converted data on success, -1 otherwise
++ */
++size_t base64_decode(char *source, char *target, size_t targetlen)
++{
++	char *src, *tmpptr;
++	char quadruple[4], tmpresult[3];
++	int i, tmplen = 3;
++	size_t converted = 0;
++
++	/* concatinate '===' to the source to handle unpadded base64 data */
++	src = malloc(strlen(source)+5);
++	if (src == NULL)
++		return -1;
++	strcpy(src, source);
++	strcat(src, "====");
++	tmpptr = src;
++
++	memset(target, 0, targetlen);
++
++	/* convert as long as we get a full result */
++	while (tmplen == 3) {
++		/* get 4 characters to convert */
++		for (i = 0; i < 4; i++) {
++			/* skip invalid characters - we won't reach the end */
++			while (*tmpptr != '=' && _base64_char_value(*tmpptr) < 0)
++				tmpptr++;
++			quadruple[i] = *(tmpptr++);
++		}
++
++		/* convert the characters */
++		tmplen = _base64_decode_triple(quadruple, tmpresult);
++
++		/* check if the fit in the result buffer */
++		if (targetlen < tmplen) {
++			free(src);
++			return -1;
++		}
++
++		/* put the partial result in the result buffer */
++		memcpy(target, tmpresult, tmplen);
++		target += tmplen;
++		targetlen -= tmplen;
++		converted += tmplen;
++	}
++
++	free(src);
++	return converted;
++}
++
++#if 0
++#include <stdio.h>
++
++int main(int argc, char **argv)
++{
++	char *source = "testt(estt#wot%est'ing";
++	int source_len = strlen(source);
++	char dest[80];
++	int dest_len = 79;
++	char decoded[80];
++	int decode_len = 79;
++	int len;
++
++	printf("string %s\n", source);
++
++	if (base64_encode(source, source_len, dest, dest_len))
++		printf("encoded %s len %d\n", dest, strlen(dest));
++
++	len = base64_decode(dest, decoded, decode_len);
++	if (len != -1)
++		printf("decoded %s len %d\n", decoded, len);
++}
++#endif
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -33,6 +33,7 @@
+ #include "automount.h"
+ #include "nsswitch.h"
+ #include "lookup_ldap.h"
++#include "base64.h"
+ 
+ #define MAPFMT_DEFAULT "sun"
+ 
+@@ -1005,9 +1006,12 @@ int parse_ldap_config(unsigned logopt, s
+ 
+ 	if (auth_required == LDAP_AUTH_USESIMPLE ||
+ 	   (authtype && authtype_requires_creds(authtype))) {
++		char *s1 = NULL, *s2 = NULL;
+ 		ret = get_property(logopt, root, "user",  &user);
+-		ret |= get_property(logopt, root, "secret", &secret);
+-		if (ret != 0 || (!user || !secret)) {
++		ret |= get_property(logopt, root, "secret", &s1);
++		ret |= get_property(logopt, root, "encoded_secret", &s2);
++		if (ret != 0 || (!user || (!s1 && !s2))) {
++auth_fail:
+ 			error(logopt,
+ 			      MODPREFIX
+ 			      "%s authentication type requires a username "
+@@ -1016,12 +1020,29 @@ int parse_ldap_config(unsigned logopt, s
+ 			free(authtype);
+ 			if (user)
+ 				free(user);
+-			if (secret)
+-				free(secret);
++			if (s1)
++				free(s1);
++			if (s2)
++				free(s2);
+ 
+ 			ret = -1;
+ 			goto out;
+ 		}
++		if (!s2)
++			secret = s1;
++		else {
++			char dec_buf[120];
++			int dec_len = base64_decode(s2, dec_buf, 119);
++			if (dec_len <= 0)
++				goto auth_fail;
++			secret = strdup(dec_buf);
++			if (!secret)
++				goto auth_fail;
++			if (s1)
++				free(s1);
++			if (s2)
++				free(s2);
++		}
+ 	} else if (auth_required == LDAP_AUTH_REQUIRED &&
+ 		  (authtype && !strncmp(authtype, "EXTERNAL", 8))) {
+ 		ret = get_property(logopt, root, "external_cert",  &extern_cert);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-dump-maps-option.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-dump-maps-option.patch
@@ -0,0 +1,354 @@
+autofs-5.0.5 - add dump maps option
+
+From: Ondrej Valousek <webserv@s3group.cz>
+
+Modified by Ian Kent <raven@themaw.net>
+---
+
+ CHANGELOG          |    1 
+ daemon/automount.c |   52 +++++++++++++++------
+ include/log.h      |    1 
+ include/master.h   |    1 
+ lib/log.c          |   14 ++++-
+ lib/master.c       |  126 +++++++++++++++++++++++++++++++++++++++++++++++++++++
+ man/automount.8    |    3 +
+ 7 files changed, 180 insertions(+), 18 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -55,6 +55,7 @@
+ - auto adjust ldap page size.
+ - fix paged ldap map read.
+ - add base64 password encode.
++- add option to dump configured automount maps.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/automount.c
++++ autofs-5.0.5/daemon/automount.c
+@@ -1663,6 +1663,7 @@ static void usage(void)
+ 		"	-f --foreground do not fork into background\n"
+ 		"	-r --random-multimount-selection\n"
+ 		"			use ramdom replicated server selection\n"
++		"	-m --dumpmaps	dump automounter maps and exit\n"
+ 		"	-n --negative-timeout n\n"
+ 		"			set the timeout for failed key lookups.\n"
+ 		"	-O --global-options\n"
+@@ -1812,7 +1813,7 @@ int main(int argc, char *argv[])
+ 	int res, opt, status;
+ 	int logpri = -1;
+ 	unsigned ghost, logging, daemon_check;
+-	unsigned foreground, have_global_options;
++	unsigned dumpmaps, foreground, have_global_options;
+ 	time_t timeout;
+ 	time_t age = time(NULL);
+ 	struct rlimit rlim;
+@@ -1826,6 +1827,7 @@ int main(int argc, char *argv[])
+ 		{"foreground", 0, 0, 'f'},
+ 		{"random-multimount-selection", 0, 0, 'r'},
+ 		{"negative-timeout", 1, 0, 'n'},
++		{"dumpmaps", 0, 0, 'm'},
+ 		{"global-options", 1, 0, 'O'},
+ 		{"version", 0, 0, 'V'},
+ 		{"set-log-priority", 1, 0, 'l'},
+@@ -1856,10 +1858,11 @@ int main(int argc, char *argv[])
+ 	global_options = NULL;
+ 	have_global_options = 0;
+ 	foreground = 0;
++	dumpmaps = 0;
+ 	daemon_check = 1;
+ 
+ 	opterr = 0;
+-	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:l:n:CF", long_options, NULL)) != EOF) {
++	while ((opt = getopt_long(argc, argv, "+hp:t:vmdD:fVrO:l:n:CF", long_options, NULL)) != EOF) {
+ 		switch (opt) {
+ 		case 'h':
+ 			usage();
+@@ -1901,6 +1904,10 @@ int main(int argc, char *argv[])
+ 			global_negative_timeout = getnumopt(optarg, opt);
+ 			break;
+ 
++		case 'm':
++			dumpmaps = 1;
++			break;
++
+ 		case 'O':
+ 			if (!have_global_options) {
+ 				global_options = strdup(optarg);
+@@ -1987,7 +1994,8 @@ int main(int argc, char *argv[])
+ 	}
+ #endif
+ 
+-	if (!query_kproto_ver() || get_kver_major() < 5) {
++	/* Don't need the kernel module just to look at the configured maps */
++	if (!dumpmaps && (!query_kproto_ver() || get_kver_major() < 5)) {
+ 		fprintf(stderr,
+ 			"%s: test mount forbidden or "
+ 			"incorrect kernel protocol version, "
+@@ -2000,34 +2008,50 @@ int main(int argc, char *argv[])
+ 	rlim.rlim_max = MAX_OPEN_FILES;
+ 	res = setrlimit(RLIMIT_NOFILE, &rlim);
+ 	if (res)
+-		warn(logging,
+-		     "can't increase open file limit - continuing");
++		printf("%s: can't increase open file limit - continuing",
++			argv[0]);
+ 
+ #if ENABLE_CORES
+ 	rlim.rlim_cur = RLIM_INFINITY;
+ 	rlim.rlim_max = RLIM_INFINITY;
+ 	res = setrlimit(RLIMIT_CORE, &rlim);
+ 	if (res)
+-		warn(logging,
+-		     "can't increase core file limit - continuing");
++		printf("%s: can't increase core file limit - continuing",
++			argv[0]);
+ #endif
+ 
+-	become_daemon(foreground, daemon_check);
+-
+ 	if (argc == 0)
+ 		master_list = master_new(NULL, timeout, ghost);
+ 	else
+ 		master_list = master_new(argv[0], timeout, ghost);
+ 
+ 	if (!master_list) {
+-		logerr("%s: can't create master map %s",
+-			program, argv[0]);
+-		res = write(start_pipefd[1], pst_stat, sizeof(*pst_stat));
+-		close(start_pipefd[1]);
+-		release_flag_file();
++		printf("%s: can't create master map %s", program, argv[0]);
+ 		exit(1);
+ 	}
+ 
++	if (dumpmaps) {
++		struct mapent_cache *nc;
++
++		open_log();
++
++		master_init_scan();
++
++		nc = cache_init_null_cache(master_list);
++		if (!nc) {
++			printf("%s: failed to init null map cache for %s",
++				master_list->name, argv[0]);
++			exit(1);
++		}
++		master_list->nc = nc;
++
++		lookup_nss_read_master(master_list, 0);
++		master_show_mounts(master_list);
++		exit(0);
++	}
++
++	become_daemon(foreground, daemon_check);
++
+ 	if (pthread_attr_init(&th_attr)) {
+ 		logerr("%s: failed to init thread attribute struct!",
+ 		     program);
+--- autofs-5.0.5.orig/include/log.h
++++ autofs-5.0.5/include/log.h
+@@ -35,6 +35,7 @@ extern void set_log_verbose_ap(struct au
+ extern void set_log_debug_ap(struct autofs_point *ap);
+ extern void set_mnt_logging(unsigned global_logopt);
+ 
++extern void open_log(void);
+ extern void log_to_syslog(void);
+ extern void log_to_stderr(void);
+  
+--- autofs-5.0.5.orig/include/master.h
++++ autofs-5.0.5/include/master.h
+@@ -110,6 +110,7 @@ int master_submount_list_empty(struct au
+ int master_notify_submount(struct autofs_point *, const char *path, enum states);
+ void master_notify_state_change(struct master *, int);
+ int master_mount_mounts(struct master *, time_t, int);
++int master_show_mounts(struct master *);
+ extern inline unsigned int master_get_logopt(void);
+ int master_list_empty(struct master *);
+ int master_done(struct master *);
+--- autofs-5.0.5.orig/lib/log.c
++++ autofs-5.0.5/lib/log.c
+@@ -193,17 +193,23 @@ void logmsg(const char *msg, ...)
+ 	return;
+ }
+ 
+-void log_to_syslog(void)
++void open_log(void)
+ {
+-	char buf[MAX_ERR_BUF];
+-	int nullfd;
+-
+ 	if (!syslog_open) {
+ 		syslog_open = 1;
+ 		openlog("automount", LOG_PID, LOG_DAEMON);
+ 	}
+ 
+ 	logging_to_syslog = 1;
++	return;
++}
++
++void log_to_syslog(void)
++{
++	char buf[MAX_ERR_BUF];
++	int nullfd;
++
++	open_log();
+ 
+ 	/* Redirect all our file descriptors to /dev/null */
+ 	nullfd = open("/dev/null", O_RDWR);
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -30,6 +30,7 @@
+ /* The root of the map entry tree */
+ struct master *master_list = NULL;
+ 
++extern const char *global_options;
+ extern long global_negative_timeout;
+ 
+ /* Attribute to create a joinable thread */
+@@ -1208,6 +1209,131 @@ int master_mount_mounts(struct master *m
+ 	return 1;
+ }
+ 
++/* The nss source instances end up in reverse order. */
++static void list_source_instances(struct map_source *source, struct map_source *instance)
++{
++	if (!source || !instance) {
++		printf("none");
++		return;
++	}
++
++	if (instance->next)
++		list_source_instances(source, instance->next);
++
++	/*
++	 * For convienience we map nss instance type "files" to "file".
++	 * Check for that and report corrected instance type.
++	 */
++	if (strcmp(instance->type, "file"))
++		printf("%s ", instance->type);
++	else {
++		if (source->argv && *(source->argv[0]) != '/')
++			printf("files ");
++		else
++			printf("%s ", instance->type);
++	}
++
++	return;
++}
++
++int master_show_mounts(struct master *master)
++{
++	struct list_head *p, *head;
++
++	printf("\nautofs dump map information\n"
++		 "===========================\n\n");
++
++	printf("global options: ");
++	if (!global_options)
++		printf("none configured\n");
++	else {
++		printf("%s\n", global_options);
++		unsigned int append_options = defaults_get_append_options();
++		const char *append = append_options ? "will" : "will not";
++		printf("global options %s be appended to map entries\n", append);
++	}
++
++	if (list_empty(&master->mounts)) {
++		printf("no master map entries found\n\n");
++		return 1;
++	}
++
++	head = &master->mounts;
++	p = head->next;
++	while (p != head) {
++		struct map_source *source;
++		struct master_mapent *this;
++		struct autofs_point *ap;
++		time_t now = time(NULL);
++		int i;
++
++		this = list_entry(p, struct master_mapent, list);
++		p = p->next;
++
++		ap = this->ap;
++
++		printf("\nMount point: %s\n", ap->path);
++		printf("\nsource(s):\n");
++
++		/* Read the map content into the cache */
++		if (lookup_nss_read_map(ap, NULL, now))
++			lookup_prune_cache(ap, now);
++		else {
++			printf("  failed to read map\n\n");
++			continue;
++		}
++
++		if (!this->maps) {
++			printf("  no map sources found\n\n");
++			continue;
++		}
++
++		source = this->maps;
++		while (source) {
++			struct mapent *me;
++
++			if (source->type)
++				printf("\n  type: %s\n", source->type);
++			else {
++				printf("\n  instance type(s): ");
++				list_source_instances(source, source->instance);
++				printf("\n");
++			}
++
++			if (source->argc >= 1) {
++				i = 0;
++				if (source->argv[0] && *source->argv[0] != '-') {
++					printf("  map: %s\n", source->argv[0]);
++					i = 1;
++				}
++				if (source->argc > 1) {
++					printf("  arguments: ");
++					for (; i < source->argc; i++)
++						printf("%s ", source->argv[i]);
++					printf("\n");
++				}
++			}
++
++			printf("\n");
++
++			me = cache_lookup_first(source->mc);
++			if (!me)
++				printf("  no keys found in map\n");
++			else {
++				do {
++					printf("  %s | %s\n", me->key, me->mapent);
++				} while ((me = cache_lookup_next(source->mc, me)));
++			}
++
++			source = source->next;
++		}
++
++		printf("\n");
++	}
++
++	return 1;
++}
++
+ int master_list_empty(struct master *master)
+ {
+ 	int res = 0;
+--- autofs-5.0.5.orig/man/automount.8
++++ autofs-5.0.5/man/automount.8
+@@ -57,6 +57,9 @@ Run the daemon in the forground and log 
+ Enables the use of ramdom selection when choosing a host from a
+ list of replicated servers.
+ .TP
++.I "\-m, \-\-dumpmaps"
++Dump configured automounter maps, then exit.
++.TP
+ .I "\-O, \-\-global-options"
+ Allows the specification of global mount options used for all master
+ map entries. These options will either replace or be appened to options
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-external-bind-method.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-external-bind-method.patch
@@ -0,0 +1,404 @@
+autofs-5.0.5 - add external bind method
+
+From: Ian Kent <raven@themaw.net>
+
+Add sasl external bind handler.
+---
+
+ CHANGELOG                      |    1 
+ include/lookup_ldap.h          |    7 ++
+ man/autofs_ldap_auth.conf.5.in |   24 +++++++-
+ modules/Makefile               |    5 +
+ modules/cyrus-sasl-extern.c    |  117 +++++++++++++++++++++++++++++++++++++++++
+ modules/cyrus-sasl.c           |   20 +++++++
+ modules/lookup_ldap.c          |   78 ++++++++++++++++++++++-----
+ 7 files changed, 234 insertions(+), 18 deletions(-)
+ create mode 100644 modules/cyrus-sasl-extern.c
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -37,6 +37,7 @@
+ - fix remount locking.
+ - fix init script restart option.
+ - always read file maps mount lookup map read fix.
++- add external bind method.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/include/lookup_ldap.h
++++ autofs-5.0.5/include/lookup_ldap.h
+@@ -10,6 +10,7 @@
+ #include <krb5.h>
+ #endif
+ 
++#include "list.h"
+ #include "dclist.h"
+ 
+ struct ldap_schema {
+@@ -76,9 +77,13 @@ struct lookup_context {
+ 	int          kinit_done;
+ 	int          kinit_successful;
+ #ifdef WITH_SASL
++	/* Kerberos */
+ 	krb5_context krb5ctxt;
+ 	krb5_ccache  krb5_ccache;
+ 	sasl_conn_t  *sasl_conn;
++	/* SASL external */
++	char	     *extern_cert;
++	char	     *extern_key;
+ #endif
+ 	/* keytab file name needs to be added */
+ 
+@@ -110,6 +115,8 @@ int autofs_sasl_bind(unsigned logopt, LD
+ void autofs_sasl_unbind(struct lookup_context *ctxt);
+ void autofs_sasl_dispose(struct lookup_context *ctxt);
+ void autofs_sasl_done(void);
++/* cyrus-sasl-extern */
++int do_sasl_extern(LDAP *ldap, struct lookup_context *ctxt);
+ #endif
+ 
+ #endif
+--- autofs-5.0.5.orig/man/autofs_ldap_auth.conf.5.in
++++ autofs-5.0.5/man/autofs_ldap_auth.conf.5.in
+@@ -59,12 +59,30 @@ set to autodetect then the ldap server w
+ suitable authentication mechanism. If no suitable mechanism can be found,
+ connections to the ldap server are made without authentication.
+ .TP
+-\fBauthtype="GSSAPI"|"LOGIN"|"PLAIN"|"ANONYMOUS"|"DIGEST-MD5"\fP
++\fBauthtype="GSSAPI"|"LOGIN"|"PLAIN"|"ANONYMOUS"|"DIGEST-MD5|EXTERNAL"\fP
+ This attribute can be used to specify a preferred authentication mechanism.
+- In normal operations, the automounter will attempt to authenticate to the
++In normal operations, the automounter will attempt to authenticate to the
+ ldap server using the list of supportedSASLmechanisms obtained from the
+ directory server.  Explicitly setting the authtype will bypass this selection
+-and only try the mechanism specified.
++and only try the mechanism specified. The EXTERNAL mechanism may be used to
++authenticate using a client certificate and requires that authrequired
++set to "yes" if using SSL or usetls, tlsrequired and authrequired all set to
++"yes" if using TLS, in addition to authtype being set to EXTERNAL.
++.sp
++If using authtype EXTERNAL two additional configuration entries are
++required:
++.sp
++\fBexternal_cert="<client certificate path>"\fP
++.sp
++This specifies the path of the file containing the client certificate.
++.sp
++\fBexternal_key="<client certificate key path>"\fP
++.sp
++This specifies the path of the file containing the client certificate key.
++.sp
++These two configuration entries are mandatory when using the EXTERNAL method
++as the HOME environment variable cannot be assumed to be set or, if it is,
++to be set to the location we expect.
+ .TP
+ \fBuser="<username>"\fP
+ This attribute holds the authentication identity used by authentication
+--- autofs-5.0.5.orig/modules/Makefile
++++ autofs-5.0.5/modules/Makefile
+@@ -41,7 +41,7 @@ ifeq ($(LDAP), 1)
+   SRCS += lookup_ldap.c
+   MODS += lookup_ldap.so
+   ifeq ($(SASL), 1)
+-    SASL_OBJ = cyrus-sasl.o
++    SASL_OBJ = cyrus-sasl.o cyrus-sasl-extern.o
+     LDAP_FLAGS += $(SASL_FLAGS) $(XML_FLAGS) -DLDAP_THREAD_SAFE
+     LIBLDAP += $(LIBSASL) $(XML_LIBS)
+   endif
+@@ -92,6 +92,9 @@ lookup_hesiod.so: lookup_hesiod.c
+ cyrus-sasl.o: cyrus-sasl.c
+ 	$(CC) $(CFLAGS) $(LDAP_FLAGS) -c $<
+ 
++cyrus-sasl-extern.o: cyrus-sasl-extern.c
++	$(CC) $(CFLAGS) $(LDAP_FLAGS) -c $<
++
+ lookup_ldap.so: lookup_ldap.c dclist.o $(SASL_OBJ)
+ 	$(CC) $(SOLDFLAGS) $(CFLAGS) $(LDAP_FLAGS) -o lookup_ldap.so \
+ 		lookup_ldap.c dclist.o $(SASL_OBJ) \
+--- /dev/null
++++ autofs-5.0.5/modules/cyrus-sasl-extern.c
+@@ -0,0 +1,117 @@
++/*
++ * cyrus-sasl-extern.c - Module for Cyrus sasl external authentication.
++ *
++ *   Copyright 2010 Ian Kent <raven@themaw.net>
++ *   Copyright 2010 Red Hat, Inc.
++ *   All rights reserved.
++ *
++ *   This program is free software; you can redistribute it and/or modify
++ *   it under the terms of the GNU General Public License as published by
++ *   the Free Software Foundation, Inc., 675 Mass Ave, Cambridge MA 02139,
++ *   USA; either version 2 of the License, or (at your option) any later
++ *   version.
++ *
++ *   This program is distributed in the hope that it will be useful,
++ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *   GNU General Public License for more details.
++ */
++
++#include "config.h"
++
++#ifdef WITH_SASL
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <unistd.h>
++#include <sasl/sasl.h>
++#include <ldap.h>
++#include <ldap_cdefs.h>
++#include <lber_types.h>
++
++#include "lookup_ldap.h"
++
++struct values {
++	char *mech;
++	char *realm;
++	char *authcid;
++	char *authzid;
++	char *password;
++	char **resps;
++	int nresps;
++};
++
++static int interaction(unsigned flags, sasl_interact_t *interact, void *values)
++{
++	const char *val = interact->defresult;
++	struct values *vals = values;
++
++	switch(interact->id) {
++	case SASL_CB_GETREALM:
++		if (values)
++			val = vals->realm;
++		break;
++
++	case SASL_CB_AUTHNAME:
++		if (values)
++			val = vals->authcid;
++		break;
++
++	case SASL_CB_PASS:
++		if (values)
++			val = vals->password;
++		break;
++
++	case SASL_CB_USER:
++		if (values)
++			val = vals->authzid;
++		break;
++
++	case SASL_CB_NOECHOPROMPT:
++	case SASL_CB_ECHOPROMPT:
++		break;
++	}
++
++	if (val && !*val)
++		val = NULL;
++
++	if (val || interact->id == SASL_CB_USER) {
++		interact->result = (val && *val) ? val : "";
++		interact->len = strlen(interact->result);
++	}
++
++	return LDAP_SUCCESS;
++}
++
++int sasl_extern_interact(LDAP *ldap, unsigned flags, void *values, void *list)
++{
++	sasl_interact_t *interact = list;
++
++	if (!ldap)
++		return LDAP_PARAM_ERROR;
++
++	while (interact->id != SASL_CB_LIST_END) {
++		int rc = interaction(flags, interact, values);
++		if (rc)
++			return rc;
++		interact++;
++	}
++
++	return LDAP_SUCCESS;
++}
++
++int do_sasl_extern(LDAP *ldap, struct lookup_context *ctxt)
++{
++	int flags = LDAP_SASL_QUIET;
++	char *mech = ctxt->sasl_mech;
++	struct values values;
++	int rc;
++
++	memset(&values, 0, sizeof(struct values));
++	values.mech = mech;
++
++	rc = ldap_sasl_interactive_bind_s(ldap, NULL, mech, NULL, NULL,
++					  flags, sasl_extern_interact, &values);
++	return rc;
++}
++#endif
+--- autofs-5.0.5.orig/modules/cyrus-sasl.c
++++ autofs-5.0.5/modules/cyrus-sasl.c
+@@ -875,6 +875,26 @@ autofs_sasl_bind(unsigned logopt, LDAP *
+ 	if (ctxt->sasl_conn)
+ 		return 0;
+ 
++	if (ctxt->sasl_mech && !strncmp(ctxt->sasl_mech, "EXTERNAL", 8)) {
++		int result;
++
++		debug(logopt,
++		      "Attempting sasl bind with mechanism %s",
++		      ctxt->sasl_mech);
++
++		result = do_sasl_extern(ldap, ctxt);
++		if (result)
++			debug(logopt,
++			      "Failed to authenticate with mech %s",
++			      ctxt->sasl_mech);
++		else
++			debug(logopt,
++			      "sasl bind with mechanism %s succeeded",
++			      ctxt->sasl_mech);
++
++		return result;
++	}
++
+ 	sasl_auth_id = ctxt->user;
+ 	sasl_auth_secret = ctxt->secret;
+ 
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -41,6 +41,9 @@
+ 
+ int lookup_version = AUTOFS_LOOKUP_VERSION;	/* Required by protocol */
+ 
++#define ENV_LDAPTLS_CERT	"LDAPTLS_CERT"
++#define ENV_LDAPTLS_KEY		"LDAPTLS_KEY"
++
+ static struct ldap_schema common_schema[] = {
+ 	{"nisMap", "nisMapName", "nisObject", "cn", "nisMapEntry"},
+ 	{"automountMap", "ou", "automount", "cn", "automountInformation"},
+@@ -61,6 +64,16 @@ struct ldap_search_params {
+ 
+ static int decode_percent_hack(const char *, char **);
+ 
++static int set_env(unsigned logopt, const char *name, const char *val)
++{
++	int ret = setenv(name, val, 1);
++	if (ret == -1) {
++		error(logopt, "failed to set config value for %s", name);
++		return 0;
++	}
++	return 1;
++}
++
+ #ifndef HAVE_LDAP_CREATE_PAGE_CONTROL
+ int ldap_create_page_control(LDAP *ldap, ber_int_t pagesize,
+ 			     struct berval *cookie, char isCritical,
+@@ -586,13 +599,17 @@ static LDAP *do_connect(unsigned logopt,
+ {
+ 	LDAP *ldap;
+ 
+-	ldap = init_ldap_connection(logopt, uri, ctxt);
+-	if (!ldap)
+-		return NULL;
++	if (ctxt->extern_cert && ctxt->extern_key) {
++		set_env(logopt, ENV_LDAPTLS_CERT, ctxt->extern_cert);
++		set_env(logopt, ENV_LDAPTLS_KEY, ctxt->extern_key);
++	}
+ 
+-	if (!do_bind(logopt, ldap, uri, ctxt)) {
+-		unbind_ldap_connection(logopt, ldap, ctxt);
+-		return NULL;
++	ldap = init_ldap_connection(logopt, uri, ctxt);
++	if (ldap) {
++		if (!do_bind(logopt, ldap, uri, ctxt)) {
++			unbind_ldap_connection(logopt, ldap, ctxt);
++			ldap = NULL;
++		}
+ 	}
+ 
+ 	return ldap;
+@@ -828,6 +845,7 @@ int parse_ldap_config(unsigned logopt, s
+ 	xmlNodePtr   root = NULL;
+ 	char         *authrequired, *auth_conf, *authtype;
+ 	char         *user = NULL, *secret = NULL;
++	char         *extern_cert = NULL, *extern_key = NULL;
+ 	char         *client_princ = NULL, *client_cc = NULL;
+ 	char	     *usetls, *tlsrequired;
+ 
+@@ -1009,6 +1027,26 @@ int parse_ldap_config(unsigned logopt, s
+ 			ret = -1;
+ 			goto out;
+ 		}
++	} else if (auth_required == LDAP_AUTH_REQUIRED &&
++		  (authtype && !strncmp(authtype, "EXTERNAL", 8))) {
++		ret = get_property(logopt, root, "external_cert",  &extern_cert);
++		ret |= get_property(logopt, root, "external_key",  &extern_key);
++		/*
++		 * For EXTERNAL auth to function we need a client certificate
++		 * and and certificate key. The ca certificate used to verify
++		 * the server certificate must also be set correctly in the
++		 * global configuration as the connection must be encrypted
++		 * and the server and client certificates must have been
++		 * verified for the EXTERNAL method to be offerred by the
++		 * server. If the cert and key have not been set in the autofs
++		 * configuration they must be set in the ldap rc file.
++		 */
++		if (ret != 0 || !extern_cert || !extern_key) {
++			if (extern_cert)
++				free(extern_cert);
++			if (extern_key)
++				free(extern_key);
++		}
+ 	}
+ 
+ 	/*
+@@ -1029,6 +1067,8 @@ int parse_ldap_config(unsigned logopt, s
+ 	ctxt->secret = secret;
+ 	ctxt->client_princ = client_princ;
+ 	ctxt->client_cc = client_cc;
++	ctxt->extern_cert = extern_cert;
++	ctxt->extern_key = extern_key;
+ 
+ 	debug(logopt, MODPREFIX
+ 	      "ldap authentication configured with the following options:");
+@@ -1038,14 +1078,20 @@ int parse_ldap_config(unsigned logopt, s
+ 	      "auth_required: %u, "
+ 	      "sasl_mech: %s",
+ 	      use_tls, tls_required, auth_required, authtype);
+-	debug(logopt, MODPREFIX
+-	      "user: %s, "
+-	      "secret: %s, "
+-	      "client principal: %s "
+-	      "credential cache: %s",
+-	      user, secret ? "specified" : "unspecified",
+-	      client_princ, client_cc);
+-
++	if (authtype && !strncmp(authtype, "EXTERNAL", 8)) {
++		debug(logopt, MODPREFIX "external cert: %s",
++		      extern_cert ? extern_cert : "ldap default");
++		debug(logopt, MODPREFIX "external key: %s ",
++		      extern_key ? extern_key : "ldap default");
++	} else {
++		debug(logopt, MODPREFIX
++		      "user: %s, "
++		      "secret: %s, "
++		      "client principal: %s "
++		      "credential cache: %s",
++		      user, secret ? "specified" : "unspecified",
++		      client_princ, client_cc);
++	}
+ out:
+ 	xmlFreeDoc(doc);
+ 
+@@ -1312,6 +1358,10 @@ static void free_context(struct lookup_c
+ 		defaults_free_searchdns(ctxt->sdns);
+ 	if (ctxt->dclist)
+ 		free_dclist(ctxt->dclist);
++	if (ctxt->extern_cert)
++		free(ctxt->extern_cert);
++	if (ctxt->extern_key)
++		free(ctxt->extern_key);
+ 	free(ctxt);
+ 
+ 	return;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-locality-as-valid-ldap-master-map-attribute.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-locality-as-valid-ldap-master-map-attribute.patch
@@ -0,0 +1,53 @@
+autofs-5.0.5 - add locality as valid ldap master map attribute
+
+From: Ian Kent <raven@themaw.net>
+
+The master map dn string parsing is quite strict so we will need to add
+allowable attributes as required. One such attribute is "l", the locality.
+---
+
+ CHANGELOG        |    1 +
+ lib/master_tok.l |    7 ++++---
+ 2 files changed, 5 insertions(+), 3 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -33,6 +33,7 @@
+ - fix cache_init() on source re-read.
+ - fix negative cache included map lookup.
+ - remove state machine timed wait.
++- add locality as valid ldap master map attribute.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/master_tok.l
++++ autofs-5.0.5/lib/master_tok.l
+@@ -110,7 +110,8 @@ AT_OU		([oO][[uU])
+ AT_DC		([dD][[cC])
+ AT_O		([oO])
+ AT_C		([cC])
+-DNATTRSTR	({AT_CN}|{AT_NMN}|{AT_AMN}|{AT_OU}|{AT_DC}|{AT_O}|{AT_C})
++AT_L		([lL])
++DNATTRSTR	({AT_CN}|{AT_NMN}|{AT_AMN}|{AT_OU}|{AT_DC}|{AT_O}|{AT_C}|{AT_L})
+ DNNAMESTR1	([[:alnum:]_.\- ]+)
+ DNNAMESTR2	([[:alnum:]_.\-]+)
+ 
+@@ -209,7 +210,7 @@ OPTNTOUT	(-n{OPTWS}|-n{OPTWS}={OPTWS}|--
+ 	}
+ 
+ 	{MTYPE} |
+-	{MTYPE}/{DNSERVERSTR}{DNATTRSTR} |
++	{MTYPE}/{DNSERVERSTR}{DNATTRSTR}= |
+ 	{MTYPE}/{DNATTRSTR}= {
+ 		tlen = master_leng - 1;
+ 		if (bptr != buff && isblank(master_text[tlen])) {
+@@ -249,7 +250,7 @@ OPTNTOUT	(-n{OPTWS}|-n{OPTWS}={OPTWS}|--
+ 		yyless(0);
+ 	}
+ 
+-	{DNSERVERSTR}{DNATTRSTR} {
++	{DNSERVERSTR}{DNATTRSTR}= {
+ 		BEGIN(DNSTR);
+ 		yyless(0);
+ 	}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-lsb-force-reload-and-try-restart.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-lsb-force-reload-and-try-restart.patch
@@ -0,0 +1,48 @@
+autofs-5.0.5 - add lsb force-reload and try-restart
+
+From: Ian Kent <raven@themaw.net>
+
+LSB specifies two additional init script options, force-reload and
+try-restart. The force-reload option is supposed to do what restart
+does and does that. The try-restart option is essentially condrestart
+and is another option for that action. This change is made only to
+RedHat init script.
+---
+
+ redhat/autofs.init.in |   10 +++-------
+ 1 file changed, 3 insertions(+), 7 deletions(-)
+
+
+--- autofs-5.0.5.orig/redhat/autofs.init.in
++++ autofs-5.0.5/redhat/autofs.init.in
+@@ -173,7 +173,7 @@ case "$1" in
+ 	status)
+ 		status -p /var/run/autofs.pid -l autofs $prog
+ 		;;
+-	restart)
++	restart|force-reload)
+ 		restart
+ 		;;
+ 	forcerestart)
+@@ -183,19 +183,15 @@ case "$1" in
+ 	reload)
+ 		reload
+ 		;;
+-	condrestart)
++	condrestart|try-restart)
+ 		if [ -f /var/lock/subsys/autofs ]; then
+ 			restart
+ 		fi
+ 		;;
+ 	usage)
+-		echo $"Usage: $0 {start|forcestart|stop|status|restart|forcerestart|reload|condrestart}"
++		echo $"Usage: $0 {start|forcestart|stop|status|restart|force-reload|forcerestart|reload|condrestart|try-restart}"
+ 		exit 0;
+ 		;;
+-	try-restart|force-reload)
+-		echo "$1 service action not supported"
+-		exit 3
+-		;;
+ 	*)
+ 		echo "unknown, invalid or excess argument(s)"
+ 		exit 2
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-sasl-mutex-callbacks.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-sasl-mutex-callbacks.patch
@@ -0,0 +1,98 @@
+autofs-5.0.5 - add sasl mutex callbacks
+
+From: Ian Kent <raven@themaw.net>
+
+We missed the fact that Cyrus SASL requires the user to provide mutex
+handling functions when being used in a threaded environment.
+
+Original patch contributed by Kazuhiro Kikuchi (of Fujitsu), slightly
+modified by myself.
+---
+
+ CHANGELOG            |    1 
+ modules/cyrus-sasl.c |   57 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 58 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -26,6 +26,7 @@
+ - add autofs_ldap_auth.conf man page.
+ - fix random selection for host on different network.
+ - make redhat init script more lsb compliant.
++- add missing sasl mutex callbacks.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/cyrus-sasl.c
++++ autofs-5.0.5/modules/cyrus-sasl.c
+@@ -944,12 +944,69 @@ void autofs_sasl_dispose(struct lookup_c
+ 	}
+ }
+ 
++static void *sasl_mutex_new(void)
++{
++	pthread_mutex_t* mutex;
++
++	mutex = malloc(sizeof(pthread_mutex_t));
++	if (!mutex)
++		return 0;
++
++	pthread_mutex_init(mutex, NULL);
++
++	return (void *) mutex;
++}
++
++static int sasl_mutex_lock(void *mutex __attribute__((unused)))
++{
++	int rc;
++
++	if (!mutex)
++		return SASL_FAIL;
++
++	rc = pthread_mutex_lock((pthread_mutex_t *) mutex);
++
++	return (rc==0 ? SASL_OK : SASL_FAIL);
++}
++
++static int sasl_mutex_unlock(void *mutex __attribute__((unused)))
++{
++	int rc;
++
++	if (!mutex)
++		return SASL_FAIL;
++
++	rc = pthread_mutex_unlock((pthread_mutex_t *) mutex);
++
++	return (rc==0 ? SASL_OK : SASL_FAIL);
++}
++
++static void sasl_mutex_dispose(void *mutex __attribute__((unused)))
++{
++	int rc;
++
++	if (!mutex)
++		return;
++
++	rc = pthread_mutex_destroy((pthread_mutex_t *) mutex);
++	if (rc == 0)
++		free(mutex);
++
++	return;
++}
++
+ /*
+  * Initialize the sasl callbacks, which increments the global
+  * use counter.
+  */
+ int autofs_sasl_client_init(unsigned logopt)
+ {
++
++	sasl_set_mutex(sasl_mutex_new,
++		       sasl_mutex_lock,
++		       sasl_mutex_unlock,
++		       sasl_mutex_dispose);
++
+ 	/* Start up Cyrus SASL--only needs to be done at library load. */
+ 	if (sasl_client_init(callbacks) != SASL_OK) {
+ 		error(logopt, "sasl_client_init failed");
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-simple-bind-auth.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-add-simple-bind-auth.patch
@@ -0,0 +1,120 @@
+autofs-5.0.5 - add simple bind authentication
+
+From: James Y Knight <foom@fuhm.net>
+
+This patch adds the ability to do a simple bind against an LDAP server with
+the configured username and password.
+---
+
+ CHANGELOG                      |    1 +
+ include/lookup_ldap.h          |    1 +
+ man/autofs_ldap_auth.conf.5.in |   15 ++++++++-------
+ modules/lookup_ldap.c          |   21 +++++++++++++--------
+ 4 files changed, 23 insertions(+), 15 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -38,6 +38,7 @@
+ - fix init script restart option.
+ - always read file maps mount lookup map read fix.
+ - add external bind method.
++- add simple bind authentication.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/include/lookup_ldap.h
++++ autofs-5.0.5/include/lookup_ldap.h
+@@ -102,6 +102,7 @@ struct lookup_context {
+ #define LDAP_AUTH_NOTREQUIRED	0x0001
+ #define LDAP_AUTH_REQUIRED	0x0002
+ #define LDAP_AUTH_AUTODETECT	0x0004
++#define LDAP_AUTH_USESIMPLE	0x0008
+ 
+ /* lookup_ldap.c */
+ LDAP *init_ldap_connection(unsigned logopt, const char *uri, struct lookup_context *ctxt);
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -150,11 +150,13 @@ static void uris_mutex_unlock(struct loo
+ 	return;
+ }
+ 
+-int bind_ldap_anonymous(unsigned logopt, LDAP *ldap, const char *uri, struct lookup_context *ctxt)
++int bind_ldap_simple(unsigned logopt, LDAP *ldap, const char *uri, struct lookup_context *ctxt)
+ {
+ 	int rv;
+ 
+-	if (ctxt->version == 2)
++	if (ctxt->auth_required == LDAP_AUTH_USESIMPLE)
++		rv = ldap_simple_bind_s(ldap, ctxt->user, ctxt->secret);
++	else if (ctxt->version == 2)
+ 		rv = ldap_simple_bind_s(ldap, ctxt->base, NULL);
+ 	else
+ 		rv = ldap_simple_bind_s(ldap, NULL, NULL);
+@@ -530,12 +532,12 @@ static int do_bind(unsigned logopt, LDAP
+ 		rv = autofs_sasl_bind(logopt, ldap, ctxt);
+ 		debug(logopt, MODPREFIX "autofs_sasl_bind returned %d", rv);
+ 	} else {
+-		rv = bind_ldap_anonymous(logopt, ldap, uri, ctxt);
+-		debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
++		rv = bind_ldap_simple(logopt, ldap, uri, ctxt);
++		debug(logopt, MODPREFIX "ldap simple bind returned %d", rv);
+ 	}
+ #else
+-	rv = bind_ldap_anonymous(logopt, ldap, uri, ctxt);
+-	debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
++	rv = bind_ldap_simple(logopt, ldap, uri, ctxt);
++	debug(logopt, MODPREFIX "ldap simple bind returned %d", rv);
+ #endif
+ 
+ 	if (rv != 0)
+@@ -989,11 +991,13 @@ int parse_ldap_config(unsigned logopt, s
+ 			auth_required = LDAP_AUTH_NOTREQUIRED;
+ 		else if (!strcasecmp(authrequired, "autodetect"))
+ 			auth_required = LDAP_AUTH_AUTODETECT;
++		else if (!strcasecmp(authrequired, "simple"))
++			auth_required = LDAP_AUTH_USESIMPLE;
+ 		else {
+ 			error(logopt,
+ 			      MODPREFIX
+ 			      "The authrequired property must have value "
+-			      "\"yes\", \"no\" or \"autodetect\".");
++			      "\"yes\", \"no\", \"autodetect\", or \"simple\".");
+ 			ret = -1;
+ 			goto out;
+ 		}
+@@ -1009,7 +1013,8 @@ int parse_ldap_config(unsigned logopt, s
+ 		goto out;
+ 	}
+ 
+-	if (authtype && authtype_requires_creds(authtype)) {
++	if (auth_required == LDAP_AUTH_USESIMPLE ||
++	   (authtype && authtype_requires_creds(authtype))) {
+ 		ret = get_property(logopt, root, "user",  &user);
+ 		ret |= get_property(logopt, root, "secret", &secret);
+ 		if (ret != 0 || (!user || !secret)) {
+--- autofs-5.0.5.orig/man/autofs_ldap_auth.conf.5.in
++++ autofs-5.0.5/man/autofs_ldap_auth.conf.5.in
+@@ -50,14 +50,15 @@ This flag tells whether the ldap connect
+ the automounter will fail to start if an encrypted connection cannot be
+ established.
+ .TP
+-\fBauthrequired="yes"|"no"|"autodetect"\fP
++\fBauthrequired="yes"|"no"|"autodetect"|"simple"\fP
+ This option tells whether an authenticated connection to the ldap server is
+-required in order to perform ldap queries. If this flag is set to yes, then
+-only authenticated connections will be allowed. If it is set to no then
+-authentication is not needed for ldap server connections. Finally, if it is
+-set to autodetect then the ldap server will be queried to establish a
+-suitable authentication mechanism. If no suitable mechanism can be found,
+-connections to the ldap server are made without authentication.
++required in order to perform ldap queries. If the flag is set to yes, only
++sasl authenticated connections will be allowed. If it is set to no then
++authentication is not needed for ldap server connections. If it is set to
++autodetect then the ldap server will be queried to establish a suitable sasl
++authentication  mechanism. If no suitable mechanism can be found, connections
++to the ldap server are made without authentication. Finally, if it is set to
++simple, then simple authentication will be used instead of SASL.
+ .TP
+ \fBauthtype="GSSAPI"|"LOGIN"|"PLAIN"|"ANONYMOUS"|"DIGEST-MD5|EXTERNAL"\fP
+ This attribute can be used to specify a preferred authentication mechanism.
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-always-read-file-maps-mount-lookup-map-read-fix.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-always-read-file-maps-mount-lookup-map-read-fix.patch
@@ -0,0 +1,44 @@
+autofs-5.0.5 - always read file maps mount lookup map read fix
+
+From: Ian Kent <raven@themaw.net>
+
+If, during a mount lookup, a file map is found to have changed and the
+browse option is not being used, the file map won't be refreshed, even
+though file maps should always be read into the cache.
+
+A previous change for the "always read file maps" optimization moved
+the check for the browse option into the map module read function so
+checking for this in send_map_update_request() is not needed and
+causes nobrowse file maps to not be read if they have changed. This
+isn't quite optimal as there will be a partial read of the file map
+to satisfy the lookup and a full read of the map done by the queued
+update request. I don't think anything can be done about that though.
+---
+
+ CHANGELOG    |    1 +
+ lib/master.c |    3 ---
+ 2 files changed, 1 insertion(+), 3 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -36,6 +36,7 @@
+ - add locality as valid ldap master map attribute.
+ - fix remount locking.
+ - fix init script restart option.
++- always read file maps mount lookup map read fix.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -489,9 +489,6 @@ void send_map_update_request(struct auto
+ 	struct map_source *map;
+ 	int status, need_update = 0;
+ 
+-	if (!(ap->flags & MOUNT_FLAG_GHOST))
+-		return;
+-
+ 	status = pthread_mutex_lock(&instance_mutex);
+ 	if (status)
+ 		fatal(status);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-auto-adjust-ldap-page-size.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-auto-adjust-ldap-page-size.patch
@@ -0,0 +1,113 @@
+autofs-5.0.5 - auto adjust ldap page size
+
+From: Ian Kent <raven@themaw.net>
+
+When doing a paged LDAP request, if an LDAP server is configured with
+request size limits less than the size autofs requests the query fails
+with an LDAP_ADMINLIMIT_EXCEEDED. To fix this, when the error is returned
+halve the request size and try again until we get down to a ridiculously
+small size.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |   32 ++++++++++++++++++++++++--------
+ 2 files changed, 25 insertions(+), 8 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -52,6 +52,7 @@
+ - don't hold lock for simple mounts.
+ - fix prune cache valid check.
+ - fix map source check in file lookup.
++- auto adjust ldap page size.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -55,6 +55,7 @@ struct ldap_search_params {
+ 	LDAP *ldap;
+ 	char *query, **attrs;
+ 	struct berval *cookie;
++	ber_int_t pageSize;
+ 	int morePages;
+ 	ber_int_t totalCount;
+ 	LDAPMessage *result;
+@@ -1927,7 +1928,6 @@ static int do_paged_query(struct ldap_se
+ 	struct autofs_point *ap = sp->ap;
+ 	LDAPControl *pageControl=NULL, *controls[2] = { NULL, NULL };
+ 	LDAPControl **returnedControls = NULL;
+-	static ber_int_t pageSize = 1000;
+ 	static char pagingCriticality = 'T';
+ 	int rv, scope = LDAP_SCOPE_SUBTREE;
+ 
+@@ -1940,7 +1940,8 @@ static int do_paged_query(struct ldap_se
+  		 * Check for Size Limit exceeded and force run through loop
+ 		 * and requery using page control.
+  		 */
+-		if (rv == LDAP_SIZELIMIT_EXCEEDED)
++		if (rv == LDAP_SIZELIMIT_EXCEEDED ||
++		    rv == LDAP_ADMINLIMIT_EXCEEDED)
+ 			sp->morePages = TRUE;
+ 		else {
+ 			debug(ap->logopt,
+@@ -1955,7 +1956,7 @@ do_paged:
+ 	/* we need to use page controls so requery LDAP */
+ 	debug(ap->logopt, MODPREFIX "geting page of results");
+ 
+-	rv = ldap_create_page_control(sp->ldap, pageSize, sp->cookie,
++	rv = ldap_create_page_control(sp->ldap, sp->pageSize, sp->cookie,
+ 				      pagingCriticality, &pageControl);
+ 	if (rv != LDAP_SUCCESS) {
+ 		warn(ap->logopt, MODPREFIX "failed to create page control");
+@@ -1970,10 +1971,11 @@ do_paged:
+ 			       ctxt->qdn, scope, sp->query, sp->attrs,
+ 			       0, controls, NULL, NULL, 0, &sp->result);
+ 	if ((rv != LDAP_SUCCESS) && (rv != LDAP_PARTIAL_RESULTS)) {
+-		debug(ap->logopt,
+-		      MODPREFIX "query failed for %s: %s",
+-		      sp->query, ldap_err2string(rv));
+ 		ldap_control_free(pageControl);
++		if (rv != LDAP_ADMINLIMIT_EXCEEDED)
++			debug(ap->logopt,
++			      MODPREFIX "query failed for %s: %s",
++			      sp->query, ldap_err2string(rv));
+ 		return rv;
+ 	}
+ 
+@@ -2328,18 +2330,32 @@ static int read_one_map(struct autofs_po
+ 	      MODPREFIX "searching for \"%s\" under \"%s\"", sp.query, ctxt->qdn);
+ 
+ 	sp.cookie = NULL;
++	sp.pageSize = 1000;
+ 	sp.morePages = FALSE;
+ 	sp.totalCount = 0;
+ 	sp.result = NULL;
+ 
+ 	do {
+ 		rv = do_paged_query(&sp, ctxt);
+-		if (rv == LDAP_SIZELIMIT_EXCEEDED)
+-		{
++		if (rv == LDAP_SIZELIMIT_EXCEEDED) {
+ 			debug(ap->logopt, MODPREFIX "result size exceed");
+ 			if (sp.result)
+ 				ldap_msgfree(sp.result);
++			continue;
++		}
+ 
++		if (rv == LDAP_ADMINLIMIT_EXCEEDED) {
++			if (sp.result)
++				ldap_msgfree(sp.result);
++			sp.pageSize = sp.pageSize / 2;
++			if (sp.pageSize < 5) {
++				debug(ap->logopt, MODPREFIX
++				      "administrative result size too small");
++				unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
++				*result_ldap = rv;
++				free(sp.query);
++				return NSS_STATUS_UNAVAIL;
++			}
+ 			continue;
+ 		}
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-automount-8-man-page-correction.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-automount-8-man-page-correction.patch
@@ -0,0 +1,33 @@
+autofs-5.0.5 - automount(8) man page correction
+
+From: Ian Kent <raven@themaw.net>
+
+Correct reference to auto.master(8) in man page automount(8).
+---
+
+ CHANGELOG       |    1 +
+ man/automount.8 |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -48,6 +48,7 @@
+ - fix next task list update.
+ - fix stale map read.
+ - fix null cache clean.
++- automount(8) man page correction.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/man/automount.8
++++ autofs-5.0.5/man/automount.8
+@@ -16,7 +16,7 @@ The \fBautomount\fP program is used to m
+ autofs, the inlined Linux automounter.  \fBautomount\fP works by
+ reading the
+ .nh
+-.BR auto.master (8)
++.BR auto.master (5)
+ .hy
+ map and sets up mount points for each entry in the master map allowing
+ them to be automatically mounted when accessed. The file systems are
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-check-each-dc-server.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-check-each-dc-server.patch
@@ -0,0 +1,199 @@
+autofs-5.0.5 - check each dc server
+
+From: Ian Kent <raven@themaw.net>
+
+We return a space separated list of dc servers from get_dc_list() but the
+GSSAPI code needs an individual server in the uri to function correctly.
+
+Change the logic in find_server() and do_reconnect() to attempt a connection
+to each dc server individually.
+---
+
+ CHANGELOG             |    1 
+ modules/lookup_ldap.c |  103 +++++++++++++++++++++++++++++---------------------
+ 2 files changed, 62 insertions(+), 42 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -61,6 +61,7 @@
+ - fix sasl bind host name selection.
+ - fix sanity checks for brackets in server name.
+ - fix mapent becomes negative during lookup.
++- check each dc server individually.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -623,23 +623,43 @@ static LDAP *connect_to_server(unsigned 
+ 	return ldap;
+ }
+ 
++static LDAP *find_dc_server(unsigned logopt, const char *uri, struct lookup_context *ctxt)
++{
++	char *str, *tok, *ptr = NULL;
++	LDAP *ldap = NULL;
++
++	str = strdup(uri);
++	if (!str)
++		return NULL;
++
++	tok = strtok_r(str, " ", &ptr);
++	while (tok) {
++		const char *this = (const char *) tok;
++		debug(logopt, "trying server uri %s", this);
++		ldap = connect_to_server(logopt, this, ctxt);
++		if (ldap) {
++			info(logopt, "connected to uri %s", this);
++			free(str);
++			return ldap;
++		}
++		tok = strtok_r(NULL, " ", &ptr);
++	}
++
++	free(str);
++
++	return NULL;
++}
++
+ static LDAP *find_server(unsigned logopt, struct lookup_context *ctxt)
+ {
+ 	LDAP *ldap = NULL;
+ 	struct ldap_uri *this;
+ 	struct list_head *p, *first;
+-	struct dclist *dclist = NULL;
++	struct dclist *dclist;
+ 	char *uri = NULL;
+ 
+ 	uris_mutex_lock(ctxt);
+-	if (ctxt->dclist) {
+-		dclist = ctxt->dclist;
+-		if (ctxt->dclist->expire < time(NULL)) {
+-			free_dclist(ctxt->dclist);
+-			ctxt->dclist = NULL;
+-			dclist = NULL;
+-		}
+-	}
++	dclist = ctxt->dclist;
+ 	if (!ctxt->uri)
+ 		first = ctxt->uris;
+ 	else
+@@ -656,9 +676,16 @@ static LDAP *find_server(unsigned logopt
+ 			continue;
+ 		}
+ 		this = list_entry(p, struct ldap_uri, list);
+-		if (!strstr(this->uri, ":///"))
++		if (!strstr(this->uri, ":///")) {
+ 			uri = strdup(this->uri);
+-		else {
++			debug(logopt, "trying server uri %s", uri);
++			ldap = connect_to_server(logopt, uri, ctxt);
++			if (ldap) {
++				info(logopt, "connected to uri %s", uri);
++				free(uri);
++				break;
++			}
++		} else {
+ 			if (dclist)
+ 				uri = strdup(dclist->uri);
+ 			else {
+@@ -671,21 +698,11 @@ static LDAP *find_server(unsigned logopt
+ 				dclist = tmp;
+ 				uri = strdup(dclist->uri);
+ 			}
+-		}
+-		if (!uri) {
+-			if (dclist) {
+-				free_dclist(dclist);
+-				dclist = NULL;
++			ldap = find_dc_server(logopt, uri, ctxt);
++			if (ldap) {
++				free(uri);
++				break;
+ 			}
+-			p = p->next;
+-			continue;
+-		}
+-		debug(logopt, "trying server uri %s", uri);
+-		ldap = connect_to_server(logopt, uri, ctxt);
+-		if (ldap) {
+-			info(logopt, "connected to uri %s", uri);
+-			free(uri);
+-			break;
+ 		}
+ 		free(uri);
+ 		uri = NULL;
+@@ -716,7 +733,7 @@ static LDAP *find_server(unsigned logopt
+ 
+ static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
+ {
+-	LDAP *ldap;
++	LDAP *ldap = NULL;
+ 	char *uri;
+ 
+ 	if (ctxt->server || !ctxt->uris) {
+@@ -731,25 +748,29 @@ static LDAP *do_reconnect(unsigned logop
+ 		return ldap;
+ 	}
+ 
++	if (ctxt->dclist) {
++		ldap = find_dc_server(logopt, ctxt->dclist->uri, ctxt);
++		if (ldap)
++			return ldap;
++	}
++
+ 	uris_mutex_lock(ctxt);
+-	if (ctxt->dclist)
+-		uri = strdup(ctxt->dclist->uri);
+-	else if (ctxt->uri)
+-		uri = strdup(ctxt->uri->uri);
+-	else {
++	if (ctxt->dclist) {
++		if (!ldap || ctxt->dclist->expire < time(NULL)) {
++			free_dclist(ctxt->dclist);
++			ctxt->dclist = NULL;
++		}
++		/* Make sure we don't skip the domain spec */
++		ctxt->uri = NULL;
+ 		uris_mutex_unlock(ctxt);
+ 		goto find_server;
+ 	}
+ 	uris_mutex_unlock(ctxt);
+ 
+-	if (!uri) {
+-		char buf[MAX_ERR_BUF];
+-		char *estr = strerror_r(errno, buf, sizeof(buf));
+-		crit(logopt, MODPREFIX "strdup: %s", estr);
+-		return NULL;
+-	}
++	if (!ctxt->uri)
++		goto find_server;
+ 
+-	ldap = do_connect(logopt, uri, ctxt);
++	ldap = do_connect(logopt, ctxt->uri->uri, ctxt);
+ #ifdef WITH_SASL
+ 	/*
+ 	 * Dispose of the sasl authentication connection and try the
+@@ -760,19 +781,17 @@ static LDAP *do_reconnect(unsigned logop
+ 		ldap = connect_to_server(logopt, uri, ctxt);
+ 	}
+ #endif
+-	free(uri);
+-
+ 	if (ldap)
+ 		return ldap;
+ 
+ 	/* Failed to connect, try to find a new server */
+ 
++find_server:
+ #ifdef WITH_SASL
+ 	autofs_sasl_dispose(ctxt);
+ #endif
+ 
+-find_server:
+-	/* Current server failed connect, try the rest */
++	/* Current server failed, try the rest or dc connection */
+ 	ldap = find_server(logopt, ctxt);
+ 	if (!ldap)
+ 		error(logopt, MODPREFIX "failed to find available server");
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-check-for-path-mount-location-in-generic-module.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-check-for-path-mount-location-in-generic-module.patch
@@ -0,0 +1,113 @@
+autofs-5.0.5 - check for path mount location in generic module
+
+From: Ian Kent <raven@themaw.net>
+
+Currently we check for dependent mounts in the mount location path
+for bind mounts and loopback mounts. But we can have the case where
+a mount other than a loopback mount uses a local path and is not a
+bind mount. In this case we need to check the local path for dependent
+mounts. To do this we can check the mount location prior to spawning
+the mount and if it starts with a "/" then it is a local path and
+the check is needed.
+---
+
+ CHANGELOG      |    1 +
+ daemon/spawn.c |   41 +++++++++++++++++++++++++++--------------
+ 2 files changed, 28 insertions(+), 14 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index cc2efab..8429e20 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -13,6 +13,7 @@
+ - make documentation for set-log-priority clearer.
+ - fix timeout in connect_nb().
+ - fix pidof init script usage.
++- check for path mount location in generic module.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/spawn.c b/daemon/spawn.c
+index db356d4..7c254d9 100644
+--- a/daemon/spawn.c
++++ b/daemon/spawn.c
+@@ -154,22 +154,30 @@ static int do_spawn(unsigned logopt, unsigned int wait,
+ 
+ 	f = fork();
+ 	if (f == 0) {
++		char **pargv = (char **) argv;
++		int loc = 0;
++
+ 		reset_signals();
+ 		close(pipefd[0]);
+ 		dup2(pipefd[1], STDOUT_FILENO);
+ 		dup2(pipefd[1], STDERR_FILENO);
+ 		close(pipefd[1]);
+ 
+-		/* Bind mount - check target exists */
+-		if (use_access) {
+-			char **pargv = (char **) argv;
+-			int argc = 0;
+-			pid_t pgrp = getpgrp();
++		/* what to mount must always be second last */
++		while (*pargv++)
++			loc++;
++		loc -= 2;
+ 
+-			/* what to mount must always be second last */
+-			while (*pargv++)
+-				argc++;
+-			argc -= 2;
++		/*
++		 * If the mount location starts with a "/" then it is
++		 * a local path. In this case it is a bind mount, a
++		 * loopback mount or a file system that uses a local
++		 * path so we need to check for dependent mounts.
++		 *
++		 * I hope host names are never allowed "/" as first char
++		 */
++		if (use_access && *(argv[loc]) == '/') {
++			pid_t pgrp = getpgrp();
+ 
+ 			/*
+ 			 * Pretend to be requesting user and set non-autofs
+@@ -182,7 +190,7 @@ static int do_spawn(unsigned logopt, unsigned int wait,
+ 			setpgrp();
+ 
+ 			/* Trigger the recursive mount */
+-			if (access(argv[argc], F_OK) == -1)
++			if (access(argv[loc], F_OK) == -1)
+ 				_exit(errno);
+ 
+ 			seteuid(0);
+@@ -312,7 +320,7 @@ int spawn_mount(unsigned logopt, ...)
+ #ifdef ENABLE_MOUNT_LOCKING
+ 	options = SPAWN_OPT_LOCK;
+ #else
+-	options = SPAWN_OPT_NONE;
++	options = SPAWN_OPT_ACCESS;
+ #endif
+ 
+ 	va_start(arg, logopt);
+@@ -344,12 +352,17 @@ int spawn_mount(unsigned logopt, ...)
+ 		p = argv + 2;
+ 	}
+ 	while ((*p = va_arg(arg, char *))) {
+-		if (options == SPAWN_OPT_NONE && !strcmp(*p, "-o")) {
++		if (options == SPAWN_OPT_ACCESS && !strcmp(*p, "-t")) {
+ 			*(++p) = va_arg(arg, char *);
+ 			if (!*p)
+ 				break;
+-			if (strstr(*p, "loop"))
+-				options = SPAWN_OPT_ACCESS;
++			/*
++			 * A cifs mount location begins with a "/" but
++			 * is not a local path, so don't try to resolve
++			 * it. Mmmm ... does anyone use smbfs these days?
++			 */
++			if (strstr(*p, "cifs"))
++				options = SPAWN_OPT_NONE;
+ 		}
+ 		p++;
+ 	}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-check-null-cache-on-expire.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-check-null-cache-on-expire.patch
@@ -0,0 +1,48 @@
+autofs-5.0.5 - dont check null cache on expire
+
+From: Ian Kent <raven@themaw.net>
+
+When expiring an entry there is no need to check the null map
+entry cache. If we have a mount then it must have been done at
+some point when the entry was not a nulled so it still needs
+to be expired. Remove this check.
+---
+
+ CHANGELOG          |    1 +
+ daemon/automount.c |    9 ---------
+ 2 files changed, 1 insertion(+), 9 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -28,6 +28,7 @@
+ - make redhat init script more lsb compliant.
+ - add missing sasl mutex callbacks.
+ - fix parse_sun() module init.
++- dont check null cache on expire.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/automount.c
++++ autofs-5.0.5/daemon/automount.c
+@@ -526,20 +526,11 @@ static int umount_subtree_mounts(struct 
+    it also tries to umount path itself */
+ int umount_multi(struct autofs_point *ap, const char *path, int incl)
+ {
+-	struct mapent_cache *nc;
+ 	int is_autofs_fs;
+ 	int left;
+ 
+ 	debug(ap->logopt, "path %s incl %d", path, incl);
+ 
+-	nc = ap->entry->master->nc;
+-	cache_readlock(nc);
+-	if (cache_lookup_distinct(nc, path)) {
+-		cache_unlock(nc);
+-		return 0;
+-	}
+-	cache_unlock(nc);
+-
+ 	is_autofs_fs = 0;
+ 	if (master_find_submount(ap, path))
+ 		is_autofs_fs = 1;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-connect-at-ldap-lookup-module-init.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-connect-at-ldap-lookup-module-init.patch
@@ -0,0 +1,196 @@
+autofs-5.0.5 - dont connect at ldap lookup module init
+
+From: Ian Kent <raven@themaw.net>
+
+When using LDAP as a map source and no server is available at
+startup autofs will fiail to mount autofs mounts because it
+cannot read the mount maps.
+
+For the case were the master map is available (for example as
+a file map) indirect autofs mounts should still be able to
+continue but the LDAP lookup module unnecessarily tryes to
+connect a an LDAP server and returns a fail if it can't
+connect causing the autofs mount to not complete.
+
+If no server is available to obtain the mount information and
+an entry for a requested mount has not been seen before then
+mount requests will fail. But, if an entry has previously been
+seen autofs will use that while the server is unavailable.
+
+If an autofs indirect mount uses the browse option and no
+server is available at startup the map cannot be read so no
+mount point directories will be created (and the mount will
+behave as though the browse option was not present). A HUP
+signal can be issued to make autofs read the map and create
+the map mount point directores. Or the next access to a mount
+point that isn't already in the cache but in the map on the
+server will trigger a map re-read.
+---
+
+ CHANGELOG             |    1 
+ daemon/lookup.c       |    7 ++++-
+ modules/lookup_ldap.c |   61 +++++++++++++++++---------------------------------
+ 3 files changed, 28 insertions(+), 41 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -16,6 +16,7 @@
+ - check for path mount location in generic module.
+ - dont fail mount on access fail.
+ - fix rpc fail on large export list.
++- dont connect at ldap lookup module init.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -292,8 +292,13 @@ static int do_read_map(struct autofs_poi
+ 	 * For maps that don't support enumeration return success
+ 	 * and do whatever we must to have autofs function with an
+ 	 * empty map entry cache.
++	 *
++	 * For indirect maps that use the browse option, when the
++	 * server is unavailable continue as best we can with
++	 * whatever we have in the cache, if anything.
+ 	 */
+-	if (status == NSS_STATUS_UNKNOWN)
++	if (status == NSS_STATUS_UNKNOWN ||
++	   (ap->type == LKP_INDIRECT && status == NSS_STATUS_UNAVAIL))
+ 		return NSS_STATUS_SUCCESS;
+ 
+ 	return status;
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -724,8 +724,12 @@ static LDAP *do_reconnect(unsigned logop
+ 	uris_mutex_lock(ctxt);
+ 	if (ctxt->dclist)
+ 		uri = strdup(ctxt->dclist->uri);
+-	else
++	else if (ctxt->uri)
+ 		uri = strdup(ctxt->uri->uri);
++	else {
++		uris_mutex_unlock(ctxt);
++		goto find_server;
++	}
+ 	uris_mutex_unlock(ctxt);
+ 
+ 	if (!uri) {
+@@ -757,6 +761,7 @@ static LDAP *do_reconnect(unsigned logop
+ 	autofs_sasl_dispose(ctxt);
+ #endif
+ 
++find_server:
+ 	/* Current server failed connect, try the rest */
+ 	ldap = find_server(logopt, ctxt);
+ 	if (!ldap)
+@@ -1342,7 +1347,6 @@ int lookup_init(const char *mapfmt, int 
+ {
+ 	struct lookup_context *ctxt;
+ 	char buf[MAX_ERR_BUF];
+-	LDAP *ldap = NULL;
+ 	int ret;
+ 
+ 	*context = NULL;
+@@ -1416,23 +1420,6 @@ int lookup_init(const char *mapfmt, int 
+ 	}
+ #endif
+ 
+-	if (ctxt->server || !ctxt->uris) {
+-		ldap = connect_to_server(LOGOPT_NONE, ctxt->server, ctxt);
+-		if (!ldap) {
+-			free_context(ctxt);
+-			return 1;
+-		}
+-	} else {
+-		ldap = find_server(LOGOPT_NONE, ctxt);
+-		if (!ldap) {
+-			free_context(ctxt);
+-			error(LOGOPT_ANY, MODPREFIX
+-			     "failed to find available server");
+-			return 1;
+-		}
+-	}
+-	unbind_ldap_connection(LOGOPT_ANY, ldap, ctxt);
+-
+ 	/* Open the parser, if we can. */
+ 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
+ 	if (!ctxt->parse) {
+@@ -1463,6 +1450,11 @@ int lookup_read_master(struct master *ma
+ 	int scope = LDAP_SCOPE_SUBTREE;
+ 	LDAP *ldap;
+ 
++	/* Initialize the LDAP context. */
++	ldap = do_reconnect(logopt, ctxt);
++	if (!ldap)
++		return NSS_STATUS_UNAVAIL;
++
+ 	class = ctxt->schema->entry_class;
+ 	entry = ctxt->schema->entry_attr;
+ 	info = ctxt->schema->value_attr;
+@@ -1486,13 +1478,6 @@ int lookup_read_master(struct master *ma
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	/* Initialize the LDAP context. */
+-	ldap = do_reconnect(logopt, ctxt);
+-	if (!ldap) {
+-		free(query);
+-		return NSS_STATUS_UNAVAIL;
+-	}
+-
+ 	/* Look around. */
+ 	debug(logopt,
+ 	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
+@@ -2264,6 +2249,11 @@ static int read_one_map(struct autofs_po
+ 	sp.ap = ap;
+ 	sp.age = age;
+ 
++	/* Initialize the LDAP context. */
++	sp.ldap = do_reconnect(ap->logopt, ctxt);
++	if (!sp.ldap)
++		return NSS_STATUS_UNAVAIL;
++
+ 	class = ctxt->schema->entry_class;
+ 	entry = ctxt->schema->entry_attr;
+ 	info = ctxt->schema->value_attr;
+@@ -2289,13 +2279,6 @@ static int read_one_map(struct autofs_po
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	/* Initialize the LDAP context. */
+-	sp.ldap = do_reconnect(ap->logopt, ctxt);
+-	if (!sp.ldap) {
+-		free(sp.query);
+-		return NSS_STATUS_UNAVAIL;
+-	}
+-
+ 	/* Look around. */
+ 	debug(ap->logopt,
+ 	      MODPREFIX "searching for \"%s\" under \"%s\"", sp.query, ctxt->qdn);
+@@ -2401,6 +2384,11 @@ static int lookup_one(struct autofs_poin
+ 		return CHE_FAIL;
+ 	}
+ 
++	/* Initialize the LDAP context. */
++	ldap = do_reconnect(ap->logopt, ctxt);
++	if (!ldap)
++		return CHE_UNAVAIL;
++
+ 	class = ctxt->schema->entry_class;
+ 	entry = ctxt->schema->entry_attr;
+ 	info = ctxt->schema->value_attr;
+@@ -2479,13 +2467,6 @@ static int lookup_one(struct autofs_poin
+ 		return CHE_FAIL;
+ 	}
+ 
+-	/* Initialize the LDAP context. */
+-	ldap = do_reconnect(ap->logopt, ctxt);
+-	if (!ldap) {
+-		free(query);
+-		return CHE_UNAVAIL;
+-	}
+-
+ 	debug(ap->logopt,
+ 	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-fail-mount-on-access-fail.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-fail-mount-on-access-fail.patch
@@ -0,0 +1,55 @@
+autofs-5.0.5 - dont fail mount on access fail
+
+From: Ian Kent <raven@themaw.net>
+
+If we encounter a recursive autofs mount in the mount location
+path, and call access(2) to perform the mount, the mount may
+succeed but the access(2) call return a fail. In the case where
+there are multiple processes waiting on this mount they will all
+get the failure return which may be incorrect for other waiters.
+Ignoring the return code from the access(2) call and allowing the
+mount to go ahead anyway should give the VFS the chance to check
+the access for each individual process and so return an accurate
+retult.
+---
+
+ CHANGELOG      |    1 +
+ daemon/spawn.c |   12 +++++++++---
+ 2 files changed, 10 insertions(+), 3 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 8429e20..88bcc1b 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -14,6 +14,7 @@
+ - fix timeout in connect_nb().
+ - fix pidof init script usage.
+ - check for path mount location in generic module.
++- dont fail mount on access fail.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/spawn.c b/daemon/spawn.c
+index 7c254d9..285f4d7 100644
+--- a/daemon/spawn.c
++++ b/daemon/spawn.c
+@@ -189,9 +189,15 @@ static int do_spawn(unsigned logopt, unsigned int wait,
+ 			}
+ 			setpgrp();
+ 
+-			/* Trigger the recursive mount */
+-			if (access(argv[loc], F_OK) == -1)
+-				_exit(errno);
++			/*
++			 * Trigger the recursive mount.
++			 *
++			 * Ignore the access(2) return code as there may be
++			 * multiple waiters for this mount and we need to
++			 * let the  VFS handle access returns to each
++			 * individual waiter.
++			 */
++			access(argv[loc], F_OK);
+ 
+ 			seteuid(0);
+ 			setegid(0);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-hold-lock-for-simple-mounts.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-hold-lock-for-simple-mounts.patch
@@ -0,0 +1,117 @@
+autofs-5.0.5 - don't hold lock for simple mounts
+
+From: Ian Kent <raven@themaw.net>
+
+A map entry that depends on another map entry in the "same" map cannot
+be allowed in all cases. In particular, multi-mount entries must not
+change during mount operations so the internal map entry cache must
+remain locked during the mount. This is because, during the mount, we
+must consult the map and possibly update the internal cache entry to
+ensure we are using the most up to date mount information.
+
+This isn't the case for non multi-mount map entries but autofs didn't
+allow for this, which is the issue this patch addresses.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   41 +++++++++++++++++------------------------
+ 2 files changed, 18 insertions(+), 24 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -49,6 +49,7 @@
+ - fix stale map read.
+ - fix null cache clean.
+ - automount(8) man page correction.
++- don't hold lock for simple mounts.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -1179,19 +1179,6 @@ static int mount_subtree(struct autofs_p
+ 
+ 	rv = 0;
+ 
+-	if (!me || !me->multi) {
+-		int loclen = strlen(loc);
+-		int namelen = strlen(name);
+-		const char *root = ap->path;
+-
+-		if (!strcmp(ap->path, "/-"))
+-			root = name;
+-
+-		rv = sun_mount(ap, root, name, namelen, loc, loclen, options, ctxt);
+-
+-		goto done;
+-	}
+-
+ 	mm = me->multi;
+ 	mm_key = mm->key;
+ 	move = MOUNT_MOVE_NONE;
+@@ -1337,7 +1324,6 @@ static int mount_subtree(struct autofs_p
+ 	if (rv > 0)
+ 		return rv;
+ 
+-done:
+ 	/*
+ 	 * Convert fail on nonstrict, non-empty multi-mount
+ 	 * to success
+@@ -1665,17 +1651,25 @@ int parse_mount(struct autofs_point *ap,
+ 		 * it's already been parsed (above) and any option string
+ 		 * has already been stripped so just use the remainder.
+ 		 */
++		cache_readlock(mc);
+ 		if (*name == '/' &&
+ 		   (me = cache_lookup_distinct(mc, name)) && me->multi) {
+ 			loc = strdup(p);
+ 			if (!loc) {
+ 				free(options);
++				cache_unlock(mc);
+ 				warn(ap->logopt, MODPREFIX "out of memory");
+ 				return 1;
+ 			}
+-			loclen = strlen(p);
+-			goto mount_it;
++			cache_multi_writelock(me);
++			rv = mount_subtree(ap, me, name, loc, options, ctxt);
++			cache_multi_unlock(me);
++			cache_unlock(mc);
++			free(loc);
++			free(options);
++			return rv;
+ 		}
++		cache_unlock(mc);
+ 
+ 		l = chunklen(p, check_colon(p));
+ 		loc = dequote(p, l, ap->logopt);
+@@ -1759,21 +1753,20 @@ int parse_mount(struct autofs_point *ap,
+ 			      MODPREFIX "entry %s is empty!", name);
+ 			return 1;
+ 		}
+-mount_it:
++
+ 		debug(ap->logopt,
+ 		      MODPREFIX "core of entry: options=%s, loc=%.*s",
+ 		      options, loclen, loc);
+ 
+-		cache_readlock(mc);
+-		cache_multi_writelock(me);
+-
+-		rv = mount_subtree(ap, me, name, loc, options, ctxt);
++		if (!strcmp(ap->path, "/-"))
++			rv = sun_mount(ap, name, name, name_len,
++				       loc, loclen, options, ctxt);
++		else
++			rv = sun_mount(ap, ap->path, name, name_len,
++				       loc, loclen, options, ctxt);
+ 
+ 		free(loc);
+ 		free(options);
+-
+-		cache_multi_unlock(me);
+-		cache_unlock(mc);
+ 		pthread_setcancelstate(cur_state, NULL);
+ 	}
+ 	return rv;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-use-master_lex_destroy-to-clear-parse-buffer.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-dont-use-master_lex_destroy-to-clear-parse-buffer.patch
@@ -0,0 +1,39 @@
+autofs-5.0.5 - don't use master_lex_destroy() to clear parse buffer
+
+From: Ian Kent <raven@themaw.net>
+
+Using master_lex_destroy() does not seem not to resolve the original
+problem it set out to solve in all cases. Change to using memset() to
+clear the buffer instead.
+---
+
+ CHANGELOG        |    1 +
+ lib/master_tok.l |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index e37dadb..329b028 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -9,6 +9,7 @@
+ - fix backwards #ifndef INET6.
+ - fix stale initialization for file map instance.
+ - add "preen" fsck for ext4 mounts.
++- don't use master_lex_destroy() to clear parse buffer.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/lib/master_tok.l b/lib/master_tok.l
+index 373248b..be2ce10 100644
+--- a/lib/master_tok.l
++++ b/lib/master_tok.l
+@@ -414,7 +414,7 @@ static void master_echo(void)
+ 
+ void master_set_scan_buffer(const char *buffer)
+ {
+-	master_lex_destroy();
++	memset(buff, 0, sizeof(buff));
+ 	optr = buff;
+ 
+ 	line = buffer;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-add-simple-bind-auth.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-add-simple-bind-auth.patch
@@ -0,0 +1,61 @@
+autofs-5.0.5 - fix add simple bind auth
+
+From: Ian Kent <raven@themaw.net>
+
+Simple authentication should not require SASL.
+---
+
+ include/lookup_ldap.h |    5 +++++
+ modules/cyrus-sasl.c  |    1 -
+ modules/lookup_ldap.c |    1 -
+ 3 files changed, 5 insertions(+), 2 deletions(-)
+
+
+--- autofs-5.0.5.orig/include/lookup_ldap.h
++++ autofs-5.0.5/include/lookup_ldap.h
+@@ -1,6 +1,8 @@
+ #ifndef LOOKUP_LDAP_H
+ #define LOOKUP_LDAP_H
+ 
++#include <ldap.h>
++
+ #ifdef WITH_SASL
+ #include <openssl/ssl.h>
+ #include <openssl/evp.h>
+@@ -102,6 +104,8 @@ struct lookup_context {
+ #define LDAP_AUTH_NOTREQUIRED	0x0001
+ #define LDAP_AUTH_REQUIRED	0x0002
+ #define LDAP_AUTH_AUTODETECT	0x0004
++#endif
++
+ #define LDAP_AUTH_USESIMPLE	0x0008
+ 
+ /* lookup_ldap.c */
+@@ -109,6 +113,7 @@ LDAP *init_ldap_connection(unsigned logo
+ int unbind_ldap_connection(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt);
+ int authtype_requires_creds(const char *authtype);
+ 
++#ifdef WITH_SASL
+ /* cyrus-sasl.c */
+ int autofs_sasl_client_init(unsigned logopt);
+ int autofs_sasl_init(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt);
+--- autofs-5.0.5.orig/modules/cyrus-sasl.c
++++ autofs-5.0.5/modules/cyrus-sasl.c
+@@ -51,7 +51,6 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+-#include <ldap.h>
+ #include <sasl/sasl.h>
+ 
+ #include "automount.h"
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -28,7 +28,6 @@
+ #include <arpa/nameser.h>
+ #include <resolv.h>
+ #include <lber.h>
+-#include <ldap.h>
+ 
+ #define MODULE_LOOKUP
+ #include "automount.h"
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-ampersand-escape-in-auto-smb.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-ampersand-escape-in-auto-smb.patch
@@ -0,0 +1,32 @@
+autofs-5.0.5 - fix ampersand escape in auto.smb
+
+From: Ian Kent <raven@themaw.net>
+
+CIFS share names containing an ampersand need to be escaped.
+---
+
+ CHANGELOG        |    1 +
+ samples/auto.smb |    1 +
+ 2 files changed, 2 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -22,6 +22,7 @@
+ - fix disable timeout.
+ - fix strdup() return value check (Leonardo Chiquitto).
+ - fix get query dn failure.
++- fix ampersand escape in auto.smb.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/samples/auto.smb
++++ autofs-5.0.5/samples/auto.smb
+@@ -26,6 +26,7 @@ $SMBCLIENT -gNL $key 2>/dev/null| awk -v
+ 		  # Enclose mount dir and location in quotes
+ 		  # Double quote "$" in location as it is special
+ 		  gsub(/\$$/, "\\$", loc);
++		  gsub(/\&/,"\\\\&",loc)
+ 		  print " \\\n\t \"/" dir "\"", "\"://" key "/" loc "\""
+ 		}
+ 	END 	{ if (!first) print "\n"; else exit 1 }
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-backwards-ifndef-INET6.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-backwards-ifndef-INET6.patch
@@ -0,0 +1,48 @@
+autofs-5.0.5 - fix backwards #ifndef INET6
+
+From: Jeff Moyer <jmoyer@redhat.com>
+
+Fix reversed macro checks for INET6 in get_proximity().
+
+Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
+---
+
+ CHANGELOG            |    1 +
+ modules/replicated.c |    4 ++--
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index b9b1602..7997d1d 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -6,6 +6,7 @@
+ - special case cifs escapes.
+ - fix compile fail with when LDAP is excluded.
+ - more code analysis corrections (and fix a typo in an init script).
++- fix backwards #ifndef INET6.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/modules/replicated.c b/modules/replicated.c
+index a66de9f..4cd3eb4 100644
+--- a/modules/replicated.c
++++ b/modules/replicated.c
+@@ -231,7 +231,7 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
+ 			break;
+ 
+ 		case AF_INET6:
+-#ifndef INET6
++#ifdef INET6
+ 			if (host_addr->sa_family == AF_INET)
+ 				break;
+ 
+@@ -313,7 +313,7 @@ static unsigned int get_proximity(struct sockaddr *host_addr)
+ 			break;
+ 
+ 		case AF_INET6:
+-#ifndef INET6
++#ifdef INET6
+ 			if (host_addr->sa_family == AF_INET)
+ 				break;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-cache_init-on-source-re-read.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-cache_init-on-source-re-read.patch
@@ -0,0 +1,109 @@
+autofs-5.0.5 - fix cache_init() on source re-read
+
+From: Ian Kent <raven@themaw.net>
+
+The master map entry cache is released and re-allocated for each
+map source upon master map re-read. This is done without holding
+the master map entry write lock and, when there are many master
+map entries, could lead to a race because other activities can be
+underway concurrently. In this case then we must either use
+additional expensive exclusive locking or not do the cache
+re-recreate.
+
+So the question really becomes what do we have to gain by releasing
+and re-creating the cache since we spend a fairly significant amount
+of effort on pruning stale entries during ongoing operation already.
+
+This patch moves the allocation of the map entry cache (belonging to
+the map source) into the function used to add the map source to the
+master map entry and does not release and re-create the cache if the
+source already exists for the given master map entry.
+---
+
+ CHANGELOG              |    1 +
+ lib/master.c           |   17 +++++++++++++++--
+ lib/master_parse.y     |   10 ----------
+ modules/mount_autofs.c |    8 --------
+ 4 files changed, 16 insertions(+), 20 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -30,6 +30,7 @@
+ - fix parse_sun() module init.
+ - dont check null cache on expire.
+ - fix null cache race.
++- fix cache_init() on source re-read.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/master_parse.y
++++ autofs-5.0.5/lib/master_parse.y
+@@ -830,16 +830,6 @@ int master_parse_entry(const char *buffe
+ 		return 0;
+ 	}
+ 
+-	if (!source->mc) {
+-		source->mc = cache_init(entry->ap, source);
+-		if (!source->mc) {
+-			error(m_logopt, "failed to init source cache");
+-			if (new)
+-				master_free_mapent(new);
+-			local_free_vars();
+-			return 0;
+-		}
+-	}
+ 	source->master_line = lineno;
+ 
+ 	entry->age = age;
+--- autofs-5.0.5.orig/modules/mount_autofs.c
++++ autofs-5.0.5/modules/mount_autofs.c
+@@ -200,14 +200,6 @@ int mount_mount(struct autofs_point *ap,
+ 	}
+ 	free_map_type_info(info);
+ 
+-	source->mc = cache_init(entry->ap, source);
+-	if (!source->mc) {
+-		error(ap->logopt, MODPREFIX "failed to init source cache");
+-		master_free_map_source(source, 0);
+-		master_free_mapent(entry);
+-		return 1;
+-	}
+-
+ 	mounts_mutex_lock(ap);
+ 
+ 	if (handle_mounts_startup_cond_init(&suc)) {
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -190,9 +190,15 @@ master_add_map_source(struct master_mape
+ 
+ 	master_source_writelock(entry);
+ 
+-	if (!entry->maps)
++	if (!entry->maps) {
++		source->mc = cache_init(entry->ap, source);
++		if (!source->mc) {
++			master_free_map_source(source, 0);
++			master_source_unlock(entry);
++			return NULL;
++		}
+ 		entry->maps = source;
+-	else {
++	} else {
+ 		struct map_source *this, *last, *next;
+ 
+ 		/* Typically there only a few map sources */
+@@ -205,6 +211,13 @@ master_add_map_source(struct master_mape
+ 			return this;
+ 		}
+ 
++		source->mc = cache_init(entry->ap, source);
++		if (!source->mc) {
++			master_free_map_source(source, 0);
++			master_source_unlock(entry);
++			return NULL;
++		}
++
+ 		last = NULL;
+ 		next = entry->maps;
+ 		while (next) {
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-direct-map-not-updating-on-reread.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-direct-map-not-updating-on-reread.patch
@@ -0,0 +1,40 @@
+autofs-5.0.5 - fix direct map not updating on reread
+
+From: Ian Kent <raven@themaw.net>
+
+If the map type is explicitly specified for a map the map isn't
+properly updated when a re-read is requested. This is because
+the map stale flag is incorrectly cleared after after the lookup
+module reads the map instead of at the completion of the update
+procedure. The map stale flag should only be cleared if the map
+read fails for some reason, otherwise it is updated when the
+refresh is completed.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    3 ++-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -43,6 +43,7 @@
+ - fix isspace() wild card substition.
+ - include ip address in debug logging.
+ - mount using address for DNS round robin host names.
++- fix direct map not updating on reread.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -286,7 +286,8 @@ static int do_read_map(struct autofs_poi
+ 
+ 	status = lookup->lookup_read_map(ap, age, lookup->context);
+ 
+-	map->stale = 0;
++	if (status != NSS_STATUS_SUCCESS)
++		map->stale = 0;
+ 
+ 	/*
+ 	 * For maps that don't support enumeration return success
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-disable-timeout.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-disable-timeout.patch
@@ -0,0 +1,35 @@
+autofs-5.0.5 - fix disable timeout
+
+From: Ian Kent <raven@themaw.net>
+
+Using a timeout of zero should disable expires but instead causes
+the alarm handler to fire constant expires.
+---
+
+ CHANGELOG   |    1 +
+ lib/alarm.c |    3 +++
+ 2 files changed, 4 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -19,6 +19,7 @@
+ - dont connect at ldap lookup module init.
+ - fix reconnect get base dn.
+ - fix random selection option.
++- fix disable timeout.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/alarm.c
++++ autofs-5.0.5/lib/alarm.c
+@@ -67,6 +67,9 @@ int alarm_add(struct autofs_point *ap, t
+ 	unsigned int empty = 1;
+ 	int status;
+ 
++	if (!seconds)
++		return 1;
++
+ 	new = malloc(sizeof(struct alarm));
+ 	if (!new)
+ 		return 0;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-ext4-fsck-at-mount.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-ext4-fsck-at-mount.patch
@@ -0,0 +1,208 @@
+autofs-5.0.5 - fix ext4 fsck at mount
+
+From: Ian Kent <raven@themaw.net>
+
+Autofs performs a "preen" fsck at max mount count for ext2 and ext3, but not
+ext4.
+---
+
+ CHANGELOG            |    1 +
+ Makefile.conf.in     |    3 ++
+ configure            |   63 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ configure.in         |    1 +
+ include/config.h.in  |    6 +++++
+ modules/Makefile     |   10 ++++++--
+ modules/mount_ext2.c |   11 +++++----
+ 7 files changed, 88 insertions(+), 7 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 8b62370..e37dadb 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -8,6 +8,7 @@
+ - more code analysis corrections (and fix a typo in an init script).
+ - fix backwards #ifndef INET6.
+ - fix stale initialization for file map instance.
++- add "preen" fsck for ext4 mounts.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/Makefile.conf.in b/Makefile.conf.in
+index f0287c3..7670364 100644
+--- a/Makefile.conf.in
++++ b/Makefile.conf.in
+@@ -44,6 +44,9 @@ EXT2FS = @HAVE_E2FSCK@
+ # Support for calling e3fsck when mounting ext3 filesystems
+ EXT3FS = @HAVE_E3FSCK@
+ 
++# Support for calling e4fsck when mounting ext4 filesystems
++EXT4FS = @HAVE_E4FSCK@
++
+ LEX = @PATH_LEX@
+ YACC = @PATH_YACC@
+ RPCGEN = @PATH_RPCGEN@
+diff --git a/configure b/configure
+index 159f25f..f5b7d07 100755
+--- a/configure
++++ b/configure
+@@ -668,6 +668,8 @@ PATH_LEX
+ LEX
+ HAVE_MODPROBE
+ MODPROBE
++HAVE_E4FSCK
++E4FSCK
+ HAVE_E3FSCK
+ E3FSCK
+ HAVE_E2FSCK
+@@ -3407,6 +3409,67 @@ else
+   HAVE_E3FSCK=0
+ fi
+ 
++for ac_prog in fsck.ext4 e4fsck
++do
++  # Extract the first word of "$ac_prog", so it can be a program name with args.
++set dummy $ac_prog; ac_word=$2
++{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
++$as_echo_n "checking for $ac_word... " >&6; }
++if test "${ac_cv_path_E4FSCK+set}" = set; then
++  $as_echo_n "(cached) " >&6
++else
++  case $E4FSCK in
++  [\\/]* | ?:[\\/]*)
++  ac_cv_path_E4FSCK="$E4FSCK" # Let the user override the test with a path.
++  ;;
++  *)
++  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
++for as_dir in $searchpath
++do
++  IFS=$as_save_IFS
++  test -z "$as_dir" && as_dir=.
++  for ac_exec_ext in '' $ac_executable_extensions; do
++  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
++    ac_cv_path_E4FSCK="$as_dir/$ac_word$ac_exec_ext"
++    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
++    break 2
++  fi
++done
++done
++IFS=$as_save_IFS
++
++  ;;
++esac
++fi
++E4FSCK=$ac_cv_path_E4FSCK
++if test -n "$E4FSCK"; then
++  { $as_echo "$as_me:$LINENO: result: $E4FSCK" >&5
++$as_echo "$E4FSCK" >&6; }
++else
++  { $as_echo "$as_me:$LINENO: result: no" >&5
++$as_echo "no" >&6; }
++fi
++
++
++  test -n "$E4FSCK" && break
++done
++
++if test -n "$E4FSCK"; then
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_E4FSCK 1
++_ACEOF
++
++
++cat >>confdefs.h <<_ACEOF
++#define PATH_E4FSCK "$E4FSCK"
++_ACEOF
++
++  HAVE_E4FSCK=1
++else
++  HAVE_E4FSCK=0
++fi
++
+ for ac_prog in modprobe
+ do
+   # Extract the first word of "$ac_prog", so it can be a program name with args.
+diff --git a/configure.in b/configure.in
+index f649a58..78085bd 100644
+--- a/configure.in
++++ b/configure.in
+@@ -131,6 +131,7 @@ AF_PATH_INCLUDE(MOUNT, mount, /bin/mount, $searchpath)
+ AF_PATH_INCLUDE(UMOUNT, umount, /bin/umount, $searchpath)
+ AF_PATH_INCLUDE(E2FSCK, fsck.ext2 e2fsck, , $searchpath)
+ AF_PATH_INCLUDE(E3FSCK, fsck.ext3 e3fsck, , $searchpath)
++AF_PATH_INCLUDE(E4FSCK, fsck.ext4 e4fsck, , $searchpath)
+ AF_PATH_INCLUDE(MODPROBE, modprobe, , $searchpath)
+ 
+ AF_CHECK_PROG(LEX, flex lex, , $searchpath)
+diff --git a/include/config.h.in b/include/config.h.in
+index 39cfa4b..dece33f 100644
+--- a/include/config.h.in
++++ b/include/config.h.in
+@@ -18,6 +18,9 @@
+ /* define if you have E3FSCK */
+ #undef HAVE_E3FSCK
+ 
++/* define if you have E4FSCK */
++#undef HAVE_E4FSCK
++
+ /* Define to 1 if you have the <inttypes.h> header file. */
+ #undef HAVE_INTTYPES_H
+ 
+@@ -93,6 +96,9 @@
+ /* define if you have E3FSCK */
+ #undef PATH_E3FSCK
+ 
++/* define if you have E4FSCK */
++#undef PATH_E4FSCK
++
+ /* define if you have LEX */
+ #undef PATH_LEX
+ 
+diff --git a/modules/Makefile b/modules/Makefile
+index 13b3bd8..0bb9464 100644
+--- a/modules/Makefile
++++ b/modules/Makefile
+@@ -69,10 +69,16 @@ ifeq ($(EXT2FS), 1)
+  ifeq ($(EXT3FS), 1)
+ 	ln -fs mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext3.so
+  endif
+-else
+- ifeq ($(EXT3FS), 1)
++ ifeq ($(EXT4FS), 1)
++	ln -fs mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
++ endif
++else ifeq ($(EXT3FS), 1)
+ 	mv $(INSTALLROOT)$(autofslibdir)/mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext3.so
++ ifeq ($(EXT4FS), 1)
++	ln -fs mount_ext3.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
+  endif
++else ifeq ($(EXT4FS), 1)
++	mv $(INSTALLROOT)$(autofslibdir)/mount_ext2.so $(INSTALLROOT)$(autofslibdir)/mount_ext4.so
+ endif
+ 
+ #
+diff --git a/modules/mount_ext2.c b/modules/mount_ext2.c
+index 724a5fa..26d59d1 100644
+--- a/modules/mount_ext2.c
++++ b/modules/mount_ext2.c
+@@ -83,13 +83,14 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
+ 			ro = 1;
+ 	}
+ 
++	fsck_prog = PATH_E2FSCK;
+ #ifdef HAVE_E3FSCK
+-	if (!strcmp(fstype,"ext3") || !strcmp(fstype,"auto"))
++	if (!strcmp(fstype,"ext3"))
+ 		fsck_prog = PATH_E3FSCK;
+-	else
+-		fsck_prog = PATH_E2FSCK;
+-#else
+-	fsck_prog = PATH_E2FSCK;
++#endif
++#ifdef HAVE_E4FSCK
++	if (!strcmp(fstype,"ext4"))
++		fsck_prog = PATH_E4FSCK;
+ #endif
+ 	if (ro) {
+ 		debug(ap->logopt,
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-get-qdn-fail.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-get-qdn-fail.patch
@@ -0,0 +1,39 @@
+autofs-5.0.5 - fix get query dn failure
+
+From: Ian Kent <raven@themaw.net>
+
+Recent changes to the LDAP connection logic can fail to retrieve a valid
+query dn upon LDAP connection.
+
+If LDAP is being used to store autofs maps, the LDAP schema to be used
+for the maps is explicitly defined in the autofs configuration and no
+master map entries exist in LDAP autofs fails to try and retrieve a
+query dn, returning success instead of failure.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -21,6 +21,7 @@
+ - fix random selection option.
+ - fix disable timeout.
+ - fix strdup() return value check (Leonardo Chiquitto).
++- fix get query dn failure.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -556,7 +556,7 @@ static int do_bind(unsigned logopt, LDAP
+ 		}
+ 	}
+ 
+-	if (ctxt->schema && !need_base)
++	if (ctxt->schema && ctxt->qdn && !need_base)
+ 		return 1;
+ 
+ 	/*
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-included-map-read-fail-handling.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-included-map-read-fail-handling.patch
@@ -0,0 +1,44 @@
+autofs-5.0.5 - fix included map read fail handling
+
+From: Ian Kent <raven@themaw.net>
+
+If an included map read fails an error is returned and subsequent
+master map entries are not read. We should report the failure but
+we shouldn't stop reading the master map.
+---
+
+ CHANGELOG             |    4 ++++
+ modules/lookup_file.c |    7 -------
+ 2 files changed, 4 insertions(+), 7 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index e734cb3..674a48b 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -1,3 +1,7 @@
++??/??/20?? autofs-5.0.6
++-----------------------
++- fix included map read fail handling.
++
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+ - fix dumb libxml2 check
+diff --git a/modules/lookup_file.c b/modules/lookup_file.c
+index a4ca39d..e43ab2f 100644
+--- a/modules/lookup_file.c
++++ b/modules/lookup_file.c
+@@ -438,13 +438,6 @@ int lookup_read_master(struct master *master, time_t age, void *context)
+ 				     MODPREFIX
+ 				     "failed to read included master map %s",
+ 				     master->name);
+-				if (!master->recurse) {
+-					master->name = save_name;
+-					master->depth--;
+-					master->recurse = 0;
+-					fclose(f);
+-					return NSS_STATUS_UNAVAIL;
+-				}
+ 			}
+ 			master->depth--;
+ 			master->recurse = 0;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-isspace-wild-card-substition.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-isspace-wild-card-substition.patch
@@ -0,0 +1,78 @@
+autofs-5.0.5 - fix isspace() wild card substition
+
+From: Ian Kent <raven@themaw.net>
+
+If there are characters that match isspace() (such as \t, \n, etc.) in a
+passed map entry key and there is no space in the key these characters
+won't be properly preserved, leading to failed or incorrect mounts.
+
+This is caused by an incorrect attempt at optimization, using a check
+to see if a space is present in the passed key and only then processing
+each character of the key individually, escaping any isspace() characters.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   40 +++++++++++++++++-----------------------
+ 2 files changed, 18 insertions(+), 23 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -40,6 +40,7 @@
+ - add external bind method.
+ - add simple bind authentication.
+ - use weight only for server selection.
++- fix isspace() wild card substition.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -161,30 +161,24 @@ int expandsunent(const char *src, char *
+ 		case '&':
+ 			l = strlen(key);
+ 			/*
+-			 * In order to ensure that any spaces in the key
+-			 * re preserved, we need to escape them here.
++			 * In order to ensure that any isspace() characters
++			 * in the key are preserved, we need to escape them
++			 * here.
+ 			 */
+-			if (strchr(key, ' ')) {
+-				const char *keyp = key;
+-				while (*keyp) {
+-					if (isspace(*keyp)) {
+-						if (dst) {
+-							*dst++ = '\\';
+-							*dst++ = *keyp++;
+-						} else
+-							keyp++;
+-						l++;
+-					} else {
+-						if (dst)
+-							*dst++ = *keyp++;
+-						else
+-							keyp++;
+-					}
+-				}
+-			} else {
+-				if (dst) {
+-					strcpy(dst, key);
+-					dst += l;
++			const char *keyp = key;
++			while (*keyp) {
++				if (isspace(*keyp)) {
++					if (dst) {
++						*dst++ = '\\';
++						*dst++ = *keyp++;
++					} else
++						keyp++;
++					l++;
++				} else {
++					if (dst)
++						*dst++ = *keyp++;
++					else
++						keyp++;
+ 				}
+ 			}
+ 			len += l;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-libxml2-workaround-configure.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-libxml2-workaround-configure.patch
@@ -0,0 +1,79 @@
+autofs-5.0.5 - fix libxml2 workaround configure
+
+From: Ian Kent <raven@themaw.net>
+
+The configure logic related to work around the libxml2 library
+reload issues is not quite right. The xml code is needed if
+ldap is used so it is sufficient to require inclusion of the
+workaround code if autofs is being built with LDAP support.
+---
+
+ CHANGELOG          |    1 +
+ daemon/Makefile    |    2 --
+ daemon/automount.c |    8 +++++---
+ 3 files changed, 6 insertions(+), 5 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 671c979..23351c8 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -4,6 +4,7 @@
+ - refactor ldap sasl bind handling.
+ - add mount wait timeout parameter.
+ - special case cifs escapes.
++- fix compile fail with when LDAP is excluded.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/Makefile b/daemon/Makefile
+index 371ec72..9e9d635 100644
+--- a/daemon/Makefile
++++ b/daemon/Makefile
+@@ -23,10 +23,8 @@ LDFLAGS += -rdynamic
+ LIBS = -ldl
+ 
+ ifeq ($(LDAP), 1)
+-  ifeq ($(SASL), 1)
+     CFLAGS += $(XML_FLAGS)
+     LIBS += $(XML_LIBS)
+-  endif
+ endif
+ 
+ all: automount
+diff --git a/daemon/automount.c b/daemon/automount.c
+index 979ecd6..7c44d4b 100644
+--- a/daemon/automount.c
++++ b/daemon/automount.c
+@@ -38,10 +38,12 @@
+ #include <sys/utsname.h>
+ 
+ #include "automount.h"
+-#ifdef LIBXML2_WORKAROUND
++#if defined(LIBXML2_WORKAROUND) || defined(TIRPC_WORKAROUND)
+ #include <dlfcn.h>
++#ifdef WITH_LDAP
+ #include <libxml/parser.h>
+ #endif
++#endif
+ 
+ const char *program;		/* Initialized with argv[0] */
+ const char *version = VERSION_STRING;	/* Program version */
+@@ -2110,7 +2112,7 @@ int main(int argc, char *argv[])
+ 		exit(1);
+ 	}
+ 
+-#ifdef LIBXML2_WORKAROUND
++#if defined(WITH_LDAP) && defined(LIBXML2_WORKAROUND)
+ 	void *dh_xml2 = dlopen("libxml2.so", RTLD_NOW);
+ 	if (!dh_xml2)
+ 		dh_xml2 = dlopen("libxml2.so.2", RTLD_NOW);
+@@ -2158,7 +2160,7 @@ int main(int argc, char *argv[])
+ 	if (dh_tirpc)
+ 		dlclose(dh_tirpc);
+ #endif
+-#ifdef LIBXML2_WORKAROUND
++#if defined(WITH_LDAP) && defined( LIBXML2_WORKAROUND)
+ 	if (dh_xml2) {
+ 		xmlCleanupParser();
+ 		dlclose(dh_xml2);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-map-source-check-in-file-lookup.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-map-source-check-in-file-lookup.patch
@@ -0,0 +1,66 @@
+autofs-5.0.5 - fix map source check in file lookup
+
+From: Ian Kent <ikent@redhat.com>
+
+With the changes to reduce the scanning of file maps and fixes for
+other issues, such as too frequent map reads the key searching has
+become broken.
+
+For an automount that has a key present in a file map and the same
+key also present in another map source, if the file map entry is
+removed and a lookup is performed before a re-load is issued the
+map lookup fails. To fix this we need to check the map source, for
+indirect maps (since plus included direct maps are handled a little
+dirrefently), and continue looking if it doesn't match.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_file.c |   14 ++++++++++----
+ 2 files changed, 11 insertions(+), 4 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -51,6 +51,7 @@
+ - automount(8) man page correction.
+ - don't hold lock for simple mounts.
+ - fix prune cache valid check.
++- fix map source check in file lookup.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_file.c
++++ autofs-5.0.5/modules/lookup_file.c
+@@ -554,13 +554,14 @@ prepare_plus_include(struct autofs_point
+ 	source = master_find_source_instance(current,
+ 					     info->type, info->format,
+ 					     argc, argv);
+-	if (source)
++	if (source) {
+ 		/*
+ 		 * Make sure included map age is in sync with its owner
+ 		 * or we could incorrectly wipe out its entries.
+ 		 */
+ 		source->age = age;
+-	else {
++		source->stale = 1;
++	} else {
+ 		source = master_add_source_instance(current,
+ 						    info->type, info->format,
+ 						    age, argc, argv);
+@@ -1041,8 +1042,13 @@ int lookup_mount(struct autofs_point *ap
+ 	cache_readlock(mc);
+ do_cache_lookup:
+ 	me = cache_lookup(mc, key);
+-	/* Stale mapent => check for entry in alternate source or wildcard */
+-	if (me && !me->mapent) {
++	/*
++	 * Stale mapent => check for entry in alternate source or wildcard.
++	 * Note, plus included direct mount map entries are included as an
++	 * instance (same map entry cache), not in a distinct source.
++	 */
++	if (me && (!me->mapent || 
++	   (ap->type == LKP_INDIRECT && me->source != source))) {
+ 		while ((me = cache_lookup_key_next(me)))
+ 			if (me->source == source)
+ 				break;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-negative-cache-included-map-lookup.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-negative-cache-included-map-lookup.patch
@@ -0,0 +1,49 @@
+autofs-5.0.5 - fix negative cache included map lookup
+
+From: Ian Kent <raven@themaw.net>
+
+If we are looking up a mount from multiple included map sources we
+can't update the negative cache until we have looked at all sources.
+If we don't postpone the negative cache update we will get a false
+negative on a subsequent lookups.
+
+Also clean up "not found" message.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    6 +++++-
+ 2 files changed, 6 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -31,6 +31,7 @@
+ - dont check null cache on expire.
+ - fix null cache race.
+ - fix cache_init() on source re-read.
++- fix negative cache included map lookup.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -804,6 +804,10 @@ static void update_negative_cache(struct
+ 	struct map_source *map;
+ 	struct mapent *me;
+ 
++	/* Don't update negative cache for included maps */ 
++	if (source && source->depth)
++		return;
++
+ 	/* Have we recorded the lookup fail for negative caching? */
+ 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
+ 	if (me)
+@@ -814,7 +818,7 @@ static void update_negative_cache(struct
+ 		cache_unlock(me->mc);
+ 	else {
+ 		/* Notify only once after fail */
+-		error(ap->logopt, "key \"%s\" not found in map.", name);
++		logmsg("key \"%s\" not found in map source(s).", name);
+ 
+ 		/* Doesn't exist in any source, just add it somewhere */
+ 		if (source)
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-next-task-list-update.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-next-task-list-update.patch
@@ -0,0 +1,44 @@
+autofs-5.0.5 - fix next task list update
+
+From: Ian Kent <raven@themaw.net>
+
+When the state queue task manager transfered an automount point pending
+task to its task queue for execution the state queue as mistakenly being
+seen as empty when the completing task was the only task in the state
+queue.
+---
+
+ CHANGELOG      |    1 +
+ daemon/state.c |    8 +++++---
+ 2 files changed, 6 insertions(+), 3 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -45,6 +45,7 @@
+ - mount using address for DNS round robin host names.
+ - fix direct map not updating on reread.
+ - remove ERR_remove_state() openssl call.
++- fix next task list update.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/state.c
++++ autofs-5.0.5/daemon/state.c
+@@ -1150,11 +1150,13 @@ remove:
+ 				next = list_entry((&task->pending)->next,
+ 							struct state_queue, pending);
+ 
+-				list_del_init(&next->pending);
+-				list_add_tail(&next->list, p);
+-
+ 				list_del(&task->list);
+ 				free(task);
++
++				list_del_init(&next->pending);
++				list_add_tail(&next->list, head);
++				if (p == head)
++					p = head->next;
+ 			}
+ 
+ 			if (list_empty(head))
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-clean.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-clean.patch
@@ -0,0 +1,36 @@
+autofs-5.0.5 - fix null cache clean
+
+From: Ian Kent <raven@themaw.net>
+
+A function to clean the null map entry cache was added to
+avoid a race when re-reading the master map. That function
+mistakenly fails to clear the hash bucket array entries
+which leads to a segmentation fault on the next null cache
+lookup.
+---
+
+ CHANGELOG   |    1 +
+ lib/cache.c |    1 +
+ 2 files changed, 2 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -47,6 +47,7 @@
+ - remove ERR_remove_state() openssl call.
+ - fix next task list update.
+ - fix stale map read.
++- fix null cache clean.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/cache.c
++++ autofs-5.0.5/lib/cache.c
+@@ -249,6 +249,7 @@ void cache_clean_null_cache(struct mapen
+ 			free(me->key);
+ 			free(me);
+ 		}
++		mc->hash[i] = NULL;
+ 	}
+ 
+ 	return;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-deadlock.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-deadlock.patch
@@ -0,0 +1,33 @@
+autofs-5.0.5 - fix null cache deadlock
+
+From: Ian Kent <ikent@redhat.com>
+
+Reported by Leonardo Chiquitto along with an excelent problem analysis.
+
+When reloading maps that include a combination of direct and indirect
+maps it is possible for automount to deadlock due to incorrect lock
+ordering.
+---
+
+ daemon/state.c |    4 ++--
+ 1 files changed, 2 insertions(+), 2 deletions(-)
+
+
+diff --git a/daemon/state.c b/daemon/state.c
+index 3645440..51809a1 100644
+--- a/daemon/state.c
++++ b/daemon/state.c
+@@ -473,11 +473,11 @@ static void *do_readmap(void *arg)
+ 
+ 		mnts = tree_make_mnt_tree(_PROC_MOUNTS, "/");
+ 		pthread_cleanup_push(tree_mnts_cleanup, mnts);
+-		pthread_cleanup_push(master_source_lock_cleanup, ap->entry);
+-		master_source_readlock(ap->entry);
+ 		nc = ap->entry->master->nc;
+ 		cache_readlock(nc);
+ 		pthread_cleanup_push(cache_lock_cleanup, nc);
++		master_source_readlock(ap->entry);
++		pthread_cleanup_push(master_source_lock_cleanup, ap->entry);
+ 		map = ap->entry->maps;
+ 		while (map) {
+ 			/* Is map source up to date or no longer valid */
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-race.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-null-cache-race.patch
@@ -0,0 +1,189 @@
+autofs-5.0.5 - fix null cache race
+
+From: Ian Kent <raven@themaw.net>
+
+The null map entry cache scope is across the entire master map but
+it is used by individual master map entries during master map re-read
+and subsequest updates resulting form it. The current null cache locking
+doesn't properly account for this.
+
+To resolve this, when we re-read the master, map we need to block
+access to the null cache until the master map has been read and the
+null cache updated.
+---
+
+ CHANGELOG           |    1 +
+ daemon/automount.c  |    4 +++-
+ include/automount.h |    1 +
+ lib/cache.c         |   33 ++++++++++++++++++++++++++-------
+ lib/master.c        |   28 ++++++++++++++++++++--------
+ lib/master_parse.y  |    5 -----
+ 6 files changed, 51 insertions(+), 21 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -29,6 +29,7 @@
+ - add missing sasl mutex callbacks.
+ - fix parse_sun() module init.
+ - dont check null cache on expire.
++- fix null cache race.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/automount.c
++++ autofs-5.0.5/daemon/automount.c
+@@ -1273,14 +1273,16 @@ static int do_hup_signal(struct master *
+ 	if (status)
+ 		fatal(status);
+ 
++	master_mutex_lock();
+ 	if (master->reading) {
+ 		status = pthread_mutex_unlock(&mrc.mutex);
+ 		if (status)
+ 			fatal(status);
++		master_mutex_unlock();
+ 		return 1;
+ 	}
+-
+ 	master->reading = 1;
++	master_mutex_unlock();
+ 
+ 	status = pthread_create(&thid, &th_attr_detached, do_read_master, NULL);
+ 	if (status) {
+--- autofs-5.0.5.orig/include/automount.h
++++ autofs-5.0.5/include/automount.h
+@@ -194,6 +194,7 @@ void cache_multi_writelock(struct mapent
+ void cache_multi_unlock(struct mapent *me);
+ int cache_delete_offset_list(struct mapent_cache *mc, const char *key);
+ void cache_release(struct map_source *map);
++void cache_clean_null_cache(struct mapent_cache *mc);
+ void cache_release_null_cache(struct master *master);
+ struct mapent *cache_enumerate(struct mapent_cache *mc, struct mapent *me);
+ char *cache_get_offset(const char *prefix, char *offset, int start, struct list_head *head, struct list_head **pos);
+--- autofs-5.0.5.orig/lib/cache.c
++++ autofs-5.0.5/lib/cache.c
+@@ -228,15 +228,38 @@ struct mapent_cache *cache_init(struct a
+ 	return mc;
+ }
+ 
++void cache_clean_null_cache(struct mapent_cache *mc)
++{
++	struct mapent *me, *next;
++	int i;
++
++	for (i = 0; i < mc->size; i++) {
++		me = mc->hash[i];
++		if (me == NULL)
++			continue;
++		next = me->next;
++		free(me->key);
++		if (me->mapent)
++			free(me->mapent);
++		free(me);
++
++		while (next != NULL) {
++			me = next;
++			next = me->next;
++			free(me->key);
++			free(me);
++		}
++	}
++
++	return;
++}
++
+ struct mapent_cache *cache_init_null_cache(struct master *master)
+ {
+ 	struct mapent_cache *mc;
+ 	unsigned int i;
+ 	int status;
+ 
+-	if (master->nc)
+-		cache_release_null_cache(master);
+-
+ 	mc = malloc(sizeof(struct mapent_cache));
+ 	if (!mc)
+ 		return NULL;
+@@ -264,8 +287,6 @@ struct mapent_cache *cache_init_null_cac
+ 	if (status)
+ 		fatal(status);
+ 
+-	cache_writelock(mc);
+-
+ 	for (i = 0; i < mc->size; i++) {
+ 		mc->hash[i] = NULL;
+ 		INIT_LIST_HEAD(&mc->ino_index[i]);
+@@ -274,8 +295,6 @@ struct mapent_cache *cache_init_null_cac
+ 	mc->ap = NULL;
+ 	mc->map = NULL;
+ 
+-	cache_unlock(mc);
+-
+ 	return mc;
+ }
+ 
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -797,17 +797,29 @@ int master_read_master(struct master *ma
+ 	unsigned int logopt = master->logopt;
+ 	struct mapent_cache *nc;
+ 
+-	nc = cache_init_null_cache(master);
+-	if (!nc) {
+-		error(logopt,
+-		      "failed to init null map cache for %s", master->name);
+-		return 0;
++	/*
++	 * We need to clear and re-populate the null map entry cache
++	 * before alowing anyone else to use it.
++	 */
++	if (master->nc) {
++		cache_writelock(master->nc);
++		nc = master->nc;
++		cache_clean_null_cache(nc);
++	} else {
++		nc = cache_init_null_cache(master);
++		if (!nc) {
++			error(logopt,
++			      "failed to init null map cache for %s",
++			      master->name);
++			return 0;
++		}
++		cache_writelock(nc);
++		master->nc = nc;
+ 	}
+-	master->nc = nc;
+-
+ 	master_init_scan();
+-
+ 	lookup_nss_read_master(master, age);
++	cache_unlock(nc);
++
+ 	master_mount_mounts(master, age, readall);
+ 
+ 	master_mutex_lock();
+--- autofs-5.0.5.orig/lib/master_parse.y
++++ autofs-5.0.5/lib/master_parse.y
+@@ -741,21 +741,16 @@ int master_parse_entry(const char *buffe
+ 
+ 	/* Add null map entries to the null map cache */
+ 	if (type && !strcmp(type, "null")) {
+-		cache_writelock(nc);
+ 		cache_update(nc, NULL, path, NULL, lineno);
+-		cache_unlock(nc);
+ 		local_free_vars();
+ 		return 1;
+ 	}
+ 
+ 	/* Ignore all subsequent matching nulled entries */
+-	cache_readlock(nc);
+ 	if (cache_lookup_distinct(nc, path)) {
+-		cache_unlock(nc);
+ 		local_free_vars();
+ 		return 1;
+ 	}
+-	cache_unlock(nc);
+ 
+ 	if (debug || verbose) {
+ 		logopt = (debug ? LOGOPT_DEBUG : 0);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-paged-ldap-map-read.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-paged-ldap-map-read.patch
@@ -0,0 +1,57 @@
+autofs-5.0.5 - fix paged ldap map read
+
+From: Ian Kent <raven@themaw.net>
+
+With certain LDAP configurations autofs can loop indefinitely
+when trying to perform a paged result query to get the map.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |   13 ++++---------
+ 2 files changed, 5 insertions(+), 9 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -53,6 +53,7 @@
+ - fix prune cache valid check.
+ - fix map source check in file lookup.
+ - auto adjust ldap page size.
++- fix paged ldap map read.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -2330,27 +2330,22 @@ static int read_one_map(struct autofs_po
+ 	      MODPREFIX "searching for \"%s\" under \"%s\"", sp.query, ctxt->qdn);
+ 
+ 	sp.cookie = NULL;
+-	sp.pageSize = 1000;
++	sp.pageSize = 2000;
+ 	sp.morePages = FALSE;
+ 	sp.totalCount = 0;
+ 	sp.result = NULL;
+ 
+ 	do {
+ 		rv = do_paged_query(&sp, ctxt);
+-		if (rv == LDAP_SIZELIMIT_EXCEEDED) {
+-			debug(ap->logopt, MODPREFIX "result size exceed");
+-			if (sp.result)
+-				ldap_msgfree(sp.result);
+-			continue;
+-		}
+ 
+-		if (rv == LDAP_ADMINLIMIT_EXCEEDED) {
++		if (rv == LDAP_ADMINLIMIT_EXCEEDED ||
++		    rv == LDAP_SIZELIMIT_EXCEEDED) {
+ 			if (sp.result)
+ 				ldap_msgfree(sp.result);
+ 			sp.pageSize = sp.pageSize / 2;
+ 			if (sp.pageSize < 5) {
+ 				debug(ap->logopt, MODPREFIX
+-				      "administrative result size too small");
++				      "result size too small");
+ 				unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 				*result_ldap = rv;
+ 				free(sp.query);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-parse_sun-module-init.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-parse_sun-module-init.patch
@@ -0,0 +1,107 @@
+autofs-5.0.5 - fix parse_sun() module init
+
+From: Ian Kent <raven@themaw.net>
+
+In the parse sun module we pre-open the NFS mount module and cache
+the library handle because it is used so often. Since this is shared
+amonst all the master map entries multiple threads can race when
+accessing the instance counter, especially when there are many
+master map entries, leading to a double close on the mount library
+handle.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   37 ++++++++++++++++++++++++++++++-------
+ 2 files changed, 31 insertions(+), 7 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -27,6 +27,7 @@
+ - fix random selection for host on different network.
+ - make redhat init script more lsb compliant.
+ - add missing sasl mutex callbacks.
++- fix parse_sun() module init.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -45,6 +45,22 @@ int parse_version = AUTOFS_PARSE_VERSION
+ 
+ static struct mount_mod *mount_nfs = NULL;
+ static int init_ctr = 0;
++static int macro_init_done = 0;
++static pthread_mutex_t instance_mutex = PTHREAD_MUTEX_INITIALIZER;
++
++static void instance_mutex_lock(void)
++{
++	int status = pthread_mutex_lock(&instance_mutex);
++	if (status)
++		fatal(status);
++}
++
++static void instance_mutex_unlock(void)
++{
++	int status = pthread_mutex_unlock(&instance_mutex);
++	if (status)
++		fatal(status);
++}
+ 
+ extern const char *global_options;
+ 
+@@ -276,9 +292,12 @@ int parse_init(int argc, const char *con
+ 	unsigned int append_options;
+ 
+ 	/* Get processor information for predefined escapes */
+-
+-	if (!init_ctr)
++	macro_lock();
++	if (!macro_init_done) {
++		macro_init_done = 1;
+ 		macro_init();
++	}
++	macro_unlock();
+ 
+ 	/* Set up context and escape chain */
+ 
+@@ -434,19 +453,21 @@ options_done:
+ 
+ 	/* We only need this once.  NFS mounts are so common that we cache
+ 	   this module. */
+-	if (!mount_nfs) {
++	instance_mutex_lock();
++	if (mount_nfs)
++		init_ctr++;
++	else {
+ 		if ((mount_nfs = open_mount("nfs", MODPREFIX))) {
+ 			init_ctr++;
+-			return 0;
+ 		} else {
+ 			kill_context(ctxt);
+ 			*context = NULL;
++			instance_mutex_unlock();
+ 			return 1;
+ 		}
+-	} else {
+-		init_ctr++;
+-		return 0;
+ 	}
++	instance_mutex_unlock();
++	return 0;
+ }
+ 
+ static const char *parse_options(const char *str, char **ret, unsigned int logopt)
+@@ -1741,10 +1762,12 @@ int parse_done(void *context)
+ 	int rv = 0;
+ 	struct parse_context *ctxt = (struct parse_context *) context;
+ 
++	instance_mutex_lock();
+ 	if (--init_ctr == 0) {
+ 		rv = close_mount(mount_nfs);
+ 		mount_nfs = NULL;
+ 	}
++	instance_mutex_unlock();
+ 	if (ctxt)
+ 		kill_context(ctxt);
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-pidof-init-script-usage.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-pidof-init-script-usage.patch
@@ -0,0 +1,91 @@
+autofs-5.0.5 - fix pidof init script usage
+
+From: Ian Kent <raven@themaw.net>
+
+For some reason, following an update, pidof doesn't return the pid
+of a running automount daemon when the path is used rather than just
+the name, probably to do with the inode of the daemon program changing.
+
+So we change the init script to use just the program name rather than
+the path.
+---
+
+ CHANGELOG             |    1 +
+ redhat/autofs.init.in |    8 ++++----
+ samples/rc.autofs.in  |    8 ++++----
+ 3 files changed, 9 insertions(+), 8 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index dd093e2..cc2efab 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -12,6 +12,7 @@
+ - don't use master_lex_destroy() to clear parse buffer.
+ - make documentation for set-log-priority clearer.
+ - fix timeout in connect_nb().
++- fix pidof init script usage.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/redhat/autofs.init.in b/redhat/autofs.init.in
+index 806302b..363e824 100644
+--- a/redhat/autofs.init.in
++++ b/redhat/autofs.init.in
+@@ -101,14 +101,14 @@ function start() {
+ function stop() {
+ 	echo -n $"Stopping $prog: "
+ 	count=0
+-	while [ -n "`pidof $DAEMON`" -a $count -lt 15 ] ; do
++	while [ -n "`pidof $prog`" -a $count -lt 15 ] ; do
+ 		killproc $prog -TERM >& /dev/null
+ 		RETVAL=$?
+-		[ $RETVAL = 0 -a -z "`pidof $DAEMON`" ] || sleep 3
++		[ $RETVAL = 0 -a -z "`pidof $prog`" ] || sleep 3
+ 		count=`expr $count + 1`
+ 	done
+ 	[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/autofs
+-	if [ -n "`pidof $DAEMON`" ] ; then
++	if [ -n "`pidof $prog`" ] ; then
+ 		failure "$prog shutdown"
+ 	else
+ 		success "$prog shutdown"
+@@ -128,7 +128,7 @@ function reload() {
+ 		RETVAL=1
+ 		return $RETVAL
+ 	fi
+-	pid=`pidof $DAEMON`
++	pid=`pidof $prog`
+ 	if [ -z $pid ]; then
+ 		echo $"$prog not running"
+ 		RETVAL=1
+diff --git a/samples/rc.autofs.in b/samples/rc.autofs.in
+index b193a4e..ae2e907 100644
+--- a/samples/rc.autofs.in
++++ b/samples/rc.autofs.in
+@@ -88,13 +88,13 @@ function start() {
+ function stop() {
+ 	echo -n $"Stopping $prog: "
+ 	count=0
+-	while [ -n "`pidof $DAEMON`" -a $count -lt 15 ] ; do
++	while [ -n "`pidof $prog`" -a $count -lt 15 ] ; do
+ 		killall -TERM $prog >& /dev/null
+ 		RETVAL=$?
+-		[ $RETVAL = 0 -a -z "`pidof $DAEMON`" ] || sleep 3
++		[ $RETVAL = 0 -a -z "`pidof $prog`" ] || sleep 3
+ 		count=`expr $count + 1`
+ 	done
+-	if [ -z "`pidof $DAEMON`" ] ; then
++	if [ -z "`pidof $prog`" ] ; then
+ 		echo "done."
+ 	else
+ 		echo "failed."
+@@ -108,7 +108,7 @@ function restart() {
+ }
+ 
+ function reload() {
+-	pid=`pidof $DAEMON`
++	pid=`pidof $prog`
+ 	if [ -z $pid ]; then
+ 		echo $"$prog not running"
+ 		RETVAL=1
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-prune-cache-valid-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-prune-cache-valid-check.patch
@@ -0,0 +1,42 @@
+autofs-5.0.5 - fix prune cache valid check
+
+From: Ian Kent <raven@themaw.net>
+
+During a map reload, when pruning the cache we look for a valid map entry
+in another map. In lookup_prune_one_cache() There is a missing check for
+the entry being in the current map which causes the directory cleanup code
+from doing its job.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    8 ++++++++
+ 2 files changed, 9 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -50,6 +50,7 @@
+ - fix null cache clean.
+ - automount(8) man page correction.
+ - don't hold lock for simple mounts.
++- fix prune cache valid check.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -1051,6 +1051,14 @@ void lookup_prune_one_cache(struct autof
+ 		 * cache entry.
+ 		 */
+ 		valid = lookup_source_valid_mapent(ap, key, LKP_DISTINCT);
++		if (valid && valid->mc == mc) {
++			 /*
++			  * We've found a map entry that has been removed from
++			  * the current cache so it isn't really valid.
++			  */
++			cache_unlock(valid->mc);
++			valid = NULL;
++		}
+ 		if (!valid &&
+ 		    is_mounted(_PATH_MOUNTED, path, MNTS_REAL)) {
+ 			debug(ap->logopt,
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-random-selection-for-host-on-different-network.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-random-selection-for-host-on-different-network.patch
@@ -0,0 +1,137 @@
+autofs-5.0.5 - fix random selection for host on different network
+
+From: Ian Kent <raven@themaw.net>
+
+When we select from a list of hosts from which we can mount the list
+is ordered by response time within proximity.
+
+This is intended for normal selection but when using random selection
+if any hosts are on another network (and so considered further away)
+they will never be at the head of the list and so are unlikely to be
+used. This leads to a limited set of hosts being used for mounts which
+usually isn't what's required when the random selection option is used.
+---
+
+ CHANGELOG            |    1 +
+ include/replicated.h |    2 +-
+ modules/mount_nfs.c  |    2 +-
+ modules/replicated.c |   28 ++++++++++++++++++++--------
+ 4 files changed, 23 insertions(+), 10 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -24,6 +24,7 @@
+ - fix get query dn failure.
+ - fix ampersand escape in auto.smb.
+ - add autofs_ldap_auth.conf man page.
++- fix random selection for host on different network.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/include/replicated.h
++++ autofs-5.0.5/include/replicated.h
+@@ -64,7 +64,7 @@ struct host {
+ 
+ void seed_random(void);
+ void free_host_list(struct host **);
+-int parse_location(unsigned, struct host **, const char *);
++int parse_location(unsigned, struct host **, const char *, unsigned int);
+ int prune_host_list(unsigned, struct host **, unsigned int, const char *, unsigned int);
+ void dump_host_list(struct host *);
+ 
+--- autofs-5.0.5.orig/modules/mount_nfs.c
++++ autofs-5.0.5/modules/mount_nfs.c
+@@ -137,7 +137,7 @@ int mount_mount(struct autofs_point *ap,
+ 	else if (mount_default_proto == 4)
+ 		vers = vers | NFS4_VERS_MASK;
+ 
+-	if (!parse_location(ap->logopt, &hosts, what)) {
++	if (!parse_location(ap->logopt, &hosts, what, random_selection)) {
+ 		info(ap->logopt, MODPREFIX "no hosts available");
+ 		return 1;
+ 	}
+--- autofs-5.0.5.orig/modules/replicated.c
++++ autofs-5.0.5/modules/replicated.c
+@@ -1041,13 +1041,23 @@ int prune_host_list(unsigned logopt, str
+ 
+ static int add_new_host(struct host **list,
+ 			const char *host, unsigned int weight,
+-			struct addrinfo *host_addr)
++			struct addrinfo *host_addr,
++			unsigned int random_selection)
+ {
+ 	struct host *new;
+ 	unsigned int prx;
+ 	int addr_len;
+ 
+-	prx = get_proximity(host_addr->ai_addr);
++	/*
++	 * If we are using random selection we pretend all hosts are at
++	 * the same proximity so hosts further away don't get excluded.
++	 * We can't use PROXIMITY_LOCAL or we won't perform an RPC ping
++	 * to remove hosts that may be down.
++	 */
++	if (random_selection)
++		prx = PROXIMITY_SUBNET;
++	else
++		prx = get_proximity(host_addr->ai_addr);
+ 	/*
+ 	 * If we tried to add an IPv6 address and we don't have IPv6
+ 	 * support return success in the hope of getting an IPv4
+@@ -1071,7 +1081,8 @@ static int add_new_host(struct host **li
+ 	return 1;
+ }
+ 
+-static int add_host_addrs(struct host **list, const char *host, unsigned int weight)
++static int add_host_addrs(struct host **list, const char *host,
++			  unsigned int weight, unsigned int random_selection)
+ {
+ 	struct addrinfo hints, *ni, *this;
+ 	int ret;
+@@ -1087,7 +1098,7 @@ static int add_host_addrs(struct host **
+ 
+ 	this = ni;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this);
++		ret = add_new_host(list, host, weight, this, random_selection);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
+@@ -1110,7 +1121,7 @@ try_name:
+ 
+ 	this = ni;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this);
++		ret = add_new_host(list, host, weight, this, random_selection);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
+@@ -1197,7 +1208,8 @@ static char *seek_delim(const char *s)
+ 	return NULL;
+ }
+ 
+-int parse_location(unsigned logopt, struct host **hosts, const char *list)
++int parse_location(unsigned logopt, struct host **hosts,
++		   const char *list, unsigned int random_selection)
+ {
+ 	char *str, *p, *delim;
+ 	unsigned int empty = 1;
+@@ -1252,7 +1264,7 @@ int parse_location(unsigned logopt, stru
+ 				}
+ 
+ 				if (p != delim) {
+-					if (!add_host_addrs(hosts, p, weight)) {
++					if (!add_host_addrs(hosts, p, weight, random_selection)) {
+ 						if (empty) {
+ 							p = next;
+ 							continue;
+@@ -1274,7 +1286,7 @@ int parse_location(unsigned logopt, stru
+ 				*delim = '\0';
+ 				next = delim + 1;
+ 
+-				if (!add_host_addrs(hosts, p, weight)) {
++				if (!add_host_addrs(hosts, p, weight, random_selection)) {
+ 					p = next;
+ 					continue;
+ 				}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-random-selection-option.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-random-selection-option.patch
@@ -0,0 +1,35 @@
+autofs-5.0.5 - fix random selection option
+
+From: Ian Kent <raven@themaw.net>
+
+When parsing the master map we fail to check if the random selection
+option has been seen and set the random selection option unconditionally.
+---
+
+ CHANGELOG          |    1 +
+ lib/master_parse.y |    3 ++-
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -18,6 +18,7 @@
+ - fix rpc fail on large export list.
+ - dont connect at ldap lookup module init.
+ - fix reconnect get base dn.
++- fix random selection option.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/master_parse.y
++++ autofs-5.0.5/lib/master_parse.y
+@@ -811,7 +811,8 @@ int master_parse_entry(const char *buffe
+ 				ops->timeout(ap->logopt, ap->ioctlfd, &tout);
+ 		}
+ 	}
+-	entry->ap->flags |= MOUNT_FLAG_RANDOM_SELECT;
++	if (random_selection)
++		entry->ap->flags |= MOUNT_FLAG_RANDOM_SELECT;
+ 	if (negative_timeout)
+ 		entry->ap->negative_timeout = negative_timeout;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-reconnect-get-base-dn.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-reconnect-get-base-dn.patch
@@ -0,0 +1,37 @@
+autofs-5.0.5 - fix reconnect get base dn
+
+From: Ian Kent <raven@themaw.net>
+
+If connect to an LDAP server but fail to find a valid query dn a
+subsequent reconnect succeeds without setting the schema fields
+used for constructing queries. A segfault then occurs when we try
+to construct a query using the schema values that should have been
+set during the query dn validation.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -17,6 +17,7 @@
+ - dont fail mount on access fail.
+ - fix rpc fail on large export list.
+ - dont connect at ldap lookup module init.
++- fix reconnect get base dn.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -556,7 +556,7 @@ static int do_bind(unsigned logopt, LDAP
+ 		}
+ 	}
+ 
+-	if (!need_base)
++	if (ctxt->schema && !need_base)
+ 		return 1;
+ 
+ 	/*
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-remount-locking.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-remount-locking.patch
@@ -0,0 +1,365 @@
+autofs-5.0.5 - fix remount locking
+
+From: Ian Kent <raven@themaw.net>
+
+When autofs is restarted with active mounts it is possible, due
+to possible recursion when mounting multi-mount map entries, that
+a lookup module will take a write lock on the map entry cache
+when a read lock is alreay held.
+
+Since, during the re-mount, we are still essentially running
+single threaded we need only take care to ensure we don't take
+the write lock.
+---
+
+ CHANGELOG                |    1 +
+ modules/lookup_file.c    |   27 +++++++++++++++++----------
+ modules/lookup_hosts.c   |   24 +++++++++++++++---------
+ modules/lookup_ldap.c    |   24 ++++++++++++++++--------
+ modules/lookup_nisplus.c |   29 ++++++++++++++++++-----------
+ modules/lookup_program.c |   29 +++++++++++++++++++++--------
+ modules/lookup_yp.c      |   27 +++++++++++++++++----------
+ 7 files changed, 105 insertions(+), 56 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -34,6 +34,7 @@
+ - fix negative cache included map lookup.
+ - remove state machine timed wait.
+ - add locality as valid ldap master map attribute.
++- fix remount locking.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_file.c
++++ autofs-5.0.5/modules/lookup_file.c
+@@ -873,7 +873,6 @@ static int check_map_indirect(struct aut
+ 	if (ret == CHE_FAIL)
+ 		return NSS_STATUS_NOTFOUND;
+ 
+-	pthread_cleanup_push(cache_lock_cleanup, mc);
+ 	cache_writelock(mc);
+ 	exists = cache_lookup_distinct(mc, key);
+ 	/* Not found in the map but found in the cache */
+@@ -884,7 +883,7 @@ static int check_map_indirect(struct aut
+ 			exists->status = 0;
+ 		}
+ 	}
+-	pthread_cleanup_pop(1);
++	cache_unlock(mc);
+ 
+ 	if (ret == CHE_MISSING) {
+ 		struct mapent *we;
+@@ -898,7 +897,6 @@ static int check_map_indirect(struct aut
+ 		 * Check for map change and update as needed for
+ 		 * following cache lookup.
+ 		 */
+-		pthread_cleanup_push(cache_lock_cleanup, mc);
+ 		cache_writelock(mc);
+ 		we = cache_lookup_distinct(mc, "*");
+ 		if (we) {
+@@ -906,7 +904,7 @@ static int check_map_indirect(struct aut
+ 			if (we->source == source && (wild & CHE_MISSING))
+ 				cache_delete(mc, "*");
+ 		}
+-		pthread_cleanup_pop(1);
++		cache_unlock(mc);
+ 
+ 		if (wild & (CHE_OK | CHE_UPDATED))
+ 			return NSS_STATUS_SUCCESS;
+@@ -959,13 +957,22 @@ int lookup_mount(struct autofs_point *ap
+ 		if (me->status >= time(NULL)) {
+ 			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
++
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, key);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, key);
++				cache_unlock(smc);
++			}
+ 		}
+-
+-		/* Negative timeout expired for non-existent entry. */
+-		if (!me->mapent)
+-			cache_delete(me->mc, key);
+-
+-		cache_unlock(me->mc);
+ 	}
+ 
+ 	/*
+--- autofs-5.0.5.orig/modules/lookup_hosts.c
++++ autofs-5.0.5/modules/lookup_hosts.c
+@@ -146,19 +146,25 @@ int lookup_mount(struct autofs_point *ap
+ 	/* Check if we recorded a mount fail for this key anywhere */
+ 	me = lookup_source_mapent(ap, name, LKP_DISTINCT);
+ 	if (me) {
+-		struct mapent_cache *fmc = me->mc;
+-
+ 		if (me->status >= time(NULL)) {
+-			cache_unlock(fmc);
++			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
+-		}
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
+ 
+-		if (!me->mapent) {
+-			cache_delete(fmc, name);
+-			me = NULL;
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, name);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, name);
++				cache_unlock(smc);
++			}
+ 		}
+-
+-		cache_unlock(fmc);
+ 	}
+ 
+ 	cache_readlock(mc);
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -2676,7 +2676,6 @@ next:
+ 	unbind_ldap_connection(ap->logopt, ldap, ctxt);
+ 
+ 	/* Failed to find wild entry, update cache if needed */
+-	pthread_cleanup_push(cache_lock_cleanup, mc);
+ 	cache_writelock(mc);
+ 	we = cache_lookup_distinct(mc, "*");
+ 	if (we) {
+@@ -2702,7 +2701,7 @@ next:
+ 			}
+ 		}
+ 	}
+-	pthread_cleanup_pop(1);
++	cache_unlock(mc);
+ 	free(query);
+ 
+ 	return ret;
+@@ -2812,13 +2811,22 @@ int lookup_mount(struct autofs_point *ap
+ 		if (me->status >= time(NULL)) {
+ 			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
++
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, key);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, key);
++				cache_unlock(smc);
++			}
+ 		}
+-
+-		/* Negative timeout expired for non-existent entry. */
+-		if (!me->mapent)
+-			cache_delete(me->mc, key);
+-
+-		cache_unlock(me->mc);
+ 	}
+ 
+         /*
+--- autofs-5.0.5.orig/modules/lookup_nisplus.c
++++ autofs-5.0.5/modules/lookup_nisplus.c
+@@ -421,7 +421,6 @@ static int check_map_indirect(struct aut
+ 		return NSS_STATUS_UNAVAIL;
+ 	}
+ 
+-	pthread_cleanup_push(cache_lock_cleanup, mc);
+ 	cache_writelock(mc);
+ 	t_last_read = ap->exp_runfreq + 1;
+ 	me = cache_lookup_first(mc);
+@@ -442,8 +441,8 @@ static int check_map_indirect(struct aut
+ 			exists->status = 0;
+ 		}
+ 	}
+-	pthread_cleanup_pop(1);
+-	
++	cache_unlock(mc);
++
+ 	if (t_last_read > ap->exp_runfreq && ret & CHE_UPDATED)
+ 		source->stale = 1;
+ 
+@@ -459,7 +458,6 @@ static int check_map_indirect(struct aut
+ 		 * Check for map change and update as needed for
+ 		 * following cache lookup.
+ 		*/
+-		pthread_cleanup_push(cache_lock_cleanup, mc);
+ 		cache_writelock(mc);
+ 		we = cache_lookup_distinct(mc, "*");
+ 		if (we) {
+@@ -473,7 +471,7 @@ static int check_map_indirect(struct aut
+ 			if (wild & (CHE_OK | CHE_UPDATED))
+ 				source->stale = 1;
+ 		}
+-		pthread_cleanup_pop(1);
++		cache_unlock(mc);
+ 
+ 		if (wild & (CHE_UPDATED | CHE_OK))
+ 			return NSS_STATUS_SUCCESS;
+@@ -516,13 +514,22 @@ int lookup_mount(struct autofs_point *ap
+ 		if (me->status >= time(NULL)) {
+ 			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
+-		}
+-
+-		/* Negative timeout expired for non-existent entry. */
+-		if (!me->mapent)
+-			cache_delete(me->mc, key);
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
+ 
+-		cache_unlock(me->mc);
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, key);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, key);
++				cache_unlock(smc);
++			}
++		}
+ 	}
+ 
+ 	/*
+--- autofs-5.0.5.orig/modules/lookup_program.c
++++ autofs-5.0.5/modules/lookup_program.c
+@@ -135,17 +135,26 @@ int lookup_mount(struct autofs_point *ap
+ 		if (me->status >= time(NULL)) {
+ 			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
+-		}
+-
+-		/* Negative timeout expired for non-existent entry. */
+-		if (!me->mapent)
+-			cache_delete(me->mc, name);
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
+ 
+-		cache_unlock(me->mc);
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, name);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, name);
++				cache_unlock(smc);
++			}
++		}
+ 	}
+ 
+ 	/* Catch installed direct offset triggers */
+-	cache_writelock(mc);
++	cache_readlock(mc);
+ 	me = cache_lookup_distinct(mc, name);
+ 	if (!me) {
+ 		cache_unlock(mc);
+@@ -191,7 +200,11 @@ int lookup_mount(struct autofs_point *ap
+ 				     " key %s, returning fail", name);
+ 				return NSS_STATUS_UNAVAIL;
+ 			}
+-			cache_delete(mc, name);
++			cache_unlock(mc);
++			cache_writelock(mc);
++			me = cache_lookup_distinct(mc, name);
++			if (me)
++				cache_delete(mc, name);
+ 			cache_unlock(mc);
+ 		}
+ 	}
+--- autofs-5.0.5.orig/modules/lookup_yp.c
++++ autofs-5.0.5/modules/lookup_yp.c
+@@ -533,7 +533,6 @@ static int check_map_indirect(struct aut
+ 		source->stale = 1;
+ 	}
+ 
+-	pthread_cleanup_push(cache_lock_cleanup, mc);
+ 	cache_writelock(mc);
+ 	exists = cache_lookup_distinct(mc, key);
+ 	/* Not found in the map but found in the cache */
+@@ -545,7 +544,7 @@ static int check_map_indirect(struct aut
+ 			exists->status = 0;
+ 		}
+ 	}
+-	pthread_cleanup_pop(1);
++	cache_unlock(mc);
+ 
+ 	if (ret == CHE_MISSING) {
+ 		struct mapent *we;
+@@ -559,7 +558,6 @@ static int check_map_indirect(struct aut
+ 		 * Check for map change and update as needed for
+ 		 * following cache lookup.
+ 		 */
+-		pthread_cleanup_push(cache_lock_cleanup, mc);
+ 		cache_writelock(mc);
+ 		we = cache_lookup_distinct(mc, "*");
+ 		if (we) {
+@@ -573,7 +571,7 @@ static int check_map_indirect(struct aut
+ 			if (wild & (CHE_OK | CHE_UPDATED))
+ 				source->stale = 1;
+ 		}
+-		pthread_cleanup_pop(1);
++		cache_unlock(mc);
+ 
+ 		if (wild & (CHE_OK | CHE_UPDATED))
+ 			return NSS_STATUS_SUCCESS;
+@@ -616,13 +614,22 @@ int lookup_mount(struct autofs_point *ap
+ 		if (me->status >= time(NULL)) {
+ 			cache_unlock(me->mc);
+ 			return NSS_STATUS_NOTFOUND;
+-		}
+-
+-		/* Negative timeout expired for non-existent entry. */
+-		if (!me->mapent)
+-			cache_delete(me->mc, key);
++		} else {
++			struct mapent_cache *smc = me->mc;
++			struct mapent *sme;
+ 
+-		cache_unlock(me->mc);
++			if (me->mapent)
++				cache_unlock(smc);
++			else {
++				cache_unlock(smc);
++				cache_writelock(smc);
++				sme = cache_lookup_distinct(smc, key);
++				/* Negative timeout expired for non-existent entry. */
++				if (sme && !sme->mapent)
++					cache_delete(smc, key);
++				cache_unlock(smc);
++			}
++		}
+ 	}
+ 
+ 	 /*
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-restart.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-restart.patch
@@ -0,0 +1,34 @@
+autofs-5.0.5 - fix restart
+
+From: Ian Kent <raven@themaw.net>
+
+The recent LSB improvement change has introduced a problem with
+the restart action.
+---
+
+ CHANGELOG             |    1 +
+ redhat/autofs.init.in |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -35,6 +35,7 @@
+ - remove state machine timed wait.
+ - add locality as valid ldap master map attribute.
+ - fix remount locking.
++- fix init script restart option.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/redhat/autofs.init.in
++++ autofs-5.0.5/redhat/autofs.init.in
+@@ -126,7 +126,7 @@ function stop() {
+ }
+ 
+ function restart() {
+-	status > /dev/null 2>&1
++	status autofs > /dev/null 2>&1
+ 	if [ $? -eq 0 ]; then
+ 		stop
+ 	fi
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-rpc-large-export-list.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-rpc-large-export-list.patch
@@ -0,0 +1,142 @@
+autofs-5.0.5 - fix rpc fail on large export list
+
+From: Ian Kent <raven@themaw.net>
+
+If the export list on a server is larger than the UDP transport packet
+size the transfer will fail and autofs will try TCP instead, but there
+were some problems with the conversion to allow for IPv6 using libtirpc.
+
+When creating the local socket for an RPC connection we incorrectly
+performed a connect instead of a bind to the ilocal TCP socket. Aslo the
+timed connect, which should be done before creating the RPC client was
+not being done, which can lead to lengthy timeouts.
+---
+
+ CHANGELOG      |    1 +
+ lib/rpc_subs.c |   47 ++++++++++++++++++++++++-----------------------
+ 2 files changed, 25 insertions(+), 23 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 88bcc1b..20566a6 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -15,6 +15,7 @@
+ - fix pidof init script usage.
+ - check for path mount location in generic module.
+ - dont fail mount on access fail.
++- fix rpc fail on large export list.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
+index 628f0fc..3b11dce 100644
+--- a/lib/rpc_subs.c
++++ b/lib/rpc_subs.c
+@@ -53,6 +53,7 @@
+ /* Get numeric value of the n bits starting at position p */
+ #define getbits(x, p, n)      ((x >> (p + 1 - n)) & ~(~0 << n))
+ 
++static int connect_nb(int, struct sockaddr *, socklen_t, struct timeval *);
+ inline void dump_core(void);
+ 
+ static CLIENT *rpc_clntudp_create(struct sockaddr *addr, struct conn_info *info, int *fd)
+@@ -97,11 +98,17 @@ static CLIENT *rpc_clnttcp_create(struct sockaddr *addr, struct conn_info *info,
+ 	struct sockaddr_in *in4_raddr;
+ 	struct sockaddr_in6 *in6_raddr;
+ 	CLIENT *client = NULL;
++	socklen_t slen;
+ 
+ 	switch (addr->sa_family) {
+ 	case AF_INET:
+ 		in4_raddr = (struct sockaddr_in *) addr;
+ 		in4_raddr->sin_port = htons(info->port);
++		slen = sizeof(struct sockaddr_in);
++
++		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
++			break;
++
+ 		client = clnttcp_create(in4_raddr,
+ 					info->program, info->version, fd,
+ 					info->send_sz, info->recv_sz);
+@@ -114,6 +121,11 @@ static CLIENT *rpc_clnttcp_create(struct sockaddr *addr, struct conn_info *info,
+ #else
+ 		in6_raddr = (struct sockaddr_in6 *) addr;
+ 		in6_raddr->sin6_port = htons(info->port);
++		slen = sizeof(struct sockaddr_in6);
++
++		if (connect_nb(*fd, addr, slen, &info->timeout) < 0)
++			break;
++
+ 		client = clnttcp6_create(in6_raddr,
+ 					 info->program, info->version, fd,
+ 					 info->send_sz, info->recv_sz);
+@@ -260,32 +272,21 @@ static CLIENT *rpc_do_create_client(struct sockaddr *addr, struct conn_info *inf
+ 		return NULL;
+ 	}
+ 
++	if (!info->client) {
++		*fd = open_sock(addr->sa_family, type, proto);
++		if (*fd < 0)
++			return NULL;
++
++		if (bind(*fd, laddr, slen) < 0)
++			return NULL;
++	}
++
+ 	switch (info->proto->p_proto) {
+ 	case IPPROTO_UDP:
+-		if (!info->client) {
+-			*fd = open_sock(addr->sa_family, type, proto);
+-			if (*fd < 0)
+-				return NULL;
+-
+-			if (bind(*fd, laddr, slen) < 0) {
+-				close(*fd);
+-				return NULL;
+-			}
+-		}
+ 		client = rpc_clntudp_create(addr, info, fd);
+ 		break;
+ 
+ 	case IPPROTO_TCP:
+-		if (!info->client) {
+-			*fd = open_sock(addr->sa_family, type, proto);
+-			if (*fd < 0)
+-				return NULL;
+-
+-			if (connect_nb(*fd, laddr, slen, &info->timeout) < 0) {
+-				close(*fd);
+-				return NULL;
+-			}
+-		}
+ 		client = rpc_clnttcp_create(addr, info, fd);
+ 		break;
+ 
+@@ -327,7 +328,7 @@ static CLIENT *create_udp_client(struct conn_info *info)
+ 		if (client)
+ 			goto done;
+ 
+-		if (!info->client) {
++		if (!info->client && fd != RPC_ANYSOCK) {
+ 			close(fd);
+ 			fd = RPC_ANYSOCK;
+ 		}
+@@ -352,7 +353,7 @@ static CLIENT *create_udp_client(struct conn_info *info)
+ 		if (client)
+ 			break;
+ 
+-		if (!info->client) {
++		if (!info->client && fd != RPC_ANYSOCK) {
+ 			close(fd);
+ 			fd = RPC_ANYSOCK;
+ 		}
+@@ -477,7 +478,7 @@ static CLIENT *create_tcp_client(struct conn_info *info)
+ 		if (client)
+ 			break;
+ 
+-		if (!info->client) {
++		if (!info->client && fd != RPC_ANYSOCK) {
+ 			close(fd);
+ 			fd = RPC_ANYSOCK;
+ 		}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-sanity-checks-for-brackets-in-server-name.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-sanity-checks-for-brackets-in-server-name.patch
@@ -0,0 +1,64 @@
+autofs-5.0.5 - fix sanity checks for brackets in server name
+
+From: Siddhesh Poyarekar <siddhesh.poyarekar@gmail.com>
+
+When autofs is configured as follows:
+
+* -nodev,nosuid,intr,soft,retry=10,proto=tcp &:/tmp1
+
+One could make a mount request as follows:
+
+df /autom/tmp1/som\(efile
+
+and crash automount, since automount tries to parse the brackets to
+get the weight for the server. Automount should not parse these
+brackets if they're escaped.
+
+Also throw a syntax error in case of mismatched brackets instead of
+crashing. Sample configuration for this:
+
+* -nodev,nosuid,intr,soft,retry=10,proto=tcp foo(2:/tmp1
+
+Signed-off-by: Siddhesh Poyarekar <siddhesh.poyarekar@gmail.com>
+Signed-off-by: Ian Kent <raven@themaw.net>
+---
+
+ CHANGELOG            |    1 +
+ modules/replicated.c |    8 +++++++-
+ 2 files changed, 8 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -59,6 +59,7 @@
+ - reset negative status on cache prune.
+ - fix wildcard map entry match.
+ - fix sasl bind host name selection.
++- fix sanity checks for brackets in server name.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/replicated.c
++++ autofs-5.0.5/modules/replicated.c
+@@ -1225,7 +1225,7 @@ static char *seek_delim(const char *s)
+ 	char *delim;
+ 
+ 	delim = strpbrk(p, "(, \t:");
+-	if (delim && *delim != ':')
++	if (delim && *delim != ':' && (delim == s || *(delim - 1) != '\\'))
+ 		return delim;
+ 
+ 	while (*p) {
+@@ -1274,6 +1274,12 @@ int parse_location(unsigned logopt, stru
+ 					*delim = '\0';
+ 					weight = atoi(w);
+ 				}
++				else {
++					/* syntax error - Mismatched brackets */
++					free_host_list(hosts);
++					free(str);
++					return 0;
++				}
+ 				delim++;
+ 			}
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-sasl-bind-host-name-selection.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-sasl-bind-host-name-selection.patch
@@ -0,0 +1,43 @@
+autofs-5.0.5 - fix sasl bind host name selection
+
+From: Ian Kent <ikent@redhat.com>
+
+A host name is needed when starting a sasl client. But the ldap
+library can return a list of host names with the port appended
+following a colon. With IPv6 the host name itself may have colons
+so a forward search can no longer be used to find the colon
+delimiting the port number and a reverse search can't be used
+because it may end up including more than one host name.
+---
+
+ CHANGELOG            |    1 +
+ modules/cyrus-sasl.c |    7 +++++++
+ 2 files changed, 8 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -58,6 +58,7 @@
+ - add option to dump configured automount maps.
+ - reset negative status on cache prune.
+ - fix wildcard map entry match.
++- fix sasl bind host name selection.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/cyrus-sasl.c
++++ autofs-5.0.5/modules/cyrus-sasl.c
+@@ -738,6 +738,13 @@ sasl_bind_mech(unsigned logopt, LDAP *ld
+ 		return NULL;
+ 	}
+ 
++	/*
++	 * We need a host name to start the client.
++	 * But the ldap library can return a list of host names so
++	 * just use the first one.
++	 */
++	if ((tmp = strchr(host, ' ')))
++		*tmp = '\0';
+ 	if ((tmp = strrchr(host, ':'))) {
+ 		if (*(tmp - 1) != ']') {
+ 			*tmp = '\0';
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-stale-init-for-file-map-instance.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-stale-init-for-file-map-instance.patch
@@ -0,0 +1,39 @@
+autofs-5.0.5 - fix stale initialization for file map instance
+
+From: Ian Kent <raven@themaw.net>
+
+Somehow, during the changes to minimize reading of file maps, an error
+of not initializing a field of the map source instance structure got
+through undetected. This has the effect of preventing all file map
+lookups, following the first one, to fail.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    1 +
+ 2 files changed, 2 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 7997d1d..8b62370 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -7,6 +7,7 @@
+ - fix compile fail with when LDAP is excluded.
+ - more code analysis corrections (and fix a typo in an init script).
+ - fix backwards #ifndef INET6.
++- fix stale initialization for file map instance.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/lookup.c b/daemon/lookup.c
+index 9d5a5c8..665ada0 100644
+--- a/daemon/lookup.c
++++ b/daemon/lookup.c
+@@ -398,6 +398,7 @@ static enum nsswitch_status read_map_source(struct nss_source *this,
+ 	tmap.instance = map->instance;
+ 	tmap.recurse = map->recurse;
+ 	tmap.depth = map->depth;
++	tmap.stale = map->stale;
+ 	tmap.argc = 0;
+ 	tmap.argv = NULL;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-stale-map-read.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-stale-map-read.patch
@@ -0,0 +1,119 @@
+autofs-5.0.5 - fix stale map read
+
+From: Ian Kent <raven@themaw.net>
+
+A previous patch to fix direct maps not updating on re-read has
+a side effect of causing maps to always be re-read on lookup.
+This is because, following the application of the previous patch,
+the map stale status is no longer being updated on a successful
+map read.
+---
+
+ CHANGELOG        |    1 +
+ daemon/lookup.c  |    1 +
+ daemon/state.c   |    1 -
+ include/master.h |    1 +
+ lib/master.c     |   37 +++++++++++++++++++++++++------------
+ 5 files changed, 28 insertions(+), 13 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -46,6 +46,7 @@
+ - fix direct map not updating on reread.
+ - remove ERR_remove_state() openssl call.
+ - fix next task list update.
++- fix stale map read.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -1122,6 +1122,7 @@ int lookup_prune_cache(struct autofs_poi
+ 		cache_readlock(map->mc);
+ 		lookup_prune_one_cache(ap, map->mc, age);
+ 		pthread_cleanup_pop(1);
++		clear_stale_instances(map);
+ 		map->stale = 0;
+ 		map = map->next;
+ 	}
+--- autofs-5.0.5.orig/daemon/state.c
++++ autofs-5.0.5/daemon/state.c
+@@ -501,7 +501,6 @@ static void *do_readmap(void *arg)
+ 		pthread_cleanup_pop(1);
+ 		pthread_cleanup_pop(1);
+ 		pthread_cleanup_pop(1);
+-		lookup_prune_cache(ap, now);
+ 	}
+ 
+ 	pthread_cleanup_pop(1);
+--- autofs-5.0.5.orig/include/master.h
++++ autofs-5.0.5/include/master.h
+@@ -88,6 +88,7 @@ struct map_source *
+ master_find_source_instance(struct map_source *, const char *, const char *, int, const char **);
+ struct map_source *
+ master_add_source_instance(struct map_source *, const char *, const char *, time_t, int, const char **);
++void clear_stale_instances(struct map_source *);
+ void send_map_update_request(struct autofs_point *);
+ void master_source_writelock(struct master_mapent *);
+ void master_source_readlock(struct master_mapent *);
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -464,7 +464,26 @@ master_add_source_instance(struct map_so
+ 	return new;
+ }
+ 
+-static void check_stale_instances(struct map_source *source)
++static int check_stale_instances(struct map_source *source)
++{
++	struct map_source *map;
++
++	if (!source)
++		return 0;
++
++	map = source->instance;
++	while (map) {
++		if (map->stale)
++			return 1;
++		if (check_stale_instances(map))
++			return 1;
++		map = map->next;
++	}
++
++	return 0;
++}
++
++void clear_stale_instances(struct map_source *source)
+ {
+ 	struct map_source *map;
+ 
+@@ -473,11 +492,9 @@ static void check_stale_instances(struct
+ 
+ 	map = source->instance;
+ 	while (map) {
+-		if (map->stale) {
+-			source->stale = 1;
+-			break;
+-		}
+-		check_stale_instances(map->instance);
++		clear_stale_instances(map);
++		if (map->stale)
++			map->stale = 0;
+ 		map = map->next;
+ 	}
+ 
+@@ -495,12 +512,8 @@ void send_map_update_request(struct auto
+ 
+ 	map = ap->entry->maps;
+ 	while (map) {
+-		check_stale_instances(map);
+-		map = map->next;
+-	}
+-
+-	map = ap->entry->maps;
+-	while (map) {
++		if (check_stale_instances(map))
++			map->stale = 1;
+ 		if (map->stale) {
+ 			need_update = 1;
+ 			break;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-strdup-return-value-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-strdup-return-value-check.patch
@@ -0,0 +1,38 @@
+autofs-5.0.5 - fix strdup() return value check
+
+From: Ian Kent <raven@themaw.net>
+
+Patch posted by Leonardo Chiquitto.
+
+Fix copy and paste error when checking strdup() return value, originally
+reported by David Binderman in:
+
+http://bugzilla.novell.com/show_bug.cgi?id=523348
+---
+
+ CHANGELOG      |    1 +
+ lib/defaults.c |    2 +-
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -20,6 +20,7 @@
+ - fix reconnect get base dn.
+ - fix random selection option.
+ - fix disable timeout.
++- fix strdup() return value check (Leonardo Chiquitto).
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/defaults.c
++++ autofs-5.0.5/lib/defaults.c
+@@ -65,7 +65,7 @@ static char *get_env_string(const char *
+ 		return NULL;
+ 
+ 	res = strdup(val);
+-	if (!val)
++	if (!res)
+ 		return NULL;
+ 
+ 	return res;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-timeout-in-connect_nb.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-timeout-in-connect_nb.patch
@@ -0,0 +1,44 @@
+autofs-5.0.5 - fix timeout in connect_nb()
+
+From: Ian Kent <raven@themaw.net>
+
+When changing the timed wait from using select(2) to poll(2) in
+connect_nb(), to overcome the 1024 file handle limit of select(),
+the wait timeout was not converted from seconds to milliseconds.
+---
+
+ CHANGELOG      |    1 +
+ lib/rpc_subs.c |    7 +++++++
+ 2 files changed, 8 insertions(+), 0 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index ccf2d32..dd093e2 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -11,6 +11,7 @@
+ - add "preen" fsck for ext4 mounts.
+ - don't use master_lex_destroy() to clear parse buffer.
+ - make documentation for set-log-priority clearer.
++- fix timeout in connect_nb().
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
+index cafc775..628f0fc 100644
+--- a/lib/rpc_subs.c
++++ b/lib/rpc_subs.c
+@@ -161,6 +161,13 @@ static int connect_nb(int fd, struct sockaddr *addr, socklen_t len, struct timev
+ 	if (ret == 0)
+ 		goto done;
+ 
++	if (timeout != -1) {
++		if (timeout >= (INT_MAX - 1)/1000)
++			timeout = INT_MAX - 1;
++		else
++			timeout = timeout * 1000;
++	}
++
+ 	pfd[0].fd = fd;
+ 	pfd[0].events = POLLOUT;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-wildcard-map-entry-match.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-fix-wildcard-map-entry-match.patch
@@ -0,0 +1,59 @@
+autofs-5.0.5 - fix wildcard map entry match
+
+From: Ian Kent <raven@themaw.net>
+
+In some cases we can get a key string that includes a '*' at the start.
+This causes an incorrect comparison in the cache library routines and can
+lead to a segmentation fault.
+
+This patch enures that the key length is also considered when checking the
+wildcard key entry.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    4 ++--
+ lib/cache.c     |    2 +-
+ 3 files changed, 4 insertions(+), 3 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -57,6 +57,7 @@
+ - add base64 password encode.
+ - add option to dump configured automount maps.
+ - reset negative status on cache prune.
++- fix wildcard map entry match.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -592,7 +592,7 @@ int lookup_ghost(struct autofs_point *ap
+ 		cache_readlock(mc);
+ 		me = cache_enumerate(mc, NULL);
+ 		while (me) {
+-			if (*me->key == '*')
++			if (!strcmp(me->key, "*"))
+ 				goto next;
+ 
+ 			if (*me->key == '/') {
+@@ -1036,7 +1036,7 @@ void lookup_prune_one_cache(struct autof
+ 
+ 		key = strdup(me->key);
+ 		me = cache_enumerate(mc, me);
+-		if (!key || *key == '*') {
++		if (!key || !strcmp(key, "*")) {
+ 			if (key)
+ 				free(key);
+ 			continue;
+--- autofs-5.0.5.orig/lib/cache.c
++++ autofs-5.0.5/lib/cache.c
+@@ -739,7 +739,7 @@ int cache_update(struct mapent_cache *mc
+ 	me = cache_lookup(mc, key);
+ 	while (me && me->source != ms)
+ 		me = cache_lookup_key_next(me);
+-	if (!me || (*me->key == '*' && *key != '*')) {
++	if (!me || (!strcmp(me->key, "*") && strcmp(key, "*"))) {
+ 		ret = cache_add(mc, ms, key, mapent, age);
+ 		if (!ret) {
+ 			debug(logopt, "failed for %s", key);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-include-ip-address-in-debug-logging.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-include-ip-address-in-debug-logging.patch
@@ -0,0 +1,118 @@
+autofs-5.0.5 - include ip address in debug logging
+
+From: Ian Kent <raven@themaw.net>
+
+When probing availability of a host also log the network address along
+with the host name.
+---
+
+ CHANGELOG            |    1 +
+ include/rpc_subs.h   |    1 +
+ lib/rpc_subs.c       |   20 ++++++++++++++++++++
+ modules/replicated.c |   24 +++++++++++++++++++-----
+ 4 files changed, 41 insertions(+), 5 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -41,6 +41,7 @@
+ - add simple bind authentication.
+ - use weight only for server selection.
+ - fix isspace() wild card substition.
++- include ip address in debug logging.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/include/rpc_subs.h
++++ autofs-5.0.5/include/rpc_subs.h
+@@ -69,6 +69,7 @@ int rpc_ping_proto(struct conn_info *);
+ int rpc_ping(const char *, long, long, unsigned int);
+ double elapsed(struct timeval, struct timeval);
+ int rpc_time(const char *, unsigned int, unsigned int, long, long, unsigned int, double *);
++const char *get_addr_string(struct sockaddr *, char *, socklen_t);
+ 
+ #endif
+ 
+--- autofs-5.0.5.orig/lib/rpc_subs.c
++++ autofs-5.0.5/lib/rpc_subs.c
+@@ -983,6 +983,26 @@ try_tcp:
+ 	return exportlist;
+ }
+ 
++const char *get_addr_string(struct sockaddr *sa, char *name, socklen_t len)
++{
++	void *addr;
++
++	if (len < INET6_ADDRSTRLEN)
++		return NULL;
++
++	if (sa->sa_family == AF_INET) {
++		struct sockaddr_in *ipv4 = (struct sockaddr_in *) sa;
++		addr = &(ipv4->sin_addr);
++	} else if (sa->sa_family == AF_INET6) {
++		struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *) sa;
++		addr = &(ipv6->sin6_addr);
++	} else {
++		return NULL;
++	}
++
++	return inet_ntop(sa->sa_family, addr, name, len);
++}
++
+ #if 0
+ #include <stdio.h>
+ 
+--- autofs-5.0.5.orig/modules/replicated.c
++++ autofs-5.0.5/modules/replicated.c
+@@ -526,6 +526,8 @@ static unsigned int get_nfs_info(unsigne
+ 	char *have_port_opt = options ? strstr(options, "port=") : NULL;
+ 	unsigned int random_selection = host->options & MOUNT_FLAG_RANDOM_SELECT;
+ 	unsigned int use_weight_only = host->options & MOUNT_FLAG_USE_WEIGHT_ONLY;
++	socklen_t len = INET6_ADDRSTRLEN;
++	char buf[len + 1];
+ 	struct pmap parms;
+ 	struct timeval start, end;
+ 	struct timezone tz;
+@@ -533,9 +535,14 @@ static unsigned int get_nfs_info(unsigne
+ 	double taken = 0;
+ 	int status, count = 0;
+ 
+-	debug(logopt,
+-	      "called for host %s proto %s version 0x%x",
+-	      host->name, proto, version);
++	if (host->addr)
++		debug(logopt, "called with host %s(%s) proto %s version 0x%x",
++		      host->name, get_addr_string(host->addr, buf, len),
++		      proto, version);
++	else
++		debug(logopt,
++		      "called for host %s proto %s version 0x%x",
++		      host->name, proto, version);
+ 
+ 	memset(&parms, 0, sizeof(struct pmap));
+ 
+@@ -748,6 +755,8 @@ static int get_supported_ver_and_cost(un
+ 	char *have_port_opt = options ? strstr(options, "port=") : NULL;
+ 	unsigned int random_selection = host->options & MOUNT_FLAG_RANDOM_SELECT;
+ 	unsigned int use_weight_only = host->options & MOUNT_FLAG_USE_WEIGHT_ONLY;
++	socklen_t len = INET6_ADDRSTRLEN;
++	char buf[len + 1];
+ 	struct conn_info pm_info, rpc_info;
+ 	struct pmap parms;
+ 	const char *proto;
+@@ -758,8 +767,13 @@ static int get_supported_ver_and_cost(un
+ 	time_t timeout = RPC_TIMEOUT;
+ 	int status;
+ 
+-	debug(logopt,
+-	      "called with host %s version 0x%x", host->name, version);
++	if (host->addr)
++		debug(logopt, "called with host %s(%s) version 0x%x",
++			host->name, get_addr_string(host->addr, buf, len),
++			version);
++	else
++		debug(logopt, "called with host %s version 0x%x",
++			host->name, version);
+ 
+ 	memset(&pm_info, 0, sizeof(struct conn_info));
+ 	memset(&rpc_info, 0, sizeof(struct conn_info));
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-include-krb5-library.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-include-krb5-library.patch
@@ -0,0 +1,194 @@
+autofs-5.0.5 - include krb5 library
+
+From: Ian Kent <raven@themaw.net>
+
+Since the Cyrus SASL module calls Kerberos directly we should be
+linking against the Kerberos librarys.
+---
+
+ Makefile.conf.in |    2 +
+ aclocal.m4       |   19 +++++++++++++++
+ configure        |   67 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
+ configure.in     |    5 +++-
+ modules/Makefile |    4 +--
+ 5 files changed, 93 insertions(+), 4 deletions(-)
+
+
+--- autofs-5.0.5.orig/Makefile.conf.in
++++ autofs-5.0.5/Makefile.conf.in
+@@ -31,6 +31,8 @@ XML_FLAGS = @XML_FLAGS@
+ SASL = @HAVE_SASL@
+ LIBSASL= @LIBSASL@
+ SASL_FLAGS = @SASL_FLAGS@
++KRB5_LIBS=@KRB5_LIBS@
++KRB5_FLAGS=@KRB5_FLAGS@
+ 
+ # NIS+ support: yes (1) no (0)
+ NISPLUS = @HAVE_NISPLUS@
+--- autofs-5.0.5.orig/aclocal.m4
++++ autofs-5.0.5/aclocal.m4
+@@ -215,6 +215,25 @@ else
+ fi])
+ 
+ dnl --------------------------------------------------------------------------
++dnl AF_CHECK_KRB5
++dnl
++dnl Check for Kerberos 5
++dnl --------------------------------------------------------------------------
++AC_DEFUN([AF_CHECK_KRB5],
++[AC_PATH_PROGS(KRB5_CONFIG, krb5-config, no)
++AC_MSG_CHECKING(for Kerberos library)
++if test "$KRB5_CONFIG" = "no"
++then
++  AC_MSG_RESULT(no)
++  HAVE_KRB5=0
++else
++  AC_MSG_RESULT(yes)
++  HAVE_KRB5=1
++  KRB5_LIBS=`$KRB5_CONFIG --libs`
++  KRB5_FLAGS=`$KRB5_CONFIG --cflags`
++fi])
++
++dnl --------------------------------------------------------------------------
+ dnl AF_CHECK_LIBHESIOD
+ dnl
+ dnl Check for lib hesiod
+--- autofs-5.0.5.orig/configure
++++ autofs-5.0.5/configure
+@@ -640,6 +640,8 @@ ac_subst_vars='LTLIBOBJS
+ LIBOBJS
+ DAEMON_LDFLAGS
+ DAEMON_CFLAGS
++KRB5_FLAGS
++KRB5_LIBS
+ LIBSASL
+ HAVE_SASL
+ SASL_FLAGS
+@@ -657,6 +659,7 @@ LIBHESIOD
+ HAVE_HESIOD
+ LIBRESOLV
+ LIBNSL
++KRB5_CONFIG
+ XML_CONFIG
+ PATH_RPCGEN
+ RPCGEN
+@@ -3786,7 +3789,7 @@ $as_echo "no" >&6; }
+   fi
+ fi
+ 
+-# LDAP SASL auth need libxml
++# LDAP SASL auth needs libxml and Kerberos
+ for ac_prog in xml2-config
+ do
+   # Extract the first word of "$ac_prog", so it can be a program name with args.
+@@ -3864,6 +3867,66 @@ _ACEOF
+     fi
+   fi
+ fi
++for ac_prog in krb5-config
++do
++  # Extract the first word of "$ac_prog", so it can be a program name with args.
++set dummy $ac_prog; ac_word=$2
++{ $as_echo "$as_me:$LINENO: checking for $ac_word" >&5
++$as_echo_n "checking for $ac_word... " >&6; }
++if test "${ac_cv_path_KRB5_CONFIG+set}" = set; then
++  $as_echo_n "(cached) " >&6
++else
++  case $KRB5_CONFIG in
++  [\\/]* | ?:[\\/]*)
++  ac_cv_path_KRB5_CONFIG="$KRB5_CONFIG" # Let the user override the test with a path.
++  ;;
++  *)
++  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
++for as_dir in $PATH
++do
++  IFS=$as_save_IFS
++  test -z "$as_dir" && as_dir=.
++  for ac_exec_ext in '' $ac_executable_extensions; do
++  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
++    ac_cv_path_KRB5_CONFIG="$as_dir/$ac_word$ac_exec_ext"
++    $as_echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
++    break 2
++  fi
++done
++done
++IFS=$as_save_IFS
++
++  ;;
++esac
++fi
++KRB5_CONFIG=$ac_cv_path_KRB5_CONFIG
++if test -n "$KRB5_CONFIG"; then
++  { $as_echo "$as_me:$LINENO: result: $KRB5_CONFIG" >&5
++$as_echo "$KRB5_CONFIG" >&6; }
++else
++  { $as_echo "$as_me:$LINENO: result: no" >&5
++$as_echo "no" >&6; }
++fi
++
++
++  test -n "$KRB5_CONFIG" && break
++done
++test -n "$KRB5_CONFIG" || KRB5_CONFIG="no"
++
++{ $as_echo "$as_me:$LINENO: checking for Kerberos library" >&5
++$as_echo_n "checking for Kerberos library... " >&6; }
++if test "$KRB5_CONFIG" = "no"
++then
++  { $as_echo "$as_me:$LINENO: result: no" >&5
++$as_echo "no" >&6; }
++  HAVE_KRB5=0
++else
++  { $as_echo "$as_me:$LINENO: result: yes" >&5
++$as_echo "yes" >&6; }
++  HAVE_KRB5=1
++  KRB5_LIBS=`$KRB5_CONFIG --libs`
++  KRB5_FLAGS=`$KRB5_CONFIG --cflags`
++fi
+ 
+ #
+ # glibc/libc 6 new libraries
+@@ -5241,6 +5304,8 @@ fi
+ 
+ 
+ 
++
++
+ LDFLAGS="${AF_tmp_ldflags}"
+ 
+ #
+--- autofs-5.0.5.orig/configure.in
++++ autofs-5.0.5/configure.in
+@@ -145,8 +145,9 @@ AF_CHECK_PROG(RPCGEN, rpcgen, , $searchp
+ #
+ AF_SLOPPY_MOUNT()
+ 
+-# LDAP SASL auth need libxml
++# LDAP SASL auth needs libxml and Kerberos
+ AF_CHECK_LIBXML()
++AF_CHECK_KRB5()
+ 
+ #
+ # glibc/libc 6 new libraries
+@@ -275,6 +276,8 @@ AC_SUBST(XML_LIBS)
+ AC_SUBST(SASL_FLAGS)
+ AC_SUBST(HAVE_SASL)
+ AC_SUBST(LIBSASL)
++AC_SUBST(KRB5_LIBS)
++AC_SUBST(KRB5_FLAGS)
+ LDFLAGS="${AF_tmp_ldflags}"
+ 
+ #
+--- autofs-5.0.5.orig/modules/Makefile
++++ autofs-5.0.5/modules/Makefile
+@@ -42,8 +42,8 @@ ifeq ($(LDAP), 1)
+   MODS += lookup_ldap.so
+   ifeq ($(SASL), 1)
+     SASL_OBJ = cyrus-sasl.o cyrus-sasl-extern.o
+-    LDAP_FLAGS += $(SASL_FLAGS) $(XML_FLAGS) -DLDAP_THREAD_SAFE
+-    LIBLDAP += $(LIBSASL) $(XML_LIBS)
++    LDAP_FLAGS += $(SASL_FLAGS) $(XML_FLAGS) $(KRB5_FLAGS) -DLDAP_THREAD_SAFE
++    LIBLDAP += $(LIBSASL) $(XML_LIBS) $(KRB5_LIBS)
+   endif
+ endif
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-documentation-for-set-log-priority-clearer.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-documentation-for-set-log-priority-clearer.patch
@@ -0,0 +1,43 @@
+autofs-5.0.5 - make documentation for set-log-priority clearer
+
+From: Jeff Moyer <jmoyer@redhat.com>
+
+It is not apparent from the documentation of the --set-log-priority
+option that the option can be used to change the log priority of the
+damon while it is running.  This patch tries to fix that.
+
+Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
+---
+
+ CHANGELOG       |    1 +
+ man/automount.8 |    4 +++-
+ 2 files changed, 4 insertions(+), 1 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 329b028..ccf2d32 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -10,6 +10,7 @@
+ - fix stale initialization for file map instance.
+ - add "preen" fsck for ext4 mounts.
+ - don't use master_lex_destroy() to clear parse buffer.
++- make documentation for set-log-priority clearer.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/man/automount.8 b/man/automount.8
+index 9fcaaf4..d9a45c2 100644
+--- a/man/automount.8
++++ b/man/automount.8
+@@ -77,7 +77,9 @@ changes. For example, if verbose logging is set in the configuration then
+ attempting to set logging to basic logging, by using alert, crit, err
+ or emerg won't stop the verbose logging. However, setting logging to debug
+ will lead to everything (debug logging) being logged witch can then also
+-be disabled, returning the daemon to verbose logging.
++be disabled, returning the daemon to verbose logging. This option can be
++specified to change the logging priority of an already running automount
++process.
+ .P
+ The \fIpath\fP argument corresponds to the automounted
+ path name as specified in the master map.
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-nfs4-default-for-redhat-replicated-selection.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-nfs4-default-for-redhat-replicated-selection.patch
@@ -0,0 +1,25 @@
+autofs-5.0.5 - make nfs4 default for RedHat replicated selection configuration
+
+From: Ian Kent <raven@themaw.net>
+
+We know for sure that RHEL-6 and later is set to mount NFSv4 as default and
+fall back to earlier NFS versions if it can't mount as NFSv4. So set our
+default for replicated mount probing to start at NFSv4 instead of v3.
+---
+
+ redhat/autofs.sysconfig.in |    1 +
+ 1 files changed, 1 insertions(+), 0 deletions(-)
+
+
+diff --git a/redhat/autofs.sysconfig.in b/redhat/autofs.sysconfig.in
+index c72cd2b..a46335d 100644
+--- a/redhat/autofs.sysconfig.in
++++ b/redhat/autofs.sysconfig.in
+@@ -40,6 +40,7 @@ BROWSE_MODE="no"
+ # 			       used for single host map entries.
+ #
+ #MOUNT_NFS_DEFAULT_PROTOCOL=3
++MOUNT_NFS_DEFAULT_PROTOCOL=4
+ #
+ # APPEND_OPTIONS - append to global options instead of replace.
+ #
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-redhat-init-script-more-lsb-compliant.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-make-redhat-init-script-more-lsb-compliant.patch
@@ -0,0 +1,112 @@
+autofs-5.0.5 - make redhat init script more lsb compliant
+
+From: Ian Kent <raven@themaw.net>
+
+
+---
+
+ CHANGELOG             |    1 +
+ redhat/autofs.init.in |   39 ++++++++++++++++++++++++++++++++-------
+ 2 files changed, 33 insertions(+), 7 deletions(-)
+
+
+--- autofs-5.0.5.orig/redhat/autofs.init.in
++++ autofs-5.0.5/redhat/autofs.init.in
+@@ -86,14 +86,18 @@ function start() {
+ 	fi
+ 
+ 	echo -n $"Starting $prog: "
+-	$prog $OPTIONS 
++	$prog $OPTIONS --pid-file /var/run/autofs.pid
+ 	RETVAL=$?
+ 	if [ $RETVAL -eq 0 ] ; then
+ 		success "$prog startup"
+ 	else
+ 		failure "$prog startup"
+ 	fi
+-	[ $RETVAL -eq 0 ] && touch /var/lock/subsys/autofs
++	if [ $RETVAL -eq 0 ]; then
++		touch /var/lock/subsys/autofs
++	else
++		RETVAL=1
++	fi
+ 	echo
+ 	return $RETVAL
+ }
+@@ -107,7 +111,11 @@ function stop() {
+ 		[ $RETVAL = 0 -a -z "`pidof $prog`" ] || sleep 3
+ 		count=`expr $count + 1`
+ 	done
+-	[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/autofs
++	if [ $RETVAL -eq 0 ]; then
++		rm -f /var/lock/subsys/autofs
++	else
++		RETVAL=1
++	fi
+ 	if [ -n "`pidof $prog`" ] ; then
+ 		failure "$prog shutdown"
+ 	else
+@@ -118,7 +126,10 @@ function stop() {
+ }
+ 
+ function restart() {
+-	stop
++	status > /dev/null 2>&1
++	if [ $? -eq 0 ]; then
++		stop
++	fi
+ 	start
+ }
+ 
+@@ -142,6 +153,12 @@ function reload() {
+ 
+ RETVAL=0
+ 
++# Only the root user may change the service status
++if [ `id -u` -ne 0 ]; then
++	echo "insufficient privilege to change service status"
++	exit 4
++fi
++
+ case "$1" in
+ 	start)
+ 		start
+@@ -154,7 +171,7 @@ case "$1" in
+ 		stop
+ 		;;
+ 	status)
+-		status $prog
++		status -p /var/run/autofs.pid -l autofs $prog
+ 		;;
+ 	restart)
+ 		restart
+@@ -171,9 +188,17 @@ case "$1" in
+ 			restart
+ 		fi
+ 		;;
+-	*)
++	usage)
+ 		echo $"Usage: $0 {start|forcestart|stop|status|restart|forcerestart|reload|condrestart}"
+-		exit 1;
++		exit 0;
++		;;
++	try-restart|force-reload)
++		echo "$1 service action not supported"
++		exit 3
++		;;
++	*)
++		echo "unknown, invalid or excess argument(s)"
++		exit 2
+ 		;;
+ esac
+ 
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -25,6 +25,7 @@
+ - fix ampersand escape in auto.smb.
+ - add autofs_ldap_auth.conf man page.
+ - fix random selection for host on different network.
++- make redhat init script more lsb compliant.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-mapent-becomes-negative-during-lookup.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-mapent-becomes-negative-during-lookup.patch
@@ -0,0 +1,73 @@
+autofs-5.0.5 - mapent becomes negative during lookup
+
+From: Ian Kent <raven@themaw.net>
+
+During a mount request it is possible for a mapent to become negative
+between the time it is checked on entry and when we fetch the mount
+location information. This is because we drop the cache lock after
+the initial check and take it back again before getting the location
+information.
+---
+
+ CHANGELOG                |    1 +
+ modules/lookup_file.c    |    2 +-
+ modules/lookup_ldap.c    |    2 +-
+ modules/lookup_nisplus.c |    2 +-
+ modules/lookup_yp.c      |    2 +-
+ 5 files changed, 5 insertions(+), 4 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -60,6 +60,7 @@
+ - fix wildcard map entry match.
+ - fix sasl bind host name selection.
+ - fix sanity checks for brackets in server name.
++- fix mapent becomes negative during lookup.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_file.c
++++ autofs-5.0.5/modules/lookup_file.c
+@@ -1055,7 +1055,7 @@ do_cache_lookup:
+ 		if (!me)
+ 			me = cache_lookup_distinct(mc, "*");
+ 	}
+-	if (me && (me->source == source || *me->key == '/')) {
++	if (me && me->mapent && (me->source == source || *me->key == '/')) {
+ 		pthread_cleanup_push(cache_lock_cleanup, mc);
+ 		strcpy(mapent_buf, me->mapent);
+ 		mapent = mapent_buf;
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -2943,7 +2943,7 @@ int lookup_mount(struct autofs_point *ap
+ 		if (!me)
+ 			me = cache_lookup_distinct(mc, "*");
+ 	}
+-	if (me && (me->source == source || *me->key == '/')) {
++	if (me && me->mapent && (me->source == source || *me->key == '/')) {
+ 		strcpy(mapent_buf, me->mapent);
+ 		mapent = mapent_buf;
+ 	}
+--- autofs-5.0.5.orig/modules/lookup_nisplus.c
++++ autofs-5.0.5/modules/lookup_nisplus.c
+@@ -569,7 +569,7 @@ int lookup_mount(struct autofs_point *ap
+ 		if (!me)
+ 			me = cache_lookup_distinct(mc, "*");
+ 	}
+-	if (me && (me->source == source || *me->key == '/')) {
++	if (me && me->mapent && (me->source == source || *me->key == '/')) {
+ 		mapent_len = strlen(me->mapent);
+ 		mapent = malloc(mapent_len + 1);
+ 		strcpy(mapent, me->mapent);
+--- autofs-5.0.5.orig/modules/lookup_yp.c
++++ autofs-5.0.5/modules/lookup_yp.c
+@@ -670,7 +670,7 @@ int lookup_mount(struct autofs_point *ap
+ 		if (!me)
+ 			me = cache_lookup_distinct(mc, "*");
+ 	}
+-	if (me && (me->source == source || *me->key == '/')) {
++	if (me && me->mapent && (me->source == source || *me->key == '/')) {
+ 		mapent_len = strlen(me->mapent);
+ 		mapent = alloca(mapent_len + 1);
+ 		strcpy(mapent, me->mapent);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-more-code-analysis-corrections.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-more-code-analysis-corrections.patch
@@ -0,0 +1,241 @@
+autofs-5.0.5 - more code analysis corrections (and fix a typo in an init script)
+
+From: Jeff Moyer <jmoyer@redhat.com>
+
+- fix an obvious type in Redhat init script.
+- don't call ldap_msgfree when result pointer is null.
+- check return of ldap_parse_result as pointers will be invalid on fail.
+- get rid of a bogus assignment in defaults_free_searchdns.
+- get rid of unused optlen variable in parse_sun.c.
+- check return status of stat(2) in do_mount_direct().
+- get rid of unused name variable in master_add_map_source().
+- check return from ops->askumount() in expire_cleanup().
+- in mount_autofs.c:mount_mount(), don't increment val since we never
+  look at it again.
+- in autofs_sasl_dispose() ctxt must always be valid or we would have
+  a much bigger problem.
+- in st_start_handler() and alarm_start_handler() it is possible for
+  pthread_attr_destroy() to be called with a NULL pointer.
+- we could end up with a non-null result pointer after a failed call to
+  ldap_search_s(), well maybe, so check for it anyway.
+
+Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
+---
+
+ CHANGELOG              |    1 +
+ daemon/direct.c        |    2 +-
+ daemon/state.c         |    5 +++--
+ lib/alarm.c            |    3 ++-
+ lib/defaults.c         |    1 -
+ lib/master.c           |    6 +-----
+ modules/cyrus-sasl.c   |    2 +-
+ modules/lookup_ldap.c  |   13 +++++++++++--
+ modules/mount_autofs.c |    2 +-
+ modules/parse_sun.c    |    3 +--
+ redhat/autofs.init.in  |    2 +-
+ 11 files changed, 23 insertions(+), 17 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 23351c8..b9b1602 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -5,6 +5,7 @@
+ - add mount wait timeout parameter.
+ - special case cifs escapes.
+ - fix compile fail with when LDAP is excluded.
++- more code analysis corrections (and fix a typo in an init script).
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/daemon/direct.c b/daemon/direct.c
+index 0c78627..9b4e57b 100644
+--- a/daemon/direct.c
++++ b/daemon/direct.c
+@@ -1245,7 +1245,7 @@ static void *do_mount_direct(void *arg)
+ 	}
+ 
+ 	status = stat(mt.name, &st);
+-	if (!S_ISDIR(st.st_mode) || st.st_dev != mt.dev) {
++	if (status != 0 || !S_ISDIR(st.st_mode) || st.st_dev != mt.dev) {
+ 		error(ap->logopt,
+ 		     "direct trigger not valid or already mounted %s",
+ 		     mt.name);
+diff --git a/daemon/state.c b/daemon/state.c
+index 71af46a..27bc6de 100644
+--- a/daemon/state.c
++++ b/daemon/state.c
+@@ -160,7 +160,7 @@ void expire_cleanup(void *arg)
+ 			 * been signaled to shutdown.
+ 			 */
+ 			rv = ops->askumount(ap->logopt, ap->ioctlfd, &idle);
+-			if (!idle && !ap->shutdown) {
++			if (!rv && !idle && !ap->shutdown) {
+ 				next = ST_READY;
+ 				if (!ap->submount)
+ 					alarm_add(ap, ap->exp_runfreq);
+@@ -1198,7 +1198,8 @@ int st_start_handler(void)
+ 
+ 	status = pthread_create(&thid, pattrs, st_queue_handler, NULL);
+ 
+-	pthread_attr_destroy(pattrs);
++	if (pattrs)
++		pthread_attr_destroy(pattrs);
+ 
+ 	return !status;
+ }
+diff --git a/lib/alarm.c b/lib/alarm.c
+index 46df38a..f403d8f 100755
+--- a/lib/alarm.c
++++ b/lib/alarm.c
+@@ -239,7 +239,8 @@ int alarm_start_handler(void)
+ 
+ 	status = pthread_create(&thid, pattrs, alarm_handler, NULL);
+ 
+-	pthread_attr_destroy(pattrs);
++	if (pattrs)
++		pthread_attr_destroy(pattrs);
+ 
+ 	return !status;
+ }
+diff --git a/lib/defaults.c b/lib/defaults.c
+index 2204b18..cb8354d 100644
+--- a/lib/defaults.c
++++ b/lib/defaults.c
+@@ -534,7 +534,6 @@ void defaults_free_searchdns(struct ldap_searchdn *sdn)
+ 	struct ldap_searchdn *this = sdn;
+ 	struct ldap_searchdn *next;
+ 
+-	next = this;
+ 	while (this) {
+ 		next = this->next;
+ 		free(this->basedn);
+diff --git a/lib/master.c b/lib/master.c
+index e43f835..8455f40 100644
+--- a/lib/master.c
++++ b/lib/master.c
+@@ -152,7 +152,7 @@ master_add_map_source(struct master_mapent *entry,
+ {
+ 	struct map_source *source;
+ 	char *ntype, *nformat;
+-	const char **tmpargv, *name = NULL;
++	const char **tmpargv;
+ 
+ 	source = malloc(sizeof(struct map_source));
+ 	if (!source)
+@@ -188,10 +188,6 @@ master_add_map_source(struct master_mapent *entry,
+ 	source->argc = argc;
+ 	source->argv = tmpargv;
+ 
+-	/* Can be NULL for "hosts" map */
+-	if (argv)
+-		name = argv[0];
+-
+ 	master_source_writelock(entry);
+ 
+ 	if (!entry->maps)
+diff --git a/modules/cyrus-sasl.c b/modules/cyrus-sasl.c
+index 828143e..92e2226 100644
+--- a/modules/cyrus-sasl.c
++++ b/modules/cyrus-sasl.c
+@@ -911,7 +911,7 @@ void autofs_sasl_dispose(struct lookup_context *ctxt)
+ {
+ 	int status, ret;
+ 
+-	if (ctxt && ctxt->sasl_conn) {
++	if (ctxt->sasl_conn) {
+ 		sasl_dispose(&ctxt->sasl_conn);
+ 		ctxt->sasl_conn = NULL;
+ 	}
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index f1fb9ce..d8bd169 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -389,13 +389,16 @@ static int get_query_dn(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt
+ 				error(logopt,
+ 				      MODPREFIX "query failed for search dn %s: %s",
+ 				      this->basedn, ldap_err2string(rv));
++				if (result) {
++					ldap_msgfree(result);
++					result = NULL;
++				}
+ 			}
+ 
+ 			this = this->next;
+ 		}
+ 
+ 		if (!result) {
+-			ldap_msgfree(result);
+ 			error(logopt,
+ 			      MODPREFIX "failed to find query dn under search base dns");
+ 			free(query);
+@@ -1954,6 +1957,12 @@ do_paged:
+ 		sp->cookie = NULL;
+ 	}
+ 
++	if (rv != LDAP_SUCCESS) {
++		debug(ap->logopt,
++		      MODPREFIX "ldap_parse_result failed with %d", rv);
++		goto out_free;
++	}
++
+ 	/*
+ 	 * Parse the page control returned to get the cookie and
+ 	 * determine whether there are more pages.
+@@ -1970,8 +1979,8 @@ do_paged:
+ 	if (returnedControls)
+ 		ldap_controls_free(returnedControls);
+ 
++out_free:
+ 	ldap_control_free(pageControl);
+-
+ 	return rv;
+ }
+ 
+diff --git a/modules/mount_autofs.c b/modules/mount_autofs.c
+index afb1859..2a5d860 100644
+--- a/modules/mount_autofs.c
++++ b/modules/mount_autofs.c
+@@ -119,7 +119,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
+ 			else if (strncmp(cp, "timeout=", 8) == 0) {
+ 				char *val = strchr(cp, '=');
+ 				unsigned tout;
+-				if (val++) {
++				if (val) {
+ 					int ret = sscanf(cp, "timeout=%u", &tout);
+ 					if (ret)
+ 						timeout = tout;
+diff --git a/modules/parse_sun.c b/modules/parse_sun.c
+index db36ae2..921daf4 100644
+--- a/modules/parse_sun.c
++++ b/modules/parse_sun.c
+@@ -1334,7 +1334,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
+ 	char *pmapent, *options;
+ 	const char *p;
+ 	int mapent_len, rv = 0;
+-	int optlen, cur_state;
++	int cur_state;
+ 	int slashify = ctxt->slashify_colons;
+ 	unsigned int append_options;
+ 
+@@ -1389,7 +1389,6 @@ int parse_mount(struct autofs_point *ap, const char *name,
+ 		logerr(MODPREFIX "strdup: %s", estr);
+ 		return 1;
+ 	}
+-	optlen = strlen(options);
+ 
+ 	p = skipspace(pmapent);
+ 
+diff --git a/redhat/autofs.init.in b/redhat/autofs.init.in
+index fded1d8..806302b 100644
+--- a/redhat/autofs.init.in
++++ b/redhat/autofs.init.in
+@@ -172,7 +172,7 @@ case "$1" in
+ 		fi
+ 		;;
+ 	*)
+-		echo $"Usage: $0 {start|forcestart|stop|status|restart|orcerestart|reload|condrestart}"
++		echo $"Usage: $0 {start|forcestart|stop|status|restart|forcerestart|reload|condrestart}"
+ 		exit 1;
+ 		;;
+ esac
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-mount-using-address-for-rr.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-mount-using-address-for-rr.patch
@@ -0,0 +1,126 @@
+autofs-5.0.5 - mount using address for rr
+
+From: Ian Kent <raven@themaw.net>
+
+When a host has multiple addresses, mount using individual address so
+we can take advantage of the probing and response time calculation that's
+already been done.
+---
+
+ CHANGELOG            |    1 +
+ include/replicated.h |    1 +
+ modules/mount_nfs.c  |   31 +++++++++++++++++++++++++------
+ modules/replicated.c |   11 ++++++++---
+ 4 files changed, 35 insertions(+), 9 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -42,6 +42,7 @@
+ - use weight only for server selection.
+ - fix isspace() wild card substition.
+ - include ip address in debug logging.
++- mount using address for DNS round robin host names.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/include/replicated.h
++++ autofs-5.0.5/include/replicated.h
+@@ -54,6 +54,7 @@ struct host {
+ 	char *name;
+ 	struct sockaddr *addr;
+ 	size_t addr_len;
++	unsigned int rr;
+ 	char *path;
+ 	unsigned int version;
+ 	unsigned int options;
+--- autofs-5.0.5.orig/modules/mount_nfs.c
++++ autofs-5.0.5/modules/mount_nfs.c
+@@ -229,13 +229,32 @@ int mount_mount(struct autofs_point *ap,
+ 
+ 		/* Not a local host - do an NFS mount */
+ 
+-		loc = malloc(strlen(this->name) + 1 + strlen(this->path) + 1);
+-		if (!loc) {
+-			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-			error(ap->logopt, "malloc: %s", estr);
+-			return 1;
++		if (this->rr && this->addr) {
++			socklen_t len = INET6_ADDRSTRLEN;
++			char buf[len + 1];
++			const char *n_addr;
++			n_addr = get_addr_string(this->addr, buf, len);
++			loc = malloc(strlen(n_addr) + strlen(this->path) + 4);
++			if (!loc) {
++				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++				error(ap->logopt, "malloc: %s", estr);
++				return 1;
++			}
++			if (this->addr->sa_family == AF_INET6) {
++				strcpy(loc, "[");
++				strcat(loc, n_addr);
++				strcat(loc, "]");
++			} else
++				strcpy(loc, n_addr);
++		} else {
++			loc = malloc(strlen(this->name) + strlen(this->path) + 2);
++			if (!loc) {
++				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++				error(ap->logopt, "malloc: %s", estr);
++				return 1;
++			}
++			strcpy(loc, this->name);
+ 		}
+-		strcpy(loc, this->name);
+ 		strcat(loc, ":");
+ 		strcat(loc, this->path);
+ 
+--- autofs-5.0.5.orig/modules/replicated.c
++++ autofs-5.0.5/modules/replicated.c
+@@ -1059,7 +1059,8 @@ int prune_host_list(unsigned logopt, str
+ 
+ static int add_new_host(struct host **list,
+ 			const char *host, unsigned int weight,
+-			struct addrinfo *host_addr, unsigned int options)
++			struct addrinfo *host_addr,
++			unsigned int rr, unsigned int options)
+ {
+ 	struct host *new;
+ 	unsigned int prx;
+@@ -1094,6 +1095,7 @@ static int add_new_host(struct host **li
+ 		free_host(new);
+ 		return 0;
+ 	}
++	new->rr = rr;
+ 
+ 	return 1;
+ }
+@@ -1102,6 +1104,7 @@ static int add_host_addrs(struct host **
+ 			  unsigned int weight, unsigned int options)
+ {
+ 	struct addrinfo hints, *ni, *this;
++	int rr = 0;
+ 	int ret;
+ 
+ 	memset(&hints, 0, sizeof(hints));
+@@ -1115,7 +1118,7 @@ static int add_host_addrs(struct host **
+ 
+ 	this = ni;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this, options);
++		ret = add_new_host(list, host, weight, this, 0, options);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
+@@ -1137,8 +1140,10 @@ try_name:
+ 	}
+ 
+ 	this = ni;
++	if (this->ai_next)
++		rr++;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this, options);
++		ret = add_new_host(list, host, weight, this, rr, options);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-refactor-ldap-sasl-bind.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-refactor-ldap-sasl-bind.patch
@@ -0,0 +1,223 @@
+autofs-5.0.5 - refactor ldap sasl bind
+
+From: Ian Kent <raven@themaw.net>
+
+During the sasl authentication (and possible authentication method
+selection) we establish a connection and then dispose of it and then
+authenticate again. This is a little inefficient but some servers
+don't like a second authentication using the same LDAP handle and
+authentication fails when it should succeed. We should use the
+authentication connection once we get it and not perform another
+later.
+
+Also fixed with this patch. If a server returns a set of
+authentication mechanisms that all require authentication, then the
+connection pointer is returned to the caller uninitialized (reported
+and fix provided by Jeff Moyer).
+---
+
+ CHANGELOG             |    1 +
+ modules/cyrus-sasl.c  |   55 ++++++++++++++++++---------------------------
+ modules/lookup_ldap.c |   60 -------------------------------------------------
+ 3 files changed, 23 insertions(+), 93 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index 674a48b..5adcca5 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -1,6 +1,7 @@
+ ??/??/20?? autofs-5.0.6
+ -----------------------
+ - fix included map read fail handling.
++- refactor ldap sasl bind handling.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/modules/cyrus-sasl.c b/modules/cyrus-sasl.c
+index 04001d0..828143e 100644
+--- a/modules/cyrus-sasl.c
++++ b/modules/cyrus-sasl.c
+@@ -87,8 +87,8 @@ static sasl_callback_t callbacks[] = {
+ 	{ SASL_CB_LIST_END, NULL, NULL },
+ };
+ 
+-static char *sasl_auth_id, *sasl_auth_secret;
+-sasl_secret_t *sasl_secret;
++static char *sasl_auth_id = NULL;
++static char *sasl_auth_secret = NULL;
+ 
+ static int
+ sasl_log_func(void *context, int level, const char *message)
+@@ -798,7 +798,7 @@ sasl_bind_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt, const c
+ sasl_conn_t *
+ sasl_choose_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
+ {
+-	sasl_conn_t *conn;
++	sasl_conn_t *conn = NULL;
+ 	int authenticated;
+ 	int i;
+ 	char **mechanisms;
+@@ -845,22 +845,6 @@ sasl_choose_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
+ 	return conn;
+ }
+ 
+-int
+-autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
+-{
+-	sasl_conn_t *conn;
+-
+-	if (!ctxt->sasl_mech)
+-		return -1;
+-
+-	conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
+-	if (!conn)
+-		return -1;
+-
+-	ctxt->sasl_conn = conn;
+-	return 0;
+-}
+-
+ /*
+  *  Routine called when unbinding an ldap connection.
+  */
+@@ -883,35 +867,40 @@ autofs_sasl_unbind(struct lookup_context *ctxt)
+  * -1  -  Failure
+  */
+ int
+-autofs_sasl_init(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
++autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
+ {
+-	sasl_conn_t *conn;
++	sasl_conn_t *conn = NULL;
++
++	/* If we already have a connection use it */
++	if (ctxt->sasl_conn)
++		return 0;
+ 
+ 	sasl_auth_id = ctxt->user;
+ 	sasl_auth_secret = ctxt->secret;
+ 
++	if (ctxt->auth_required & LDAP_AUTH_AUTODETECT) {
++		if (ctxt->sasl_mech) {
++			free(ctxt->sasl_mech);
++			ctxt->sasl_mech = NULL;
++		}
++	}
++
+ 	/*
+ 	 *  If LDAP_AUTH_AUTODETECT is set, it means that there was no
+ 	 *  mechanism specified in the configuration file or auto
+ 	 *  selection has been requested, so try to auto-select an
+ 	 *  auth mechanism.
+ 	 */
+-	if (!(ctxt->auth_required & LDAP_AUTH_AUTODETECT))
++	if (ctxt->sasl_mech)
+ 		conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
+-	else {
+-		if (ctxt->sasl_mech) {
+-			free(ctxt->sasl_mech);
+-			ctxt->sasl_mech = NULL;
+-		}
++	else
+ 		conn = sasl_choose_mech(logopt, ldap, ctxt);
+-	}
+ 
+-	if (conn) {
+-		sasl_dispose(&conn);
+-		return 0;
+-	}
++	if (!conn)
++		return -1;
+ 
+-	return -1;
++	ctxt->sasl_conn = conn;
++	return 0;
+ }
+ 
+ /*
+diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
+index 2ecf5fe..f1fb9ce 100644
+--- a/modules/lookup_ldap.c
++++ b/modules/lookup_ldap.c
+@@ -59,7 +59,6 @@ struct ldap_search_params {
+ 	time_t age;
+ };
+ 
+-static LDAP *auth_init(unsigned logopt, const char *, struct lookup_context *);
+ static int decode_percent_hack(const char *, char **);
+ 
+ #ifndef HAVE_LDAP_CREATE_PAGE_CONTROL
+@@ -600,33 +599,6 @@ static LDAP *connect_to_server(unsigned logopt, const char *uri, struct lookup_c
+ {
+ 	LDAP *ldap;
+ 
+-#ifdef WITH_SASL
+-	/*
+-	 * Determine which authentication mechanism to use if we require
+-	 * authentication.
+-	 */
+-	if (ctxt->auth_required & (LDAP_AUTH_REQUIRED|LDAP_AUTH_AUTODETECT)) {
+-		ldap = auth_init(logopt, uri, ctxt);
+-		if (!ldap && ctxt->auth_required & LDAP_AUTH_AUTODETECT)
+-			info(logopt,
+-			     "no authentication mechanisms auto detected.");
+-		if (!ldap) {
+-			error(logopt, MODPREFIX
+-			      "cannot initialize authentication setup");
+-			return NULL;
+-		}
+-
+-		if (!do_bind(logopt, ldap, uri, ctxt)) {
+-			unbind_ldap_connection(logopt, ldap, ctxt);
+-			autofs_sasl_dispose(ctxt);
+-			error(logopt, MODPREFIX "cannot bind to server");
+-			return NULL;
+-		}
+-
+-		return ldap;
+-	}
+-#endif
+-
+ 	ldap = do_connect(logopt, uri, ctxt);
+ 	if (!ldap) {
+ 		warn(logopt,
+@@ -1074,38 +1046,6 @@ out:
+ 
+ 	return ret;
+ }
+-
+-/*
+- *  Reads in the xml configuration file and parses out the relevant
+- *  information.  If there is no configuration file, then we fall back to
+- *  trying all supported authentication mechanisms until one works.
+- *
+- *  Returns ldap connection on success, with authtype, user and secret
+- *  filled in as appropriate.  Returns NULL on failre.
+- */
+-static LDAP *auth_init(unsigned logopt, const char *uri, struct lookup_context *ctxt)
+-{
+-	int ret;
+-	LDAP *ldap;
+-
+-	ldap = init_ldap_connection(logopt, uri, ctxt);
+-	if (!ldap)
+-		return NULL;
+-
+-	/*
+-	 *  Initialize the sasl library.  It is okay if user and secret
+-	 *  are NULL, here.
+-	 *
+-	 *  The autofs_sasl_init routine will figure out which mechamism
+-	 *  to use. If kerberos is used, it will also take care to initialize
+-	 *  the credential cache and the client and service principals.
+-	 */
+-	ret = autofs_sasl_init(logopt, ldap, ctxt);
+-	if (ret)
+-		return NULL;
+-
+-	return ldap;
+-}
+ #endif
+ 
+ /*
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-remove-ERR_remove_state-openssl-call.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-remove-ERR_remove_state-openssl-call.patch
@@ -0,0 +1,44 @@
+autofs-5.0.5 - remove ERR_remove_state() openssl call
+
+From: Ian Kent <raven@themaw.net>
+
+autofs should never have had to use ERR_remove_state() so remove that call.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |   12 +-----------
+ 2 files changed, 2 insertions(+), 11 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -44,6 +44,7 @@
+ - include ip address in debug logging.
+ - mount using address for DNS round robin host names.
+ - fix direct map not updating on reread.
++- remove ERR_remove_state() openssl call.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -181,18 +181,8 @@ int unbind_ldap_connection(unsigned logo
+ 	int rv;
+ 
+ #ifdef WITH_SASL
+-	/*
+-	 * The OpenSSL library can't handle having its message and error
+-	 * string database loaded multiple times and segfaults if the
+-	 * TLS environment is not reset at the right times. As there
+-	 * is no ldap_stop_tls call in the openldap library we have
+-	 * to do the job ourselves, here and in lookup_done when the
+-	 * module is closed.
+-	 */
+-	if (ctxt->use_tls == LDAP_TLS_RELEASE) {
+-		ERR_remove_state(0);
++	if (ctxt->use_tls == LDAP_TLS_RELEASE)
+ 		ctxt->use_tls = LDAP_TLS_INIT;
+-	}
+ 	autofs_sasl_unbind(ctxt);
+ #endif
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-remove-state-machine-timed-wait.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-remove-state-machine-timed-wait.patch
@@ -0,0 +1,114 @@
+autofs-5.0.5 - remove state machine timed wait
+
+From: Ian Kent <raven@themaw.net>
+
+We are seeing a problem using timed waits when running under KVM.
+
+Using timed condition waits in the state machine (and in some other
+places) has been used because of observed task throughput problems
+in the past. Also, we've seen condition waits not reacting to signals
+occassionaly.
+
+But now we are seeing problems with the setup of the wait time within
+KVM VMs causing the condition wait to go into a tight loop using
+excessive CPU.
+
+Changing the state queue handler to not use timed waits appears to
+not have the previously observed throughput problems, hopefully we
+won't see lost signals either.
+---
+
+ CHANGELOG      |    1 +
+ daemon/state.c |   30 +++++++-----------------------
+ 2 files changed, 8 insertions(+), 23 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -32,6 +32,7 @@
+ - fix null cache race.
+ - fix cache_init() on source re-read.
+ - fix negative cache included map lookup.
++- remove state machine timed wait.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/state.c
++++ autofs-5.0.5/daemon/state.c
+@@ -197,11 +197,11 @@ void expire_cleanup(void *arg)
+ 		}
+ 	}
+ 
++	st_set_done(ap);
++
+ 	if (next != ST_INVAL)
+ 		__st_add_task(ap, next);
+ 
+-	st_set_done(ap);
+-
+ 	st_mutex_unlock();
+ 
+ 	return;
+@@ -332,11 +332,10 @@ static void do_readmap_cleanup(void *arg
+ 	st_mutex_lock();
+ 
+ 	ap->readmap_thread = 0;
+-	st_ready(ap);
+ 	st_set_done(ap);
+-
+ 	if (!ap->submount)
+ 		alarm_add(ap, ap->exp_runfreq);
++	st_ready(ap);
+ 
+ 	st_mutex_unlock();
+ 
+@@ -1060,8 +1059,6 @@ static void *st_queue_handler(void *arg)
+ {
+ 	struct list_head *head;
+ 	struct list_head *p;
+-	struct timespec wait;
+-	struct timeval now;
+ 	int status, ret;
+ 
+ 	st_mutex_lock();
+@@ -1072,17 +1069,11 @@ static void *st_queue_handler(void *arg)
+ 		 * entry is added.
+ 		 */
+ 		head = &state_queue;
+-		gettimeofday(&now, NULL);
+-		wait.tv_sec = now.tv_sec + 1;
+-		wait.tv_nsec = now.tv_usec * 1000;
+ 
+ 		while (list_empty(head)) {
+-			status = pthread_cond_timedwait(&cond, &mutex, &wait);
+-			if (status) {
+-				if (status == ETIMEDOUT)
+-					break;
++			status = pthread_cond_wait(&cond, &mutex);
++			if (status)
+ 				fatal(status);
+-			}
+ 		}
+ 
+ 		p = head->next;
+@@ -1108,18 +1099,11 @@ static void *st_queue_handler(void *arg)
+ 		}
+ 
+ 		while (1) {
+-			gettimeofday(&now, NULL);
+-			wait.tv_sec = now.tv_sec + 1;
+-			wait.tv_nsec = now.tv_usec * 1000;
+-
+ 			signaled = 0;
+ 			while (!signaled) {
+-				status = pthread_cond_timedwait(&cond, &mutex, &wait);
+-				if (status) {
+-					if (status == ETIMEDOUT)
+-						break;
++				status = pthread_cond_wait(&cond, &mutex);
++				if (status)
+ 					fatal(status);
+-				}
+ 			}
+ 
+ 			head = &state_queue;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-replace-gplv3-code.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-replace-gplv3-code.patch
@@ -0,0 +1,791 @@
+autofs-5.0.5 - replace GPLv3 code
+
+From: Ian Kent <raven@themaw.net>
+
+The code to get SRV records from DNS was taken from Samba.
+Samba is a GPLv3 licensed work which forces autofs to GPLv3.
+
+I don't know enough about GPLv3 to know if that is a good thing
+but I also don't like autofs being forced to GPLv3 because one
+of the copyright holders won't grant permission to use the code
+under a GPLv2 license.
+---
+
+ CHANGELOG        |    1 
+ modules/dclist.c |  592 +++++++++++++++++--------------------------------------
+ 2 files changed, 193 insertions(+), 400 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -62,6 +62,7 @@
+ - fix sanity checks for brackets in server name.
+ - fix mapent becomes negative during lookup.
+ - check each dc server individually.
++- replace GPLv3 with GPLv2 code for SRV record handling.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/dclist.c
++++ autofs-5.0.5/modules/dclist.c
+@@ -1,19 +1,10 @@
+ /*
+- * Copyright 2009 Ian Kent <raven@themaw.net>
+- * Copyright 2009 Red Hat, Inc.
+- *
+- * This module was apapted from code contained in the Samba distribution
+- * file source/libads/dns.c which contained the following copyright
+- * information:
+- *
+- * Unix SMB/CIFS implementation.
+- * DNS utility library
+- * Copyright (C) Gerald (Jerry) Carter           2006.
+- * Copyright (C) Jeremy Allison                  2007.
++ * Copyright 2011 Ian Kent <raven@themaw.net>
++ * Copyright 2011 Red Hat, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+- * the Free Software Foundation; either version 3 of the License, or
++ * the Free Software Foundation, either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+@@ -25,7 +16,9 @@
+  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+ 
++#include <sys/types.h>
+ #include <netinet/in.h>
++#include <arpa/inet.h>
+ #include <arpa/nameser.h>
+ #include <stdlib.h>
+ #include <string.h>
+@@ -39,80 +32,21 @@
+ #include "automount.h"
+ #include "dclist.h"
+ 
+-#define	MAX_DNS_PACKET_SIZE	0xffff
+-#define	MAX_DNS_NAME_LENGTH	MAXHOSTNAMELEN
+-/* The longest time we will cache dns srv records */
+-#define MAX_TTL			(60*60*1) /* 1 hours */
+-
+-#ifdef NS_HFIXEDSZ	/* Bind 8/9 interface */
+-#if !defined(C_IN)	/* AIX 5.3 already defines C_IN */
+-#  define C_IN		ns_c_in
+-#endif
+-#if !defined(T_A)	/* AIX 5.3 already defines T_A */
+-#  define T_A   	ns_t_a
+-#endif
+-
+-#  define T_SRV 	ns_t_srv
+-#if !defined(T_NS)	/* AIX 5.3 already defines T_NS */
+-#  define T_NS 		ns_t_ns
+-#endif
+-#else
+-#  ifdef HFIXEDSZ
+-#    define NS_HFIXEDSZ HFIXEDSZ
+-#  else
+-#    define NS_HFIXEDSZ sizeof(HEADER)
+-#  endif	/* HFIXEDSZ */
+-#  ifdef PACKETSZ
+-#    define NS_PACKETSZ	PACKETSZ
+-#  else	/* 512 is usually the default */
+-#    define NS_PACKETSZ	512
+-#  endif	/* PACKETSZ */
+-#  define T_SRV 	33
+-#endif
+-
+-#define SVAL(buf, pos) (*(const uint16_t *)((const char *)(buf) + (pos)))
+-#define IVAL(buf, pos) (*(const uint32_t *)((const char *)(buf) + (pos)))
+-
+-#if __BYTE_ORDER == __LITTLE_ENDIAN
+-#define SREV(x) ((((x)&0xFF)<<8) | (((x)>>8)&0xFF))
+-#define IREV(x) ((SREV(x)<<16) | (SREV((x)>>16)))
+-#else
+-#define SREV(x) (x)
+-#define IREV(x) (x)
+-#endif
+-
+-#define RSVAL(buf, pos) SREV(SVAL(buf, pos))
+-#define RIVAL(buf, pos) IREV(IVAL(buf, pos))
+-
+-#define QSORT_CAST	(int (*)(const void *, const void *))
+-
+-/* DNS query section in replies */
+-
+-struct dns_query {
+-	const char *hostname;
+-	uint16_t type;
+-	uint16_t in_class;
+-};
+-
+-/* DNS RR record in reply */
++#define MAX_TTL		(60*60) /* 1 hour */
+ 
+-struct dns_rr {
+-	const char *hostname;
+-	uint16_t type;
+-	uint16_t in_class;
+-	uint32_t ttl;
+-	uint16_t rdatalen;
+-	uint8_t *rdata;
++struct rr {
++	unsigned int type;
++	unsigned int class;
++	unsigned long ttl;
++	unsigned int len;
+ };
+ 
+-/* SRV records */
+-
+-struct dns_rr_srv {
+-	const char *hostname;
+-	uint16_t priority;
+-	uint16_t weight;
+-	uint16_t port;
+-	uint32_t ttl;
++struct srv_rr {
++	const char *name;
++	unsigned int priority;
++	unsigned int weight;
++	unsigned int port;
++	unsigned long ttl;
+ };
+ 
+ static pthread_mutex_t dclist_mutex = PTHREAD_MUTEX_INITIALIZER;
+@@ -133,374 +67,224 @@ static void dclist_mutex_unlock(void)
+ 	return;
+ }
+ 
+-static int dns_parse_query(unsigned int logopt,
+-			   uint8_t *start, uint8_t *end,
+-			   uint8_t **ptr, struct dns_query *q)
++static int do_srv_query(unsigned int logopt, char *name, u_char **packet)
+ {
+-	uint8_t *p = *ptr;
+-	char hostname[MAX_DNS_NAME_LENGTH];
+-	char buf[MAX_ERR_BUF];
+-	int namelen;
+-
+-	if (!start || !end || !q || !*ptr)
+-		return 0;
++	unsigned int len = PACKETSZ;
++	unsigned int last_len = len;
++	char ebuf[MAX_ERR_BUF];
++	u_char *buf;
++
++	while (1) {
++		buf = malloc(last_len);
++		if (!buf) {
++			char *estr = strerror_r(errno, ebuf, MAX_ERR_BUF);
++			error(logopt, "malloc: %s", estr);
++			return -1;
++		}
+ 
+-	memset(q, 0, sizeof(*q));
++		len = res_query(name, C_IN, T_SRV, buf, last_len);
++		if (len < 0) {
++			char *estr = strerror_r(errno, ebuf, MAX_ERR_BUF);
++			error(logopt, "Failed to resolve %s (%s)", name, estr);
++			free(buf);
++			return -1;
++		}
+ 
+-	/* See RFC 1035 for details. If this fails, then return. */
++		if (len == last_len) {
++			/* These shouldn't too large, bump by PACKETSZ only */
++			last_len += PACKETSZ;
++			free(buf);
++			continue;
++		}
+ 
+-	namelen = dn_expand(start, end, p, hostname, sizeof(hostname));
+-	if (namelen < 0) {
+-		error(logopt, "failed to expand query hostname");
+-		return 0;
++		break;
+ 	}
+ 
+-	p += namelen;
+-	q->hostname = strdup(hostname);
+-	if (!q) {
+-		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-		error(logopt, "strdup: %s", estr);
+-		return 0;
+-	}
++	*packet = buf;
+ 
+-	/* check that we have space remaining */
++	return len;
++}
+ 
+-	if (p + 4 > end) {
+-		error(logopt, "insufficient buffer space for result");
+-		free((void *) q->hostname);
+-		return 0;
+-	}
++static int get_name_len(u_char *buffer, u_char *start, u_char *end)
++{
++	char tmp[MAXDNAME];
++	return dn_expand(buffer, end, start, tmp, MAXDNAME);
++}
+ 
+-	q->type     = RSVAL(p, 0);
+-	q->in_class = RSVAL(p, 2);
+-	p += 4;
++static int get_data_offset(u_char *buffer,
++			   u_char *start, u_char *end,
++			   struct rr *rr)
++{
++	u_char *cp = start;
++	int name_len;
+ 
+-	*ptr = p;
++	name_len = get_name_len(buffer, start, end);
++	if (name_len < 0)
++		return -1;
++	cp += name_len;
+ 
+-	return 1;
++	GETSHORT(rr->type, cp);
++	GETSHORT(rr->class, cp);
++	GETLONG(rr->ttl, cp);
++	GETSHORT(rr->len, cp);
++
++	return (cp - start);
+ }
+ 
+-static int dns_parse_rr(unsigned int logopt,
+-			uint8_t *start, uint8_t *end,
+-			uint8_t **ptr, struct dns_rr *rr)
++static struct srv_rr *parse_srv_rr(unsigned int logopt,
++				   u_char *buffer, u_char *start, u_char *end,
++				   struct rr *rr, struct srv_rr *srv)
+ {
+-	uint8_t *p = *ptr;
+-	char hostname[MAX_DNS_NAME_LENGTH];
+-	char buf[MAX_ERR_BUF];
+-	int namelen;
+-
+-	if (!start || !end || !rr || !*ptr)
+-		return 0;
+-
+-	memset(rr, 0, sizeof(*rr));
++	u_char *cp = start;
++	char ebuf[MAX_ERR_BUF];
++	char tmp[MAXDNAME];
++	int len;
+ 
+-	/* pull the name from the answer */
++	GETSHORT(srv->priority, cp);
++	GETSHORT(srv->weight, cp);
++	GETSHORT(srv->port, cp);
++	srv->ttl = rr->ttl;
+ 
+-	namelen = dn_expand(start, end, p, hostname, sizeof(hostname));
+-	if (namelen < 0) {
+-		error(logopt, "failed to expand query hostname");
+-		return 0;
++	len = dn_expand(buffer, end, cp, tmp, MAXDNAME);
++	if (len < 0) {
++		error(logopt, "failed to expand name");
++		return NULL;
+ 	}
+-	p += namelen;
+-	rr->hostname = strdup(hostname);
+-	if (!rr->hostname) {
+-		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
++	srv->name = strdup(tmp);
++	if (!srv->name) {
++		char *estr = strerror_r(errno, ebuf, MAX_ERR_BUF);
+ 		error(logopt, "strdup: %s", estr);
+-		return 0;
+-	}
+-
+-	/* check that we have space remaining */
+-
+-	if (p + 10 > end) {
+-		error(logopt, "insufficient buffer space for result");
+-		free((void *) rr->hostname);
+-		return 0;
++		return NULL;
+ 	}
+ 
+-	/* pull some values and then skip onto the string */
+-
+-	rr->type     = RSVAL(p, 0);
+-	rr->in_class = RSVAL(p, 2);
+-	rr->ttl      = RIVAL(p, 4);
+-	rr->rdatalen = RSVAL(p, 8);
++	return srv;
++}
+ 
+-	p += 10;
++static int cmp(struct srv_rr *a, struct srv_rr *b)
++{
++	if (a->priority < b->priority)
++		return -1;
+ 
+-	/* sanity check the available space */
++	if (a->priority > b->priority)
++		return 1;
+ 
+-	if (p + rr->rdatalen > end) {
+-		error(logopt, "insufficient buffer space for data");
+-		free((void *) rr->hostname);
++	if (!a->weight || a->weight == b->weight)
+ 		return 0;
+-	}
+ 
+-	/* save a point to the rdata for this section */
+-
+-	rr->rdata = p;
+-	p += rr->rdatalen;
+-
+-	*ptr = p;
++	if (a->weight > b->weight)
++		return -1;
+ 
+ 	return 1;
+ }
+ 
+-static int dns_parse_rr_srv(unsigned int logopt,
+-			    uint8_t *start, uint8_t *end,
+-			    uint8_t **ptr, struct dns_rr_srv *srv)
+-{
+-	struct dns_rr rr;
+-	uint8_t *p;
+-	char dcname[MAX_DNS_NAME_LENGTH];
+-	char buf[MAX_ERR_BUF];
+-	int namelen;
+-
+-	if (!start || !end || !srv || !*ptr)
+-		return 0;
+-
+-	/* Parse the RR entry.  Coming out of the this, ptr is at the beginning
+-	   of the next record */
+-
+-	if (!dns_parse_rr(logopt, start, end, ptr, &rr)) {
+-		error(logopt, "Failed to parse RR record");
+-		return 0;
+-	}
++static void free_srv_rrs(struct srv_rr *dcs, unsigned int count)
++{
++	int i;
+ 
+-	if (rr.type != T_SRV) {
+-		error(logopt, "Bad answer type (%d)", rr.type);
+-		return 0;
++	for (i = 0; i < count; i++) {
++		if (dcs[i].name)
++			free((void *) dcs[i].name);
+ 	}
++	free(dcs);
++}
+ 
+-	p = rr.rdata;
++int get_srv_rrs(unsigned int logopt,
++		char *name, struct srv_rr **dcs, unsigned int *dcs_count)
++{
++	struct srv_rr *srvs;
++	unsigned int srv_num;
++	HEADER *header;
++	u_char *packet;
++	u_char *start;
++	u_char *end;
++	unsigned int count;
++	int i, len;
++	char ebuf[MAX_ERR_BUF];
+ 
+-	srv->priority = RSVAL(p, 0);
+-	srv->weight   = RSVAL(p, 2);
+-	srv->port     = RSVAL(p, 4);
+-	srv->ttl      = rr.ttl;
+-
+-	p += 6;
+-
+-	namelen = dn_expand(start, end, p, dcname, sizeof(dcname));
+-	if (namelen < 0) {
+-		error(logopt, "Failed to expand dcname");
++	len = do_srv_query(logopt, name, &packet);
++	if (len < 0)
+ 		return 0;
+-	}
+ 
+-	srv->hostname = strdup(dcname);
+-	if (!srv->hostname) {
+-		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-		error(logopt, "strdup: %s", estr);
+-		return 0;
+-	}
++	header = (HEADER *) packet;
++	start = packet + sizeof(HEADER);
++	end = packet + len;
+ 
+-	debug(logopt, "Parsed %s [%u, %u, %u]",
+-	      srv->hostname, srv->priority, srv->weight, srv->port);
++	srvs = NULL;
++	srv_num = 0;
+ 
+-	return 1;
+-}
+-
+-/*********************************************************************
+- Sort SRV record list based on weight and priority.  See RFC 2782.
+-*********************************************************************/
+-
+-static int dnssrvcmp(struct dns_rr_srv *a, struct dns_rr_srv *b)
+-{
+-	if (a->priority == b->priority) {
+-		/* randomize entries with an equal weight and priority */
+-		if (a->weight == b->weight)
+-			return 0;
+-
+-		/* higher weights should be sorted lower */
+-		if (a->weight > b->weight)
+-			return -1;
+-		else
+-			return 1;
++	/* Skip over question */
++	len = get_name_len(packet, start, end);
++	if (len < 0) {
++		error(logopt, "failed to get name length");
++		goto error_out;
+ 	}
+ 
+-	if (a->priority < b->priority)
+-		return -1;
++	start += len + QFIXEDSZ;
+ 
+-	return 1;
+-}
++	count = ntohs(header->ancount);
+ 
+-#define DNS_FAILED_WAITTIME          30
++	debug(logopt, "%d records returned in the answer section", count);
+ 
+-static int dns_send_req(unsigned int logopt,
+-			const char *name, int q_type, uint8_t **rbuf,
+-			int *resp_length)
+-{
+-	uint8_t *buffer = NULL;
+-	size_t buf_len = 0;
+-	int resp_len = NS_PACKETSZ;
+-	static time_t last_dns_check = 0;
+-	static unsigned int last_dns_status = 0;
+-	time_t now = time(NULL);
+-	char buf[MAX_ERR_BUF];
++	if (count <= 0) {
++		error(logopt, "no records found in answers section");
++		goto error_out;
++	}
+ 
+-	/* Try to prevent bursts of DNS lookups if the server is down */
++	srvs = malloc(sizeof(struct srv_rr) * count);
++	if (!srvs) {
++		char *estr = strerror_r(errno, ebuf, MAX_ERR_BUF);
++		error(logopt, "malloc: %s", estr);
++		goto error_out;
++	}
++	memset(srvs, 0, sizeof(struct srv_rr) * count);
+ 
+-	/* Protect against large clock changes */
++	srv_num = 0;
++	for (i = 0; i < count && (start < end); i++) {
++		unsigned int data_offset;
++		struct srv_rr srv;
++		struct srv_rr *psrv;
++		struct rr rr;
+ 
+-	if (last_dns_check > now)
+-		last_dns_check = 0;
++		memset(&rr, 0, sizeof(struct rr));
+ 
+-	/* IF we had a DNS timeout or a bad server and we are still
+-	   in the 30 second cache window, just return the previous
+-	   status and save the network timeout. */
+-
+-	if ((last_dns_status == ETIMEDOUT ||
+-	     last_dns_status == ECONNREFUSED) &&
+-	     ((last_dns_check + DNS_FAILED_WAITTIME) > now)) {
+-		char *estr = strerror_r(last_dns_status, buf, MAX_ERR_BUF);
+-		debug(logopt, "Returning cached status (%s)", estr);
+-		return last_dns_status;
+-	}
+-
+-	/* Send the Query */
+-	do {
+-		if (buffer)
+-			free(buffer);
+-
+-		buf_len = resp_len * sizeof(uint8_t);
+-
+-		if (buf_len) {
+-			buffer = malloc(buf_len);
+-			if (!buffer) {
+-				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-				error(logopt, "malloc: %s", estr);
+-				last_dns_status = ENOMEM;
+-				last_dns_check = time(NULL);
+-				return last_dns_status;
+-			}
++		data_offset = get_data_offset(packet, start, end, &rr);
++		if (data_offset <= 0) {
++			error(logopt, "failed to get start of data");
++			goto error_out;
+ 		}
++		start += data_offset;
+ 
+-		resp_len = res_query(name, C_IN, q_type, buffer, buf_len);
+-		if (resp_len < 0) {
+-			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-			error(logopt, "Failed to resolve %s (%s)", name, estr);
+-			free(buffer);
+-			last_dns_status = ENOENT;
+-			last_dns_check = time(NULL);
+-			return last_dns_status;
+-		}
+-
+-		/* On AIX, Solaris, and possibly some older glibc systems (e.g. SLES8)
+-		   truncated replies never give back a resp_len > buflen
+-		   which ends up causing DNS resolve failures on large tcp DNS replies */
+-
+-		if (buf_len == resp_len) {
+-			if (resp_len == MAX_DNS_PACKET_SIZE) {
+-				error(logopt,
+-				      "DNS reply too large when resolving %s",
+-				      name);
+-				free(buffer);
+-				last_dns_status = EMSGSIZE;
+-				last_dns_check = time(NULL);
+-				return last_dns_status;
+-			}
++		if (rr.type != T_SRV)
++			continue;
+ 
+-			resp_len = MIN(resp_len * 2, MAX_DNS_PACKET_SIZE);
++		psrv = parse_srv_rr(logopt, packet, start, end, &rr, &srv);
++		if (psrv) {
++			memcpy(&srvs[srv_num], psrv, sizeof(struct srv_rr));
++			srv_num++;
+ 		}
+-	} while (buf_len < resp_len && resp_len <= MAX_DNS_PACKET_SIZE);
+-
+-	*rbuf = buffer;
+-	*resp_length = resp_len;
+-
+-	last_dns_check = time(NULL);
+-	last_dns_status = 0;
+-
+-	return 0;
+-}
+-
+-static int dns_lookup_srv(unsigned int logopt, const char *name,
+-			  struct dns_rr_srv **dclist, int *numdcs)
+-{
+-	uint8_t *buffer = NULL;
+-	int resp_len = 0;
+-	struct dns_rr_srv *dcs = NULL;
+-	int query_count, answer_count;
+-	uint8_t *p = buffer;
+-	int rrnum;
+-	int idx = 0;
+-	char buf[MAX_ERR_BUF];
+-	int ret;
+-
+-	if (!name || !dclist)
+-		return -EINVAL;
+-
+-	/* Send the request.  May have to loop several times in case
+-	   of large replies */
+-
+-	ret = dns_send_req(logopt, name, T_SRV, &buffer, &resp_len);
+-	if (ret) {
+-		error(logopt, "Failed to send DNS query");
+-		return ret;
+-	}
+-	p = buffer;
+-
+-	/* For some insane reason, the ns_initparse() et. al. routines are only
+-	   available in libresolv.a, and not the shared lib.  Who knows why....
+-	   So we have to parse the DNS reply ourselves */
+-
+-	/* Pull the answer RR's count from the header.
+-	 * Use the NMB ordering macros */
+-
+-	query_count      = RSVAL(p, 4);
+-	answer_count     = RSVAL(p, 6);
+-
+-	debug(logopt,
+-	      "%d records returned in the answer section.",
+-	       answer_count);
+ 
+-	if (answer_count) {
+-		dcs = malloc(sizeof(struct dns_rr_srv) * answer_count);
+-		if (!dcs) {
+-			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+-			error(logopt, "malloc: %s", estr);
+-			free(buffer);
+-			return ENOMEM;
+-		}
++		start += rr.len;
+ 	}
++	free(packet);
+ 
+-	/* now skip the header */
+-
+-	p += NS_HFIXEDSZ;
+-
+-	/* parse the query section */
+-
+-	for (rrnum = 0; rrnum < query_count; rrnum++) {
+-		struct dns_query q;
+-
+-		ret = dns_parse_query(logopt, buffer, buffer+resp_len, &p, &q);
+-		if (!ret) {
+-			error(logopt,
+-			      "Failed to parse query record [%d]", rrnum);
+-			free(buffer);
+-			free(dcs);
+-			return EBADMSG;
+-		}
++	if (!srv_num) {
++		error(logopt, "no srv resource records found");
++		goto error_srvs;
+ 	}
+ 
+-	/* now we are at the answer section */
++	qsort(srvs, srv_num, sizeof(struct srv_rr),
++		(int (*)(const void *, const void *)) cmp);
+ 
+-	for (rrnum = 0; rrnum < answer_count; rrnum++) {
+-		ret = dns_parse_rr_srv(logopt,
+-				       buffer, buffer+resp_len,
+-				       &p, &dcs[rrnum]);
+-		if (!ret) {
+-			error(logopt,
+-			      "Failed to parse answer record [%d]", rrnum);
+-			free(buffer);
+-			free(dcs);
+-			return EBADMSG;
+-		}
+-	}
+-	idx = rrnum;
++	*dcs = srvs;
++	*dcs_count = srv_num;
+ 
+-	qsort(dcs, idx, sizeof(struct dns_rr_srv), QSORT_CAST dnssrvcmp);
+-
+-	*dclist = dcs;
+-	*numdcs = idx;
++	return 1;
+ 
++error_out:
++	free(packet);
++error_srvs:
++	if (srvs)
++		free_srv_rrs(srvs, srv_num);
+ 	return 0;
+ }
+ 
+@@ -553,14 +337,14 @@ void free_dclist(struct dclist *dclist)
+ static char *getdnsdomainname(unsigned int logopt)
+ {
+ 	struct addrinfo hints, *ni;
+-	char name[MAX_DNS_NAME_LENGTH + 1];
++	char name[MAXDNAME + 1];
+ 	char buf[MAX_ERR_BUF];
+ 	char *dnsdomain = NULL;
+ 	char *ptr;
+ 	int ret;
+ 
+ 	memset(name, 0, sizeof(name));
+-	if (gethostname(name, MAX_DNS_NAME_LENGTH) == -1) {
++	if (gethostname(name, MAXDNAME) == -1) {
+ 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+ 		error(logopt, "gethostname: %s", estr);
+ 		return NULL;
+@@ -593,14 +377,12 @@ struct dclist *get_dc_list(unsigned int 
+ {
+ 	LDAPURLDesc *ludlist = NULL;
+ 	LDAPURLDesc **ludp;
+-	struct dns_rr_srv *dcs;
+ 	unsigned int min_ttl = MAX_TTL;
+ 	struct dclist *dclist = NULL;;
+ 	char buf[MAX_ERR_BUF];
+ 	char *dn_uri, *esc_uri;
+ 	char *domain;
+ 	char *list;
+-	int numdcs;
+ 	int ret;
+ 
+ 	if (strcmp(uri, "ldap:///") && strcmp(uri, "ldaps:///")) {
+@@ -679,6 +461,8 @@ struct dclist *get_dc_list(unsigned int 
+ 	list = NULL;
+ 	for (ludp = &ludlist; *ludp != NULL;) {
+ 		LDAPURLDesc *lud = *ludp;
++		struct srv_rr *dcs = NULL;
++		unsigned int numdcs = 0;
+ 		size_t req_len, len;
+ 		char *request = NULL;
+ 		char *tmp;
+@@ -716,7 +500,7 @@ struct dclist *get_dc_list(unsigned int 
+ 		}
+ 
+ 		dclist_mutex_lock();
+-		if (dns_lookup_srv(logopt, request, &dcs, &numdcs)) {
++		if (!get_srv_rrs(logopt, request, &dcs, &numdcs)) {
+ 			error(logopt,
+ 			      "DNS SRV query failed for domain %s", domain);
+ 			dclist_mutex_unlock();
+@@ -733,7 +517,7 @@ struct dclist *get_dc_list(unsigned int 
+ 		for (i = 0; i < numdcs; i++) {
+ 			if (dcs[i].ttl > 0 && dcs[i].ttl < min_ttl)
+ 				min_ttl = dcs[i].ttl;
+-			len += strlen(dcs[i].hostname);
++			len += strlen(dcs[i].name);
+ 			if (dcs[i].port > 0)
+ 				len += sizeof(":65535");
+ 		}
+@@ -742,6 +526,8 @@ struct dclist *get_dc_list(unsigned int 
+ 		if (!tmp) {
+ 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+ 			error(logopt, "realloc: %s", estr);
++			if (dcs)
++				free_srv_rrs(dcs, numdcs);
+ 			goto out_error;
+ 		}
+ 
+@@ -755,13 +541,15 @@ struct dclist *get_dc_list(unsigned int 
+ 				strcat(tmp, " ");
+ 			strcat(tmp, lud->lud_scheme);
+ 			strcat(tmp, "://");
+-			strcat(tmp, dcs[i].hostname);
++			strcat(tmp, dcs[i].name);
+ 			if (dcs[i].port > 0) {
+ 				char port[7];
+ 				ret = snprintf(port, 7, ":%d", dcs[i].port);
+ 				if (ret > 6) {
+ 					error(logopt,
+ 					      "invalid port: %u", dcs[i].port);
++					if (dcs)
++						free_srv_rrs(dcs, numdcs);
+ 					goto out_error;
+ 				}
+ 				strcat(tmp, port);
+@@ -771,10 +559,14 @@ struct dclist *get_dc_list(unsigned int 
+ 
+ 		*ludp = lud->lud_next;
+ 		ber_memfree(domain);
++		free_srv_rrs(dcs, numdcs);
+ 	}
+ 
+ 	ldap_free_urldesc(ludlist);
+ 
++	if (!list)
++		goto out_error;
++
+ 	dclist->expire = time(NULL) + min_ttl;
+ 	dclist->uri = list;
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-reset-negative-status-on-cache-prune.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-reset-negative-status-on-cache-prune.patch
@@ -0,0 +1,38 @@
+autofs-5.0.5 - reset negative status on cache prune
+
+From: Ian Kent <raven@themaw.net>
+
+When we prune the cache we should reset time of last fail for valid map
+entries so that, on a HUP signal, we force an entry update on next mount
+attempt.
+---
+
+ CHANGELOG       |    1 +
+ daemon/lookup.c |    5 +++++
+ 2 files changed, 6 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -56,6 +56,7 @@
+ - fix paged ldap map read.
+ - add base64 password encode.
+ - add option to dump configured automount maps.
++- reset negative status on cache prune.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/lookup.c
++++ autofs-5.0.5/daemon/lookup.c
+@@ -1025,6 +1025,11 @@ void lookup_prune_one_cache(struct autof
+ 		char *key = NULL, *next_key = NULL;
+ 
+ 		if (me->age >= age) {
++			/*
++			 * Reset time of last fail for valid map entries to
++			 * force entry update and subsequent mount retry.
++			 */
++			me->status = 0;
+ 			me = cache_enumerate(mc, me);
+ 			continue;
+ 		}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-special-case-cifs-escapes.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-special-case-cifs-escapes.patch
@@ -0,0 +1,99 @@
+autofs-5.0.5 - special case cifs escapes
+
+From: Ian Kent <raven@themaw.net>
+
+Since "\" is a valid seperator for cifs shares it can't be used to escape
+characters in the share name passed to mount.cifs. So we have no choice
+but to require that the seperator we use is "/" and de-quote the string
+before sending it to mount.cifs.
+---
+
+ CHANGELOG               |    1 +
+ modules/mount_generic.c |   36 ++++++++++++++++++++++++++++++------
+ 2 files changed, 31 insertions(+), 6 deletions(-)
+
+
+diff --git a/CHANGELOG b/CHANGELOG
+index fadb229..671c979 100644
+--- a/CHANGELOG
++++ b/CHANGELOG
+@@ -3,6 +3,7 @@
+ - fix included map read fail handling.
+ - refactor ldap sasl bind handling.
+ - add mount wait timeout parameter.
++- special case cifs escapes.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+diff --git a/modules/mount_generic.c b/modules/mount_generic.c
+index 8edad8b..da85d1a 100644
+--- a/modules/mount_generic.c
++++ b/modules/mount_generic.c
+@@ -39,6 +39,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
+ {
+ 	char fullpath[PATH_MAX];
+ 	char buf[MAX_ERR_BUF];
++	char *loc;
+ 	int err;
+ 	int len, status, existed = 1;
+ 
+@@ -74,22 +75,44 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
+ 	if (!status)
+ 		existed = 0;
+ 
++	/*
++	 * Special case quoting for cifs share names.
++	 *
++	 * Since "\" is a valid seperator for cifs shares it can't be
++	 * used to escape characters in the share name passed to
++	 * mount.cifs. So we have no choice but to require that the
++	 * seperator we use is "/" and de-quote the string before
++	 * sending it to mount.cifs.
++	 */
++	loc = NULL;
++	if (strcmp(fstype, "cifs"))
++		loc = strdup(what);
++	else
++		loc = dequote(what, strlen(what), ap->logopt);
++	if (!loc) {
++		error(ap->logopt,
++		      MODPREFIX "failed to alloc buffer for mount location");
++		return 1;
++	}
++
+ 	if (options && options[0]) {
+ 		debug(ap->logopt,
+ 		      MODPREFIX "calling mount -t %s " SLOPPY "-o %s %s %s",
+-		      fstype, options, what, fullpath);
++		      fstype, options, loc, fullpath);
+ 
+ 		err = spawn_mount(ap->logopt, "-t", fstype,
+-			     SLOPPYOPT "-o", options, what, fullpath, NULL);
++			     SLOPPYOPT "-o", options, loc, fullpath, NULL);
+ 	} else {
+ 		debug(ap->logopt, MODPREFIX "calling mount -t %s %s %s",
+-		      fstype, what, fullpath);
+-		err = spawn_mount(ap->logopt, "-t", fstype, what, fullpath, NULL);
++		      fstype, loc, fullpath);
++		err = spawn_mount(ap->logopt, "-t", fstype, loc, fullpath, NULL);
+ 	}
+ 
+ 	if (err) {
+ 		info(ap->logopt, MODPREFIX "failed to mount %s (type %s) on %s",
+-		     what, fstype, fullpath);
++		     loc, fstype, fullpath);
++
++		free(loc);
+ 
+ 		if (ap->type != LKP_INDIRECT)
+ 			return 1;
+@@ -100,7 +123,8 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
+ 		return 1;
+ 	} else {
+ 		info(ap->logopt, MODPREFIX "mounted %s type %s on %s",
+-		    what, fstype, fullpath);
++		     loc, fstype, fullpath);
++		free(loc);
+ 		return 0;
+ 	}
+ }
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-use-weight-only-for-server-selection.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-use-weight-only-for-server-selection.patch
@@ -0,0 +1,568 @@
+autofs-5.0.5 - use weight only for server selection
+
+From: Ian Kent <raven@themaw.net>
+
+When using weighted server names in map entries the server response
+time is also taken into consideration when selecting a server for
+the target of the mount. In some cases people need to be able to
+rely on selection strictly by weight. We add pseudo option
+"--use-weight-only" that can be used in with master map entries
+or with individual map entries to provide for this. For individual
+map entries the option "no-use-weight-only" can also be used to
+override the master map option.
+---
+
+ CHANGELOG            |    1 
+ daemon/automount.c   |    8 ++---
+ include/automount.h  |    3 ++
+ include/replicated.h |    3 +-
+ lib/master_parse.y   |   12 ++++++--
+ lib/master_tok.l     |    1 
+ man/auto.master.5.in |    6 ++++
+ man/autofs.5         |    7 ++++
+ modules/mount_nfs.c  |   15 ++++++----
+ modules/parse_sun.c  |   36 +++++++++++++++++++++---
+ modules/replicated.c |   76 ++++++++++++++++++++++++++++++---------------------
+ 11 files changed, 120 insertions(+), 48 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -39,6 +39,7 @@
+ - always read file maps mount lookup map read fix.
+ - add external bind method.
+ - add simple bind authentication.
++- use weight only for server selection.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/daemon/automount.c
++++ autofs-5.0.5/daemon/automount.c
+@@ -57,8 +57,8 @@ const char *fifodir = AUTOFS_FIFO_DIR "/
+ const char *global_options;		/* Global option, from command line */
+ 
+ static char *pid_file = NULL;		/* File in which to keep pid */
+-unsigned int global_random_selection;	/* use random policy when selecting
+-					 * which multi-mount host to mount */
++unsigned int global_selection_options;
++
+ long global_negative_timeout = -1;
+ int do_force_unlink = 0;		/* Forceably unlink mount tree at startup */
+ 
+@@ -1852,7 +1852,7 @@ int main(int argc, char *argv[])
+ 	timeout = defaults_get_timeout();
+ 	ghost = defaults_get_browse_mode();
+ 	logging = defaults_get_logging();
+-	global_random_selection = 0;
++	global_selection_options = 0;
+ 	global_options = NULL;
+ 	have_global_options = 0;
+ 	foreground = 0;
+@@ -1894,7 +1894,7 @@ int main(int argc, char *argv[])
+ 			exit(0);
+ 
+ 		case 'r':
+-			global_random_selection = 1;
++			global_selection_options |= MOUNT_FLAG_RANDOM_SELECT;
+ 			break;
+ 
+ 		case 'n':
+--- autofs-5.0.5.orig/include/automount.h
++++ autofs-5.0.5/include/automount.h
+@@ -402,6 +402,9 @@ struct kernel_mod_version {
+ /* Mount being re-mounted */
+ #define MOUNT_FLAG_REMOUNT		0x0008
+ 
++/* Use server weight only for selection */
++#define MOUNT_FLAG_USE_WEIGHT_ONLY	0x0010
++
+ struct autofs_point {
+ 	pthread_t thid;
+ 	char *path;			/* Mount point name */
+--- autofs-5.0.5.orig/include/replicated.h
++++ autofs-5.0.5/include/replicated.h
+@@ -56,6 +56,7 @@ struct host {
+ 	size_t addr_len;
+ 	char *path;
+ 	unsigned int version;
++	unsigned int options;
+ 	unsigned int proximity;
+ 	unsigned int weight;
+ 	unsigned long cost;
+@@ -65,7 +66,7 @@ struct host {
+ void seed_random(void);
+ void free_host_list(struct host **);
+ int parse_location(unsigned, struct host **, const char *, unsigned int);
+-int prune_host_list(unsigned, struct host **, unsigned int, const char *, unsigned int);
++int prune_host_list(unsigned, struct host **, unsigned int, const char *);
+ void dump_host_list(struct host *);
+ 
+ #endif
+--- autofs-5.0.5.orig/lib/master_parse.y
++++ autofs-5.0.5/lib/master_parse.y
+@@ -58,8 +58,9 @@ static char *format;
+ static long timeout;
+ static long negative_timeout;
+ static unsigned ghost;
+-extern unsigned global_random_selection;
++extern unsigned global_selection_options;
+ static unsigned random_selection;
++static unsigned use_weight;
+ static char **tmp_argv;
+ static int tmp_argc;
+ static char **local_argv;
+@@ -98,7 +99,7 @@ static int master_fprintf(FILE *, char *
+ %token COMMENT
+ %token MAP
+ %token OPT_TIMEOUT OPT_NTIMEOUT OPT_NOGHOST OPT_GHOST OPT_VERBOSE
+-%token OPT_DEBUG OPT_RANDOM
++%token OPT_DEBUG OPT_RANDOM OPT_USE_WEIGHT
+ %token COLON COMMA NL DDASH
+ %type <strtype> map
+ %type <strtype> options
+@@ -181,6 +182,7 @@ line:
+ 	| PATH OPTION { master_notify($2); YYABORT; }
+ 	| PATH NILL { master_notify($2); YYABORT; }
+ 	| PATH OPT_RANDOM { master_notify($1); YYABORT; }
++	| PATH OPT_USE_WEIGHT { master_notify($1); YYABORT; }
+ 	| PATH OPT_DEBUG { master_notify($1); YYABORT; }
+ 	| PATH OPT_TIMEOUT { master_notify($1); YYABORT; }
+ 	| PATH OPT_GHOST { master_notify($1); YYABORT; }
+@@ -558,6 +560,7 @@ daemon_option: OPT_TIMEOUT NUMBER { time
+ 	| OPT_VERBOSE	{ verbose = 1; }
+ 	| OPT_DEBUG	{ debug = 1; }
+ 	| OPT_RANDOM	{ random_selection = 1; }
++	| OPT_USE_WEIGHT { use_weight = 1; }
+ 	;
+ 
+ mount_option: OPTION
+@@ -622,7 +625,8 @@ static void local_init_vars(void)
+ 	timeout = -1;
+ 	negative_timeout = 0;
+ 	ghost = defaults_get_browse_mode();
+-	random_selection = global_random_selection;
++	random_selection = global_selection_options & MOUNT_FLAG_RANDOM_SELECT;
++	use_weight = 0;
+ 	tmp_argv = NULL;
+ 	tmp_argc = 0;
+ 	local_argv = NULL;
+@@ -808,6 +812,8 @@ int master_parse_entry(const char *buffe
+ 	}
+ 	if (random_selection)
+ 		entry->ap->flags |= MOUNT_FLAG_RANDOM_SELECT;
++	if (use_weight)
++		entry->ap->flags |= MOUNT_FLAG_USE_WEIGHT_ONLY;
+ 	if (negative_timeout)
+ 		entry->ap->negative_timeout = negative_timeout;
+ 
+--- autofs-5.0.5.orig/lib/master_tok.l
++++ autofs-5.0.5/lib/master_tok.l
+@@ -363,6 +363,7 @@ OPTNTOUT	(-n{OPTWS}|-n{OPTWS}={OPTWS}|--
+ 	-g|--ghost|-?browse	{ return(OPT_GHOST); }
+ 	-v|--verbose		{ return(OPT_VERBOSE); }
+ 	-d|--debug		{ return(OPT_DEBUG); }
++	-w|--use-weight-only	{ return(OPT_USE_WEIGHT); }
+ 	-r|--random-multimount-selection { return(OPT_RANDOM); }
+ 
+ 	{OPTWS}","{OPTWS}	{ return(COMMA); }
+--- autofs-5.0.5.orig/man/auto.master.5.in
++++ autofs-5.0.5/man/auto.master.5.in
+@@ -153,6 +153,12 @@ list of replicated servers. This option 
+ only, overriding the global setting that may be specified on the
+ command line.
+ .TP
++.I "\-w, \-\-use-weight-only"
++Use only specified weights for server selection where more than one
++server is specified in the map entry. If no server weights are given
++then each available server will be tried in the order listed, within
++proximity.
++.TP
+ .I "\-n, \-\-negative\-timeout <seconds>"
+ Set the timeout for caching failed key lookups. This option can be
+ used to override the global default given either on the command line
+--- autofs-5.0.5.orig/man/autofs.5
++++ autofs-5.0.5/man/autofs.5
+@@ -49,6 +49,13 @@ is used to treat errors when mounting fi
+ multiple file systems should be mounted (`multi-mounts'). If this option
+ is given, no file system is mounted at all if at least one file system
+ can't be mounted.
++.I -use-weight-only
++is used to make the weight the sole factor in selecting a server when multiple
++servers are present in a map entry.
++and
++.I -no-use-weight-only
++can be used to negate the option if it is present in the master map entry
++for the map but is not wanted for the given mount.
+ 
+ .SS location
+ The location specifies from where the file system is to be mounted.  In the
+--- autofs-5.0.5.orig/modules/mount_nfs.c
++++ autofs-5.0.5/modules/mount_nfs.c
+@@ -63,7 +63,8 @@ int mount_mount(struct autofs_point *ap,
+ 	struct host *this, *hosts = NULL;
+ 	unsigned int mount_default_proto, vers;
+ 	char *nfsoptions = NULL;
+-	unsigned int random_selection = ap->flags & MOUNT_FLAG_RANDOM_SELECT;
++	unsigned int flags = ap->flags &
++			(MOUNT_FLAG_RANDOM_SELECT | MOUNT_FLAG_USE_WEIGHT_ONLY);
+ 	int len, status, err, existed = 1;
+ 	int nosymlink = 0;
+ 	int ro = 0;            /* Set if mount bind should be read-only */
+@@ -112,9 +113,13 @@ int mount_mount(struct autofs_point *ap,
+ 			while (*comma == ' ' || *comma == '\t')
+ 				end--;
+ 
+-			if (strncmp("nosymlink", cp, end - cp + 1) == 0)
++			if (strncmp("nosymlink", cp, end - cp + 1) == 0) {
+ 				nosymlink = 1;
+-			else {
++			} else if (strncmp("no-use-weight-only", cp, end - cp + 1) == 0) {
++				flags &= ~MOUNT_FLAG_USE_WEIGHT_ONLY;
++			} else if (strncmp("use-weight-only", cp, end - cp + 1) == 0) {
++				flags |= MOUNT_FLAG_USE_WEIGHT_ONLY;
++			} else {
+ 				/* Check for options that also make sense
+ 				   with bind mounts */
+ 				if (strncmp("ro", cp, end - cp + 1) == 0)
+@@ -137,11 +142,11 @@ int mount_mount(struct autofs_point *ap,
+ 	else if (mount_default_proto == 4)
+ 		vers = vers | NFS4_VERS_MASK;
+ 
+-	if (!parse_location(ap->logopt, &hosts, what, random_selection)) {
++	if (!parse_location(ap->logopt, &hosts, what, flags)) {
+ 		info(ap->logopt, MODPREFIX "no hosts available");
+ 		return 1;
+ 	}
+-	prune_host_list(ap->logopt, &hosts, vers, nfsoptions, random_selection);
++	prune_host_list(ap->logopt, &hosts, vers, nfsoptions);
+ 
+ 	if (!hosts) {
+ 		info(ap->logopt, MODPREFIX "no hosts available");
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -529,6 +529,7 @@ static int sun_mount(struct autofs_point
+ {
+ 	char *fstype = "nfs";	/* Default filesystem type */
+ 	int nonstrict = 1;
++	int use_weight_only = ap->flags & MOUNT_FLAG_USE_WEIGHT_ONLY;
+ 	int rv, cur_state;
+ 	char *mountpoint;
+ 	char *what;
+@@ -575,6 +576,10 @@ static int sun_mount(struct autofs_point
+ 					memcpy(np, cp, comma - cp + 1);
+ 					np += comma - cp + 1;
+ 				}
++			} else if (strncmp("no-use-weight-only", cp, 18) == 0) {
++				use_weight_only = -1;
++			} else if (strncmp("use-weight-only", cp, 15) == 0) {
++				use_weight_only = MOUNT_FLAG_USE_WEIGHT_ONLY;
+ 			} else if (strncmp("bg", cp, 2) == 0 ||
+ 				   strncmp("nofg", cp, 4) == 0) {
+ 				continue;
+@@ -593,11 +598,10 @@ static int sun_mount(struct autofs_point
+ 		options = noptions;
+ 	}
+ 
+-
+ 	if (!strcmp(fstype, "autofs") && ctxt->macros) {
+ 		char *noptions = NULL;
+ 
+-		if (!options) {
++		if (!options || *options == '\0') {
+ 			noptions = alloca(strlen(ctxt->macros) + 1);
+ 			*noptions = '\0';
+ 		} else {
+@@ -610,7 +614,7 @@ static int sun_mount(struct autofs_point
+ 			}
+ 		}
+ 
+-		if (noptions) {
++		if (noptions && *noptions != '\0') {
+ 			strcat(noptions, ctxt->macros);
+ 			options = noptions;
+ 		} else {
+@@ -624,7 +628,7 @@ static int sun_mount(struct autofs_point
+ 
+ 	type = ap->entry->maps->type;
+ 	if (type && !strcmp(type, "hosts")) {
+-		if (options) {
++		if (options && *options != '\0') {
+ 			int len = strlen(options);
+ 			int suid = strstr(options, "suid") ? 0 : 7;
+ 			int dev = strstr(options, "dev") ? 0 : 6;
+@@ -669,6 +673,30 @@ static int sun_mount(struct autofs_point
+ 		memcpy(what, loc, loclen);
+ 		what[loclen] = '\0';
+ 
++		/* Add back "[no-]use-weight-only" for NFS mounts only */
++		if (use_weight_only) {
++			char *tmp;
++			int len;
++
++			if (options && *options != '\0') {
++				len = strlen(options) + 19;
++				tmp = alloca(len);
++				strcpy(tmp, options);
++				strcat(tmp, ",");
++				if (use_weight_only == MOUNT_FLAG_USE_WEIGHT_ONLY)
++					strcat(tmp, "use-weight-only");
++				else
++					strcat(tmp, "no-use-weight-only");
++			} else {
++				tmp = alloca(19);
++				if (use_weight_only == MOUNT_FLAG_USE_WEIGHT_ONLY)
++					strcpy(tmp, "use-weight-only");
++				else
++					strcpy(tmp, "no-use-weight-only");
++			}
++			options = tmp;
++		}
++
+ 		debug(ap->logopt, MODPREFIX
+ 		      "mounting root %s, mountpoint %s, "
+ 		      "what %s, fstype %s, options %s",
+--- autofs-5.0.5.orig/modules/replicated.c
++++ autofs-5.0.5/modules/replicated.c
+@@ -351,7 +351,8 @@ static unsigned int get_proximity(struct
+ 
+ static struct host *new_host(const char *name,
+ 			     struct sockaddr *addr, size_t addr_len,
+-			     unsigned int proximity, unsigned int weight)
++			     unsigned int proximity, unsigned int weight,
++			     unsigned int options)
+ {
+ 	struct host *new;
+ 	struct sockaddr *tmp2;
+@@ -385,6 +386,7 @@ static struct host *new_host(const char 
+ 	new->addr = tmp2;
+ 	new->proximity = proximity;
+ 	new->weight = weight;
++	new->options = options;
+ 
+ 	return new;
+ }
+@@ -519,9 +521,11 @@ static unsigned short get_port_option(co
+ static unsigned int get_nfs_info(unsigned logopt, struct host *host,
+ 			 struct conn_info *pm_info, struct conn_info *rpc_info,
+ 			 const char *proto, unsigned int version,
+-			 const char *options, unsigned int random_selection)
++			 const char *options)
+ {
+ 	char *have_port_opt = options ? strstr(options, "port=") : NULL;
++	unsigned int random_selection = host->options & MOUNT_FLAG_RANDOM_SELECT;
++	unsigned int use_weight_only = host->options & MOUNT_FLAG_USE_WEIGHT_ONLY;
+ 	struct pmap parms;
+ 	struct timeval start, end;
+ 	struct timezone tz;
+@@ -675,7 +679,10 @@ done_ver:
+ 		 * Average response time to 7 significant places as
+ 		 * integral type.
+ 		 */
+-		host->cost = (unsigned long) ((taken * 1000000) / count);
++		if (use_weight_only)
++			host->cost = 1;
++		else
++			host->cost = (unsigned long) ((taken * 1000000) / count);
+ 
+ 		/* Allow for user bias */
+ 		if (host->weight)
+@@ -689,8 +696,7 @@ done_ver:
+ }
+ 
+ static int get_vers_and_cost(unsigned logopt, struct host *host,
+-			     unsigned int version, const char *options,
+-			     unsigned int random_selection)
++			     unsigned int version, const char *options)
+ {
+ 	struct conn_info pm_info, rpc_info;
+ 	time_t timeout = RPC_TIMEOUT;
+@@ -717,8 +723,7 @@ static int get_vers_and_cost(unsigned lo
+ 
+ 	if (version & UDP_REQUESTED) {
+ 		supported = get_nfs_info(logopt, host,
+-					&pm_info, &rpc_info, "udp", vers,
+-					options, random_selection);
++				   &pm_info, &rpc_info, "udp", vers, options);
+ 		if (supported) {
+ 			ret = 1;
+ 			host->version |= (supported << 8);
+@@ -727,8 +732,7 @@ static int get_vers_and_cost(unsigned lo
+ 
+ 	if (version & TCP_REQUESTED) {
+ 		supported = get_nfs_info(logopt, host,
+-					 &pm_info, &rpc_info, "tcp", vers,
+-					 options, random_selection);
++				   &pm_info, &rpc_info, "tcp", vers, options);
+ 		if (supported) {
+ 			ret = 1;
+ 			host->version |= supported;
+@@ -739,10 +743,11 @@ static int get_vers_and_cost(unsigned lo
+ }
+ 
+ static int get_supported_ver_and_cost(unsigned logopt, struct host *host,
+-				      unsigned int version, const char *options,
+-				      unsigned int random_selection)
++				      unsigned int version, const char *options)
+ {
+ 	char *have_port_opt = options ? strstr(options, "port=") : NULL;
++	unsigned int random_selection = host->options & MOUNT_FLAG_RANDOM_SELECT;
++	unsigned int use_weight_only = host->options & MOUNT_FLAG_USE_WEIGHT_ONLY;
+ 	struct conn_info pm_info, rpc_info;
+ 	struct pmap parms;
+ 	const char *proto;
+@@ -855,7 +860,10 @@ done:
+ 
+ 	if (status) {
+ 		/* Response time to 7 significant places as integral type. */
+-		host->cost = (unsigned long) (taken * 1000000);
++		if (use_weight_only)
++			host->cost = 1;
++		else
++			host->cost = (unsigned long) (taken * 1000000);
+ 
+ 		/* Allow for user bias */
+ 		if (host->weight)
+@@ -870,8 +878,7 @@ done:
+ }
+ 
+ int prune_host_list(unsigned logopt, struct host **list,
+-		    unsigned int vers, const char *options,
+-		    unsigned int random_selection)
++		    unsigned int vers, const char *options)
+ {
+ 	struct host *this, *last, *first;
+ 	struct host *new = NULL;
+@@ -892,6 +899,7 @@ int prune_host_list(unsigned logopt, str
+ 	this = first;
+ 	while (this && this->proximity == PROXIMITY_LOCAL)
+ 		this = this->next;
++	first = this;
+ 
+ 	/*
+ 	 * Check for either a list containing only proximity local hosts
+@@ -903,8 +911,6 @@ int prune_host_list(unsigned logopt, str
+ 		return 1;
+ 
+ 	proximity = this->proximity;
+-	first = this;
+-	this = first;
+ 	while (this) {
+ 		struct host *next = this->next;
+ 
+@@ -912,8 +918,7 @@ int prune_host_list(unsigned logopt, str
+ 			break;
+ 
+ 		if (this->name) {
+-			status = get_vers_and_cost(logopt, this, vers,
+-						   options, random_selection);
++			status = get_vers_and_cost(logopt, this, vers, options);
+ 			if (!status) {
+ 				if (this == first) {
+ 					first = next;
+@@ -1022,8 +1027,7 @@ int prune_host_list(unsigned logopt, str
+ 			add_host(&new, this);
+ 		} else {
+ 			status = get_supported_ver_and_cost(logopt, this,
+-						selected_version, options,
+-						random_selection);
++						selected_version, options);
+ 			if (status) {
+ 				this->version = selected_version;
+ 				remove_host(list, this);
+@@ -1041,8 +1045,7 @@ int prune_host_list(unsigned logopt, str
+ 
+ static int add_new_host(struct host **list,
+ 			const char *host, unsigned int weight,
+-			struct addrinfo *host_addr,
+-			unsigned int random_selection)
++			struct addrinfo *host_addr, unsigned int options)
+ {
+ 	struct host *new;
+ 	unsigned int prx;
+@@ -1054,10 +1057,21 @@ static int add_new_host(struct host **li
+ 	 * We can't use PROXIMITY_LOCAL or we won't perform an RPC ping
+ 	 * to remove hosts that may be down.
+ 	 */
+-	if (random_selection)
++	if (options & MOUNT_FLAG_RANDOM_SELECT)
+ 		prx = PROXIMITY_SUBNET;
+-	else
++	else {
+ 		prx = get_proximity(host_addr->ai_addr);
++		/*
++		 * If we want the weight to be the determining factor
++		 * when selecting a host then all hosts must have the
++		 * same proximity. However, if this is the local machine
++		 * it should always be used since it is certainly available.
++		 */
++		if (prx != PROXIMITY_LOCAL &&
++		   (options & MOUNT_FLAG_USE_WEIGHT_ONLY))
++			prx = PROXIMITY_SUBNET;
++	}
++
+ 	/*
+ 	 * If we tried to add an IPv6 address and we don't have IPv6
+ 	 * support return success in the hope of getting an IPv4
+@@ -1069,7 +1083,7 @@ static int add_new_host(struct host **li
+ 		return 0;
+ 
+ 	addr_len = sizeof(struct sockaddr);
+-	new = new_host(host, host_addr->ai_addr, addr_len, prx, weight);
++	new = new_host(host, host_addr->ai_addr, addr_len, prx, weight, options);
+ 	if (!new)
+ 		return 0;
+ 
+@@ -1082,7 +1096,7 @@ static int add_new_host(struct host **li
+ }
+ 
+ static int add_host_addrs(struct host **list, const char *host,
+-			  unsigned int weight, unsigned int random_selection)
++			  unsigned int weight, unsigned int options)
+ {
+ 	struct addrinfo hints, *ni, *this;
+ 	int ret;
+@@ -1098,7 +1112,7 @@ static int add_host_addrs(struct host **
+ 
+ 	this = ni;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this, random_selection);
++		ret = add_new_host(list, host, weight, this, options);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
+@@ -1121,7 +1135,7 @@ try_name:
+ 
+ 	this = ni;
+ 	while (this) {
+-		ret = add_new_host(list, host, weight, this, random_selection);
++		ret = add_new_host(list, host, weight, this, options);
+ 		if (!ret)
+ 			break;
+ 		this = this->ai_next;
+@@ -1209,7 +1223,7 @@ static char *seek_delim(const char *s)
+ }
+ 
+ int parse_location(unsigned logopt, struct host **hosts,
+-		   const char *list, unsigned int random_selection)
++		   const char *list, unsigned int options)
+ {
+ 	char *str, *p, *delim;
+ 	unsigned int empty = 1;
+@@ -1264,7 +1278,7 @@ int parse_location(unsigned logopt, stru
+ 				}
+ 
+ 				if (p != delim) {
+-					if (!add_host_addrs(hosts, p, weight, random_selection)) {
++					if (!add_host_addrs(hosts, p, weight, options)) {
+ 						if (empty) {
+ 							p = next;
+ 							continue;
+@@ -1286,7 +1300,7 @@ int parse_location(unsigned logopt, stru
+ 				*delim = '\0';
+ 				next = delim + 1;
+ 
+-				if (!add_host_addrs(hosts, p, weight, random_selection)) {
++				if (!add_host_addrs(hosts, p, weight, options)) {
+ 					p = next;
+ 					continue;
+ 				}
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-wait-for-master-source-mutex.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.5-wait-for-master-source-mutex.patch
@@ -0,0 +1,43 @@
+autofs-5.0.5 - wait for master source mutex
+
+From: Ian Kent <raven@themaw.net>
+
+Occasionally we might not be able to get the master source write
+lock when a read lock is held. We can wait a little while to see
+if it gets released without causing a problem.
+---
+
+ lib/master.c |   15 ++++++++++++++-
+ 1 file changed, 14 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -535,13 +535,26 @@ void send_map_update_request(struct auto
+ 
+ void master_source_writelock(struct master_mapent *entry)
+ {
++	int retries = 5; /* 1 second maximum */
+ 	int status;
+ 
+-	status = pthread_rwlock_wrlock(&entry->source_lock);
++	while (retries--) {
++		status = pthread_rwlock_wrlock(&entry->source_lock);
++		if (status != EAGAIN)
++			break;
++		else {
++                	struct timespec t = { 0, 200000000 };
++	                struct timespec r;
++                	while (nanosleep(&t, &r) == -1 && errno == EINTR)
++                        	memcpy(&t, &r, sizeof(struct timespec));
++		}
++	}
++
+ 	if (status) {
+ 		logmsg("master_mapent source write lock failed");
+ 		fatal(status);
+ 	}
++
+ 	return;
+ }
+ 
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-code-analysis-fixes-1.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-code-analysis-fixes-1.patch
@@ -0,0 +1,95 @@
+autofs-5.0.6 - code analysis fixes 1
+
+From: Ian Kent <ikent@redhat.com>
+
+Code analysis defect fixes, installment 1.
+
+- fix signed usage of unsigned variable in do_srv_query().
+- make NULL check handling of variable dcs explicit in get_dc_list().
+  - adding an explicit NULL check for variable dcs gaurds against
+    future changes in get_srv_rrs() returning success while not
+    clearing the dcs variable.
+  - makes it explict for readers why we don't need to check for NULL
+    before free later in the loop.
+- fix typo in do_reconnect()
+  - uri is never set now and, at this point, we need to try to connect
+    to the last server uri (ctxt->uri->uri) which is set in find_server()
+    when ctxt->uri is NULL.
+---
+
+ CHANGELOG             |    1 +
+ modules/dclist.c      |   11 +++++------
+ modules/lookup_ldap.c |    3 +--
+ 3 files changed, 7 insertions(+), 8 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -66,6 +66,7 @@
+ - fix paged query more results check.
+ - fix dumpmaps not reading maps.
+ - improve mount location error reporting.
++- code analysis defect fixes, installment 1.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/dclist.c
++++ autofs-5.0.5/modules/dclist.c
+@@ -69,7 +69,7 @@ static void dclist_mutex_unlock(void)
+ 
+ static int do_srv_query(unsigned int logopt, char *name, u_char **packet)
+ {
+-	unsigned int len = PACKETSZ;
++	int len = PACKETSZ;
+ 	unsigned int last_len = len;
+ 	char ebuf[MAX_ERR_BUF];
+ 	u_char *buf;
+@@ -500,7 +500,8 @@ struct dclist *get_dc_list(unsigned int 
+ 		}
+ 
+ 		dclist_mutex_lock();
+-		if (!get_srv_rrs(logopt, request, &dcs, &numdcs)) {
++		ret = get_srv_rrs(logopt, request, &dcs, &numdcs);
++		if (!ret | !dcs) {
+ 			error(logopt,
+ 			      "DNS SRV query failed for domain %s", domain);
+ 			dclist_mutex_unlock();
+@@ -526,8 +527,7 @@ struct dclist *get_dc_list(unsigned int 
+ 		if (!tmp) {
+ 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+ 			error(logopt, "realloc: %s", estr);
+-			if (dcs)
+-				free_srv_rrs(dcs, numdcs);
++			free_srv_rrs(dcs, numdcs);
+ 			goto out_error;
+ 		}
+ 
+@@ -548,8 +548,7 @@ struct dclist *get_dc_list(unsigned int 
+ 				if (ret > 6) {
+ 					error(logopt,
+ 					      "invalid port: %u", dcs[i].port);
+-					if (dcs)
+-						free_srv_rrs(dcs, numdcs);
++					free_srv_rrs(dcs, numdcs);
+ 					goto out_error;
+ 				}
+ 				strcat(tmp, port);
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -734,7 +734,6 @@ static LDAP *find_server(unsigned logopt
+ static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
+ {
+ 	LDAP *ldap = NULL;
+-	char *uri;
+ 
+ 	if (ctxt->server || !ctxt->uris) {
+ 		ldap = do_connect(logopt, ctxt->server, ctxt);
+@@ -778,7 +777,7 @@ static LDAP *do_reconnect(unsigned logop
+ 	 */
+ 	if (!ldap) {
+ 		autofs_sasl_dispose(ctxt);
+-		ldap = connect_to_server(logopt, uri, ctxt);
++		ldap = connect_to_server(logopt, ctxt->uri->uri, ctxt);
+ 	}
+ #endif
+ 	if (ldap)
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-dumpmaps-not-reading-maps.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-dumpmaps-not-reading-maps.patch
@@ -0,0 +1,43 @@
+autofs-5.0.6 - fix dumpmaps not reading maps
+
+From: Ian Kent <raven@themaw.net>
+
+The lookup modules won't read any indirect map entries (other than those
+in a file map) unless unless the browse option is set. In order to list
+the entries when tyhe dumpmap option is given the browse option needs to
+be set.
+---
+
+ CHANGELOG    |    1 +
+ lib/master.c |    9 +++++++++
+ 2 files changed, 10 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -64,6 +64,7 @@
+ - check each dc server individually.
+ - replace GPLv3 with GPLv2 code for SRV record handling.
+ - fix paged query more results check.
++- fix dumpmaps not reading maps.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/lib/master.c
++++ autofs-5.0.5/lib/master.c
+@@ -1275,6 +1275,15 @@ int master_show_mounts(struct master *ma
+ 		printf("\nMount point: %s\n", ap->path);
+ 		printf("\nsource(s):\n");
+ 
++		/*
++		 * Ensure we actually read indirect map entries so we can
++		 * list them. The map reads won't read any indirect map
++		 * entries (other than those in a file map) unless the
++		 * browse option is set.
++		 */
++		if (ap->type == LKP_INDIRECT)
++			ap->flags |= MOUNT_FLAG_GHOST;
++
+ 		/* Read the map content into the cache */
+ 		if (lookup_nss_read_map(ap, NULL, now))
+ 			lookup_prune_cache(ap, now);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-improve-mount-location-error-reporting.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-improve-mount-location-error-reporting.patch
@@ -0,0 +1,49 @@
+autofs-5.0.6 - fix improve mount location error reporting
+
+From: Ian Kent <raven@themaw.net>
+
+The validate_location() function is meant to check for a small subset
+of map location errors only but the "improve mount location error
+reporting" patch inverted a logic test which has made the scope of
+the test greater causing false positive fails. So add a check for
+those special cases and return success instead.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   12 ++++++++++++
+ 2 files changed, 13 insertions(+)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -67,6 +67,7 @@
+ - fix dumpmaps not reading maps.
+ - improve mount location error reporting.
+ - code analysis defect fixes, installment 1.
++- fix improve mount location error reporting.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -868,6 +868,20 @@ static int validate_location(unsigned in
+ 	 * have ":", "[" and "]".
+ 	 */
+ 	if (!check_colon(ptr)) {
++		char *esc;
++		/*
++		 * Don't forget cases where a colon is present but
++		 * not followed by a "/" or, if there is no colon at
++		 * all, we don't know if it is actually invalid since
++		 * it may be a map name by itself, for example.
++		 */
++		if (!strchr(ptr, ':') ||
++		    ((esc = strchr(ptr, '\\')) && *(esc + 1) == ':') ||
++		    !strncmp(ptr, "file:", 5) || !strncmp(ptr, "yp:", 3) ||
++		    !strncmp(ptr, "nis:", 4) || !strncmp(ptr, "nisplus:", 8) ||
++		    !strncmp(ptr, "ldap:", 5) || !strncmp(ptr, "ldaps:", 6) ||
++		    !strncmp(ptr, "dir:", 4))
++			return 1;
+ 		error(logopt,
+ 		      "expected colon delimeter not found in location %s",
+ 		      loc);
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-paged-query-more-results-check.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-fix-paged-query-more-results-check.patch
@@ -0,0 +1,83 @@
+autofs-5.0.6 - fix paged query more results check
+
+From: Ian Kent <ikent@redhat.com>
+
+When getting paged results from an LDAP server the server returns an
+opaque cookie (of type berval) that is used to retrieve the next page.
+The criteria for deciding if there are more pages is that the berval
+value is non-null and has a non-zero length.
+
+To determine if the berval value has non-zero length autofs checks the
+strlen() of the value but on ppc64 and s390x this can return 0 even if
+the value has non-zero length causing a premature termination of the
+query.
+
+Fix this by also checking the berval length field.
+Also make sure we free the opaque cookie when the query is finished.
+---
+
+ CHANGELOG             |    1 +
+ modules/lookup_ldap.c |   13 ++++++++++++-
+ 2 files changed, 13 insertions(+), 1 deletion(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -63,6 +63,7 @@
+ - fix mapent becomes negative during lookup.
+ - check each dc server individually.
+ - replace GPLv3 with GPLv2 code for SRV record handling.
++- fix paged query more results check.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/lookup_ldap.c
++++ autofs-5.0.5/modules/lookup_ldap.c
+@@ -2041,7 +2041,8 @@ do_paged:
+ 	rv = ldap_parse_page_control(sp->ldap,
+ 				     returnedControls, &sp->totalCount,
+ 				     &sp->cookie);
+-	if (sp->cookie && sp->cookie->bv_val && strlen(sp->cookie->bv_val))
++	if (sp->cookie && sp->cookie->bv_val &&
++	    (strlen(sp->cookie->bv_val) || sp->cookie->bv_len))
+ 		sp->morePages = TRUE;
+ 	else
+ 		sp->morePages = FALSE;
+@@ -2382,6 +2383,10 @@ static int read_one_map(struct autofs_po
+ 		    rv == LDAP_SIZELIMIT_EXCEEDED) {
+ 			if (sp.result)
+ 				ldap_msgfree(sp.result);
++			if (sp.cookie) {
++				ber_bvfree(sp.cookie);
++				sp.cookie = NULL;
++			}
+ 			sp.pageSize = sp.pageSize / 2;
+ 			if (sp.pageSize < 5) {
+ 				debug(ap->logopt, MODPREFIX
+@@ -2397,6 +2402,8 @@ static int read_one_map(struct autofs_po
+ 		if (rv != LDAP_SUCCESS || !sp.result) {
+ 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 			*result_ldap = rv;
++			if (sp.cookie)
++				ber_bvfree(sp.cookie);
+ 			free(sp.query);
+ 			return NSS_STATUS_UNAVAIL;
+ 		}
+@@ -2406,6 +2413,8 @@ static int read_one_map(struct autofs_po
+ 			ldap_msgfree(sp.result);
+ 			unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 			*result_ldap = rv;
++			if (sp.cookie)
++				ber_bvfree(sp.cookie);
+ 			free(sp.query);
+ 			return NSS_STATUS_NOTFOUND;
+ 		}
+@@ -2417,6 +2426,8 @@ static int read_one_map(struct autofs_po
+ 	unbind_ldap_connection(ap->logopt, sp.ldap, ctxt);
+ 
+ 	source->age = age;
++	if (sp.cookie)
++		ber_bvfree(sp.cookie);
+ 	free(sp.query);
+ 
+ 	return NSS_STATUS_SUCCESS;
Index: backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-improve-mount-location-error-reporting.patch
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/autofs-5.0.6-improve-mount-location-error-reporting.patch
@@ -0,0 +1,113 @@
+autofs-5.0.6 - improve mount location error reporting
+
+From: Ian Kent <raven@themaw.net>
+
+Try and report a more sensible error when an invalid location is
+encountered.
+---
+
+ CHANGELOG           |    1 +
+ modules/parse_sun.c |   32 ++++++++++++++++++--------------
+ 2 files changed, 19 insertions(+), 14 deletions(-)
+
+
+--- autofs-5.0.5.orig/CHANGELOG
++++ autofs-5.0.5/CHANGELOG
+@@ -65,6 +65,7 @@
+ - replace GPLv3 with GPLv2 code for SRV record handling.
+ - fix paged query more results check.
+ - fix dumpmaps not reading maps.
++- improve mount location error reporting.
+ 
+ 03/09/2009 autofs-5.0.5
+ -----------------------
+--- autofs-5.0.5.orig/modules/parse_sun.c
++++ autofs-5.0.5/modules/parse_sun.c
+@@ -853,7 +853,7 @@ add_offset_entry(struct autofs_point *ap
+ 	return ret;
+ }
+ 
+-static int validate_location(char *loc)
++static int validate_location(unsigned int logopt, char *loc)
+ {
+ 	char *ptr = loc;
+ 
+@@ -867,14 +867,22 @@ static int validate_location(char *loc)
+ 	 * and "@" in the host name part and ipv6 addresses that
+ 	 * have ":", "[" and "]".
+ 	 */
+-	if (check_colon(ptr)) {
++	if (!check_colon(ptr)) {
++		error(logopt,
++		      "expected colon delimeter not found in location %s",
++		      loc);
++		return 0;
++	} else {
+ 		while (*ptr && strncmp(ptr, ":/", 2)) {
+ 			if (!(isalnum(*ptr) ||
+ 			    *ptr == '-' || *ptr == '.' || *ptr == '_' ||
+ 			    *ptr == ',' || *ptr == '(' || *ptr == ')' ||
+ 			    *ptr == '#' || *ptr == '@' || *ptr == ':' ||
+-			    *ptr == '[' || *ptr == ']'))
++			    *ptr == '[' || *ptr == ']')) {
++				error(logopt, "invalid character \"%c\" "
++				      "found in location %s", *ptr, loc);
+ 				return 0;
++			}
+ 			ptr++;
+ 		}
+ 
+@@ -883,8 +891,10 @@ static int validate_location(char *loc)
+ 	}
+ 
+ 	/* Must always be something following */
+-	if (!*ptr)
++	if (!*ptr) {
++		error(logopt, "invalid location %s", loc);
+ 		return 0;
++	}
+ 
+ 	return 1;
+ }
+@@ -951,8 +961,7 @@ static int parse_mapent(const char *ent,
+ 		return 0;
+ 	}
+ 
+-	if (!validate_location(loc)) {
+-		warn(logopt, MODPREFIX "invalid location %s", loc);
++	if (!validate_location(logopt, loc)) {
+ 		free(myoptions);
+ 		free(loc);
+ 		return 0;
+@@ -985,9 +994,7 @@ static int parse_mapent(const char *ent,
+ 			return 0;
+ 		}
+ 
+-		if (!validate_location(ent_chunk)) {
+-			warn(logopt,
+-			      MODPREFIX "invalid location %s", ent_chunk);
++		if (!validate_location(logopt, ent_chunk)) {
+ 			free(ent_chunk);
+ 			free(myoptions);
+ 			free(loc);
+@@ -1688,8 +1695,7 @@ int parse_mount(struct autofs_point *ap,
+ 			return 1;
+ 		}
+ 
+-		if (!validate_location(loc)) {
+-			warn(ap->logopt, MODPREFIX "invalid location %s", loc);
++		if (!validate_location(ap->logopt, loc)) {
+ 			free(loc);
+ 			free(options);
+ 			return 1;
+@@ -1714,9 +1720,7 @@ int parse_mount(struct autofs_point *ap,
+ 				return 1;
+ 			}
+ 
+-			if (!validate_location(ent)) {
+-				warn(ap->logopt,
+-				     MODPREFIX "invalid location %s", loc);
++			if (!validate_location(ap->logopt, ent)) {
+ 				free(ent);
+ 				free(loc);
+ 				free(options);
Index: backfire/feeds/packages/utils/autofs/patches/series
===================================================================
--- /dev/null
+++ backfire/feeds/packages/utils/autofs/patches/series
@@ -0,0 +1,82 @@
+autofs-5.0.5-fix-included-map-read-fail-handling.patch
+autofs-5.0.5-refactor-ldap-sasl-bind.patch
+autofs-5.0.4-add-mount-wait-parameter.patch
+autofs-5.0.5-special-case-cifs-escapes.patch
+autofs-5.0.5-fix-libxml2-workaround-configure.patch
+autofs-5.0.5-more-code-analysis-corrections.patch
+autofs-5.0.5-fix-backwards-ifndef-INET6.patch
+autofs-5.0.5-fix-stale-init-for-file-map-instance.patch
+autofs-5.0.5-fix-ext4-fsck-at-mount.patch
+autofs-5.0.5-dont-use-master_lex_destroy-to-clear-parse-buffer.patch
+autofs-5.0.5-make-documentation-for-set-log-priority-clearer.patch
+autofs-5.0.5-fix-timeout-in-connect_nb.patch
+autofs-5.0.5-fix-pidof-init-script-usage.patch
+autofs-5.0.5-check-for-path-mount-location-in-generic-module.patch
+autofs-5.0.5-dont-fail-mount-on-access-fail.patch
+autofs-5.0.5-fix-rpc-large-export-list.patch
+autofs-5.0.5-dont-connect-at-ldap-lookup-module-init.patch
+autofs-5.0.5-fix-reconnect-get-base-dn.patch
+autofs-5.0.5-fix-random-selection-option.patch
+autofs-5.0.5-fix-disable-timeout.patch
+autofs-5.0.5-fix-strdup-return-value-check.patch
+autofs-5.0.5-fix-get-qdn-fail.patch
+autofs-5.0.5-fix-ampersand-escape-in-auto-smb.patch
+autofs-5.0.5-make-nfs4-default-for-redhat-replicated-selection.patch
+autofs-5.0.5-add-autofs_ldap_auth_conf-man-page.patch
+autofs-5.0.5-fix-random-selection-for-host-on-different-network.patch
+autofs-5.0.5-make-redhat-init-script-more-lsb-compliant.patch
+autofs-5.0.5-add-sasl-mutex-callbacks.patch
+autofs-5.0.5-fix-parse_sun-module-init.patch
+autofs-5.0.5-dont-check-null-cache-on-expire.patch
+autofs-5.0.5-fix-null-cache-race.patch
+autofs-5.0.5-fix-cache_init-on-source-re-read.patch
+autofs-5.0.5-fix-negative-cache-included-map-lookup.patch
+autofs-5.0.5-remove-state-machine-timed-wait.patch
+autofs-5.0.5-add-locality-as-valid-ldap-master-map-attribute.patch
+autofs-5.0.5-fix-remount-locking.patch
+autofs-5.0.5-fix-restart.patch
+autofs-5.0.5-always-read-file-maps-mount-lookup-map-read-fix.patch
+autofs-5.0.5-add-external-bind-method.patch
+autofs-5.0.5-add-simple-bind-auth.patch
+autofs-5.0.5-fix-add-simple-bind-auth.patch
+autofs-5.0.5-use-weight-only-for-server-selection.patch
+autofs-5.0.5-fix-isspace-wild-card-substition.patch
+autofs-5.0.5-add-lsb-force-reload-and-try-restart.patch
+autofs-5.0.5-include-ip-address-in-debug-logging.patch
+autofs-5.0.5-mount-using-address-for-rr.patch
+autofs-5.0.5-fix-direct-map-not-updating-on-reread.patch
+autofs-5.0.5-include-krb5-library.patch
+autofs-5.0.5-remove-ERR_remove_state-openssl-call.patch
+autofs-5.0.5-fix-next-task-list-update.patch
+autofs-5.0.5-fix-stale-map-read.patch
+autofs-5.0.5-fix-null-cache-clean.patch
+autofs-5.0.5-automount-8-man-page-correction.patch
+autofs-5.0.5-dont-hold-lock-for-simple-mounts.patch
+autofs-5.0.5-fix-prune-cache-valid-check.patch
+autofs-5.0.5-fix-map-source-check-in-file-lookup.patch
+autofs-5.0.5-wait-for-master-source-mutex.patch
+autofs-5.0.5-auto-adjust-ldap-page-size.patch
+autofs-5.0.5-fix-paged-ldap-map-read.patch
+autofs-5.0.5-add-base64-password-encode.patch
+autofs-5.0.5-add-dump-maps-option.patch
+autofs-5.0.5-reset-negative-status-on-cache-prune.patch
+autofs-5.0.5-fix-wildcard-map-entry-match.patch
+autofs-5.0.5-fix-sasl-bind-host-name-selection.patch
+autofs-5.0.5-fix-sanity-checks-for-brackets-in-server-name.patch
+autofs-5.0.5-mapent-becomes-negative-during-lookup.patch
+autofs-5.0.5-check-each-dc-server.patch
+autofs-5.0.5-fix-null-cache-deadlock.patch
+autofs-5.0.5-replace-gplv3-code.patch
+autofs-5.0.6-fix-paged-query-more-results-check.patch
+autofs-5.0.6-fix-dumpmaps-not-reading-maps.patch
+autofs-5.0.6-improve-mount-location-error-reporting.patch
+autofs-5.0.6-code-analysis-fixes-1.patch
+autofs-5.0.6-fix-improve-mount-location-error-reporting.patch
+200-fix-configure-not-run-when-cross-compiling
+201-uclibc-compat
+202-disable-yp-lookup
+203-disable-ldap-code-in-defaults
+205-fix-install-symlinks
+206-disable-parsing-nsswitch
+207-make-runtime-dep-commands-configurable
+208-dynamic-lookup-file
